/*
	Copyright (c) 2004-2011, The Dojo Foundation All Rights Reserved.
	Available via Academic Free License >= 2.1 OR the modified BSD license.
	see: http://dojotoolkit.org/license for details
*/

/*
	This is an optimized version of Dojo, built for deployment and not for
	development. To get sources and documentation, please visit:

		http://dojotoolkit.org
*/

dojo.provide("wm");
if(!dojo._hasResource['wm.base.components.componentList']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['wm.base.components.componentList'] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide('wm.base.components.componentList');


/************************************************************************************
 * MICHAEL'S ATTEMPT TO DESCRIBE THIS:
 *
 * Component.js only tries to access this list if the class isn't already loaded.
 * Any class we try to load and is NOT in this list is assumed to be in common/packages.
 * Therefore: any class you load must either already be loaded or listed here.
 * If that class is NOT a part of any existing layer, then enter in its standard package name
 * so dojo.require can run normally.  Still working out details of how to create new build layers.
 ************************************************************************************/
wm.componentFixList = {_phonegap:[]};
wm.componentList = {
    'wm.Content': ['wm.base.widget.Content'],
    'wm.DataGrid': ['build.Gzipped.wm_data_grid'],
    'wm.DojoGrid': ['build.Gzipped.wm_dojo_grid'],
    'wm.DojoMenu': ['build.Gzipped.wm_menus'],
    'wm.PopupMenu': ['build.Gzipped.wm_menus'],
    'wm.DojoChart': ['build.Gzipped.wm_charts'],
    'wm.DojoGauge': ['build.Gzipped.wm_charts'],
    'wm.Dashboard': ['build.Gzipped.wm_editors', 'build.Gzipped.wm_dashboard'],
    'wm.AccordionLayers': ['build.Gzipped.wm_accordion'],
    'wm.WizardLayers': ['build.Gzipped.wm_wizardlayer'],
    'wm.BreadcrumbLayers': ['build.Gzipped.wm_breadcrumblayer'],
    'wm.ColorPicker': ['build.Gzipped.wm_colorpicker'],
    'wm.RichTextDialog': ['wm.base.widget.Dialogs.RichTextDialog'],
    'wm.DojoFisheye': ['wm.base.widget.DojoFisheye'],
    'wm.DojoLightbox': ['wm.base.widget.DojoLightbox'],
    'wm.TwitterFeed': ['wm.base.widget.TwitterFeed'],
    'wm.JsonStatus': ['build.Gzipped.wm_editors'],
    'wm.Tree': ['build.Gzipped.wm_trees'],
    'wm.PropertyTree': ['build.Gzipped.wm_trees'],
    'wm.ObjectTree': ['build.Gzipped.wm_trees'],
    "wm.DraggableTree": ['build.Gzipped.wm_trees'],
    'wm.Gadget': ["wm.base.widget.gadget.Gadget"],
    'wm.gadget.YouTube': ["wm.base.widget.gadget.YouTube"],
    'wm.gadget.FacebookLikeButton': ["wm.base.widget.gadget.Facebook"],
    'wm.gadget.FacebookActivityFeed': ["wm.base.widget.gadget.Facebook"],
    'wm.gadget.GoogleMap': ["wm.base.widget.gadget.GoogleMap"],
    'wm.gadget.Stocks': ["wm.base.widget.gadget.Stocks"],
    'wm.gadget.Weather': ["wm.base.widget.gadget.Weather"],
    'wm.gadget.TwitterFollowButton': ["wm.base.widget.gadget.TwitterGadgets"],
    'wm.gadget.TwitterTweetButton': ["wm.base.widget.gadget.TwitterGadgets"],
    'wm.gadget.TwitterList': ["wm.base.widget.gadget.TwitterGadgets"],
    'wm.TwitterFeed': ["wm.base.widget.TwitterFeed"],

    'wm.RichText': ['build.Gzipped.wm_editors', 'build.Gzipped.wm_richTextEditor'],

    'wm.CheckBoxEditor': ['build.Gzipped.wm_editors_old'],
    'wm.RadioButtonEditor': ['build.Gzipped.wm_editors_old'],
    'wm.SelectEditor': ['build.Gzipped.wm_editors_old'],
    'wm.TextEditor': ['build.Gzipped.wm_editors_old'],
    'wm.SliderEditor': ['build.Gzipped.wm_editors_old'],
    'wm._SliderEditor': ['build.Gzipped.wm_editors_old'],
    'wm.TextAreaEditor': ['build.Gzipped.wm_editors_old'],
    'wm._TextEditor': ['build.Gzipped.wm_editors_old'],
    'wm.CurrencyEditor': ['build.Gzipped.wm_editors_old'],
    'wm.NumberEditor': ['build.Gzipped.wm_editors_old'],
    'wm.Editor': ['build.Gzipped.wm_editors_old'],
    'wm.DateEditor': ['build.Gzipped.wm_editors_old'],
    'wm.TimeEditor': ['build.Gzipped.wm_editors_old'],
    'wm.Select': ['build.Gzipped.wm_editors_old'],

    'wm.Date': ['build.Gzipped.wm_editors'],
    'wm.DateTime': ['build.Gzipped.wm_editors', "build.Gzipped.wm_list"],
    'wm.SelectMenu': ['build.Gzipped.wm_editors'],
    'wm.Lookup': ['build.Gzipped.wm_editors'],
    'wm.FilteringLookup': ['build.Gzipped.wm_editors'],
    'wm.CheckboxSet': ['build.Gzipped.wm_editors'],
    'wm.RadioSet': ['build.Gzipped.wm_editors_misc'],
    'wm.ListSet': ['build.Gzipped.wm_editors', "build.Gzipped.wm_list"],
    'wm.Number': ['build.Gzipped.wm_editors'],
    'wm.Checkbox': ['build.Gzipped.wm_editors'],
    'wm.RadioButton': ['build.Gzipped.wm_editors_misc'],
    //'wm.RadioSet':['build.Gzipped.wm_editors_misc'],
    'wm.Currency': ['build.Gzipped.wm_editors'],

    'wm.Slider': ['build.Gzipped.wm_editors_misc'],
    'wm.Text': ['build.Gzipped.wm_editors'],
    'wm.TextArea': ['build.Gzipped.wm_editors'],
    'wm.Time': ['build.Gzipped.wm_editors'],
    'wm.LargeTextArea': ['build.Gzipped.wm_editors'],

    'wm.dijit.Dijit': ['wm.base.widget.dijit.Dijit'],
    'wm.dijit.ProgressBar': ['build.Gzipped.wm_progressbar'],
    'wm.RoundedButton': ['wm.base.widget.Buttons.RoundedButton'],
    'wm.BusyButton': ['wm.base.widget.Buttons.BusyButton'],
    'wm.PopupMenuButton': ['build.Gzipped.wm_menus'],
    'wm.ToggleButton': ['build.Gzipped.wm_editors'],
    // currently in main build
    'wm.ToggleButtonPanel': ['build.Gzipped.wm_editors'],
    // currently in main build
    'wm.Timer': ['wm.base.components.Timer'],

    /* Old forms and related widgets */
    'wm.SimpleForm': ['build.Gzipped.wm_livepanel'],
    'wm.LiveForm': ['build.Gzipped.wm_livepanel'],
    'wm.RelatedEditor': ['build.Gzipped.wm_livepanel'],
    'wm.LivePanel': ['build.Gzipped.wm_livepanel'],
    'wm.EditPanel': ['build.Gzipped.wm_livepanel'],
    'wm.DataNavigator': ['build.Gzipped.wm_livepanel'],
    'wm.RegularExpressionFormatter': ["wm.base.widget.FormattersMisc"],
    'wm.EvaluationFormatter': ["wm.base.widget.FormattersMisc"],
    'wm.LinkFormatter': ["wm.base.widget.FormattersMisc"],
    'wm.ImageFormatter': ["wm.base.widget.FormattersMisc"],
    /* New Forms */
    'wm.DataForm': ['build.Gzipped.wm_dataform'],
    'wm.FormPanel': ['build.Gzipped.wm_dataform'],
    'wm.SubForm': ['build.Gzipped.wm_dataform'],
    'wm.DBForm': ['build.Gzipped.wm_dataform'],
    'wm.OneToMany': ['wm.compressed.wm_dataform'],
    'wm.ServiceInputForm': ['build.Gzipped.wm_dataform'],
    'wm.ServiceQueue': ['wm.base.components.ServiceQueue'],
    //'wm.Picture': ["wm.base.widget.Picture"],
    'wm.dijit.Calendar': ["build.Gzipped.wm_editors"],
    'wm.Template': ['wm.base.widget.Template'],

    'wm.ComponentPublisher': ["wm.base.components.Publisher"],
    'wm.CompositePublisher': ["wm.base.components.Publisher"],
    'wm.TemplatePublisher': ["wm.base.components.Publisher"],
    'wm.Composite': ['wm.base.widget.Composite'],
    'wm.CompositeMixin': ['wm.base.widget.Composite'],
    'wm.Ticker': ['wm.base.widget.Ticker'],
    'wm.FileUpload': ['wm.base.widget.FileUpload'],
    'wm.DojoFileUpload': ['build.Gzipped.wm_fileupload'],
    'wm.DojoFlashFileUpload': ['build.Gzipped.wm_fileupload'],
    'wm.DijitDesigner': ["wm.base.widget.dijit.Dijit"],

    //'wm.Popup':['wm.base.widget.Popup'],
    'wm.FunctionService': ['wm.base.components.FunctionService'],
    'wm.List': ["build.Gzipped.wm_list"],
    'wm.IFrame': ['wm.base.widget.IFrame'],
    'wm.FeedList': ['wm.base.widget.FeedList'],
    'wm.ListViewer': ['wm.base.widget.ListViewer'],
    'wm.PhoneGapService': ['wm.base.components.PhoneGapService'],
    'wm.XhrService': ['wm.base.components.XhrService'],
    'wm.LogoutVariable': ['wm.base.components.LogoutVariable']
}

/* wm.require is the public version of wm.getComponentStructure; inCommon is optional parameter
 * to use when loading a class from the common folder
 */
wm.require = function(inType, inCommon) {
    if (dojo.getObject(inType)) return;
    var requireList = wm.componentList[inType];
    if (requireList || inCommon) return wm.getComponentStructure(inType);
    else dojo["require"](inType);
}

wm.getComponentStructure = function(inType) {
    //console.info('Loading ' + inType + ' dynamically.');
    if (inType == "wm.DojoGrid" && wm.isMobile) {
        inType = "wm.List";
    }
    var requireList = wm.componentList[inType];

    // if we dont get the require list, then we assume that it is a composite widget
    // so we will try to load it.
    if (!requireList) {
        // this is done for custom widgets.
        if (inType.indexOf('wm.') == 0) {
            inType = inType.substring(3);
        }

        /* This code is obsolete as of WM 6.6; see WM-4750: https://github.com/SpringSource/wavemaker/commit/aa3d2c28721740c0182b0a98e3674ee3c1114c60 */
        requireList = ['wm.base.widget.Composite', 'wm.packages.' + inType];
        //console.info('Trying to load composite: ' + requireList);
    }

    if (!requireList) {
        console.error('Add ' + inType + ' in component list.');
    } else {
        for (var i = 0; i < requireList.length; i++) {
            var relpath = dojo._getModuleSymbols(requireList[i]).join("/") + ".js";
            var uri;
            // If its a phonegap request to common/packages, then don't prefix dojo.baseUrl; common folder
            // has been copied into the project's webapp folder.
            if (wm.isPhonegap && requireList[i].match(/^(wm|common)\.packages\./)) {
                uri = relpath;
            } else {
                uri  = ((relpath.charAt(0) == "/" || relpath.match(/^\w+:/)) ? "" : dojo.baseUrl) + relpath;
            }
            while (uri.match(/[^\/]\/\.\.\//)) {
                uri = uri.replace(/[^\/]*\/\.\.\/+/, "");
            }
            wm.dojoScriptLoader(uri);
            if (wm.componentFixList[requireList[i]]) {
                var fixes = wm.componentFixList[requireList[i]];
                for (var j = 0; j < fixes.length; j++) {
                    fixes[j]();
                }
            }
        }
    }
    if (wm.isMobile && inType == "wm.List") {
        wm.DojoGrid = wm.List;
    }
}

/*
   // Usage:
   // inClass: wm.Button
   // packageList: null, the default build layer is loaded before the patches file, and wm.Button is loaded
    wm.addFrameworkFix("wm.Button", null, function() {
        wm.Button.extend({
            click: function() {
                alert("Dont click on buttons");
            }
        });
    });

    // N
    wm.addFrameworkFix("wm.List", ["build.Gzipped.wm_list"], function() {
        wm.List.extend({
            setScrollTop: function() {
                alert("HEY");
            }
        });
    });
*/

/**************
// So why do we need to pass in wm_dojo_grid when thats indexed by the wm.componentList hash?
// Because there might be more than one thing that causes a given widget class to load;
// sometimes interdependencies can cause less obvious packages to cause wm.DojoGrid to be loaded
wm.addFrameworkFix("wm.DojoGrid", ['build.Gzipped.wm_dojo_grid'], function() {
   wm.DojoGrid.extend({
      ...
   })
});

// So why not just do wm.PageContainer.extend without wm.addFrameworkFix?  Because for a phonegap
// build, wm.PageContainer isn't defined until after the patches have loaded.  Use null or [] for
// the second parameter so that it gets added to the phonegap's fix list
wm.addFrameworkFix("wm.PageContainer", null, function() {
   wm.PageContainer.extend({
      ...
   })
});

**************/
wm.addFrameworkFix = function(className, packageList, inFunc) {
    /* All classes are preloaded in debug mode; just fire inFunc */
    if (djConfig.isDebug && !wm.studioConfig) {
        inFunc();
    } else {
        var ctor = dojo.getObject(className);
        /* If the class has already been loaded, call inFunc() */
        if (ctor) {
            inFunc();
        } else if (packageList && packageList.length) {
            dojo.forEach(packageList, function(packageName) {
                if (!wm.componentFixList[packageName]) {
                    wm.componentFixList[packageName] = [inFunc];
                } else {
                    wm.componentFixList[packageName].push(inFunc);
                }
            });
        } else {
            wm.componentFixList._phonegap.push(inFunc); // phonegap build loads patches file before loading its standard package library
        }
    }
}

wm.applyFrameworkFixes = function() {
    for (var packageName in wm.componentFixList) {
        var ctor = dojo.getObject(packageName);
        if (ctor) {
            var classFixes = wm.componentFixList[packageName];
            for (var i = 0; i < packageName.length; i++) {
                classFixes[i]();
            }
            delete wm.componentFixList[packageName];
        }
    }
}

//wm.loadLib("common." + wm.version.replace(/[^a-zA-Z0-9]/g,"") + "_patches"); moved to Application.js

}

if(!dojo._hasResource['wm.base.lib.util']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['wm.base.lib.util'] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide('wm.base.lib.util');

/**
	@namespace Master namespace for all WaveMaker library objects.
*/
wm = window["wm"] || {};

// simple logging
wm.logErrors = false;
wm.log = function() {
	console.log.apply(console, arguments);
}

// strings

wm.capitalize = function(s) {
	return s ? s.charAt(0).toUpperCase() + s.slice(1) : "";
}

wm.decapitalize = function(s) {
	return s ? s.charAt(0).toLowerCase() + s.slice(1) : "";
}

wm.camelcase = function(s) {
    return s.replace(/[\.-](.?)/g, function(inChar) {console.log(inChar);return inChar[1].toUpperCase();})
}

wm.flattenObject = function(inObj, keepOld) {
    var outObj = {};
    for (var prop in inObj) {
	if (!inObj[prop])
	    continue;

	if (typeof inObj[prop] != "object") {
	    outObj[prop] = inObj[prop];
	} else {
	    var tmpObj = wm.flattenObject(inObj[prop]);
	    if (keepOld) outObj[prop] = tmpObj;
	    for (var prop2 in tmpObj) outObj[prop + "." + prop2] = tmpObj[prop2];
	}
    }
    return outObj;
}

/* Use this instead of dojo.clone when you don't want to recurse through the full depth
 * of the object.  Full recursion can cause infinite recursion; almost certain to do this
 * for a Component which has an owner and child component where each points to the other.
 */
 wm.shallowClone = function(inObj) {
    var result = {};
    wm.forEachProperty(inObj, function(inValue, inKey) {
        result[inKey] = inValue;
    });
    return result;
 }

wm.requireCss = function(modulepath) {
/*
    var replaceSubstr = 'lib/dojo/dojo/../../../lib';
    if (modulepath.indexOf(replaceSubstr) == 0) {
	modulepath = "lib" + modulepath.substring(replaceSubstr.length);
    }
    modulepath = ((modulepath.charAt(0) == "/" || modulepath.match(/^\w+:/)) ? "" : dojo.baseUrl) + modulepath;

    var parts = modulepath.split(".");
    var filename = parts.pop();
    var path = parts.join(".");
    */

    var path = wm.dojoModuleToPath(modulepath) + ".css";
    wm.requireCssPath(path);
}
wm.dojoModuleToPath = function(modulepath) {
    var lastIndex = modulepath.lastIndexOf(".");
    var filename = modulepath.substring(lastIndex + 1);
    var modulepath = modulepath.substring(0,lastIndex);
    var path = dojo.moduleUrl(modulepath).path.replace(/lib\/\//, "lib/") + filename;

    while (path.match(/[^\/]\/\.\.\//)) {
        path = path.replace(/[^\/]*\/\.\.\/+/, "");
    }
    return path;
}
wm.requireCssPath = function(path) {
    var styleNodeId = "CSS_" + path.replace(/\./g,"_").replace(/\//g,"_");
    var stylenode = dojo.byId(styleNodeId);
    if (stylenode) return;

    stylenode = document.createElement("link");
    stylenode.rel = "stylesheet";
    stylenode.id = styleNodeId;
    stylenode.type="text/css";
    stylenode.href = path;
    document.getElementsByTagName("head")[0].appendChild(stylenode);
}


wm.isEqual = function (a1, a2){
	try{
		if(a1 == a2)
			return true;
		if(dojo.isArray(a1) && dojo.isArray(a2))
			return dojo.toJson([].concat(a1).sort()) == dojo.toJson([].concat(a2).sort())
		return dojo.toJson(a1) == dojo.toJson(a2)
	} catch(e) {
		console.info('Could not compare objects ', arguments, ' therefore returning false. Error ', e);
		return false;
	}
}

wm.compareStrings = function(a, b) {
	return a < b ? -1 : a == b ? 0 : 1;
}

wm.toTitleCase = function(s){
	return s.replace(/\b\w+\b/g, function(word) {
		return word ? word.charAt(0).toUpperCase() + (word.slice(1) || "").toLowerCase() : "";
	});
}

wm.delimCat = function(inPrefix, inSuffix, inDelim) {
	return inPrefix + (inPrefix && inSuffix ? inDelim : "") + inSuffix;
}

wm.joinEx = function(inValues, inDelim) {
	var i = 0;
	while (i < inValues.length) {
		if (inValues[i++] !== "")
			inValues.splice(--i, 1);
	}
	return inValues.join(inDelim);
}

// number

wm.isNumber = function(v) {
	return (typeof v == 'number') || (v instanceof Number);
}

wm.max = function(list) {
  var max = list[0];
  for (var i = 1; i < list.length; i++) if (list[i] > max) max = list[i];
  return max;
}
wm.sum = function(list) {
  var sum = 0;
  for (var i = 0; i < list.length; i++) sum += list[i];
  return sum;
}

wm.average = function(list) {
  return wm.sum(list)/list.length;
}

// lang

wm.nop = function() {};

wm.isEmpty = function(inObj) {
    /* ACE Editor's libraries changed fundamental aspects of javascript objects in IE such that our default handling here is invalid */
    if (window["studio"] && dojo.isIE == 8) {
	if (dojo.isArray(inObj) && inObj.length == 0) return true;
	if (typeof inObj == "object") {
	    for (var i in inObj) {
		if (!dojo.isFunction(inObj[i])) {
		    return false;
		}
	    }
	}

    } else {
	for (var i in inObj)
		return false;
    }
    // for (var i in inObj) finds no properties
    if (typeof inObj == "object" && inObj instanceof Date)
        return false;
    return true;
}

wm.fire = function(obj, method, args) {
	var f = obj && method && obj[method];
	if (f)
		return args ? f.apply(obj, args) : f.call(obj);
}

wm.async = function(f, delay) {
	return function(){setTimeout(f, delay || 1);};
}

wm.forEach = function(inObject, inFunc) {
	if (dojo.isArray(inObject))
		dojo.forEach(inObject, inFunc);
	else
		wm.forEachProperty(inObject, inFunc);
}

wm.forEachProperty = function(inObject, inFunc) {
	for (var i in inObject) {
	    if (!inObject.hasOwnProperty || inObject.hasOwnProperty(i)) {
		inFunc(inObject[i], i);
	    }
	}
}

wm.isDomShowing = function(inNode) {
    var n = inNode;
    while(n && n != window.document.body && n.style.display != "none") {
	n = n.parentNode;
    }
    return !n || n.style.display != "none";
}

wm.evalJs = function(inJavascript, inDefault) {
	var r = inDefault || "";
	try {
		r = eval(inJavascript);
	} catch(e) {
		wm.logging && console.log("Error evaluating Javascript:", e);
	}
	return r;
};

wm.getClassProp = function(inClassName, inProp) {
	var klass = dojo.getObject(inClassName);
	var ptype = klass && klass.prototype;
	return ptype && ptype[inProp];
}

// DOM

wm.showHideNode = function(inNode, inTrueToShow) {
	inNode.style.display = inTrueToShow ? "" : "none";
};

wm.kids = function(inNode, inTag) {
	var result = [], t=inTag.toUpperCase();
	for (var i=0, n; (n=inNode.childNodes[i]); i++)
		if (n.tagName == inTag)
			result.push(n);
	return result;
}

wm.divkids = function(inNode) {
	return wm.kids(inNode, 'div');
}

wm.clearSelection = function() {
	try{
		if (window.getSelection)
			window.getSelection().collapseToEnd();
		else if (document.selection)
			document.selection.clear();
	}catch(e){
	}
}

wm.focusOnIdle = function(inNode) {
	setTimeout(function() {
		try {
			wm.fire(inNode, "focus");
			wm.fire(inNode, "select");
		} catch(e) {};
	}, 1);
}

wm.inScrollbar = function(e) {
	var t = e.target;
	var s = t.style && dojo.getComputedStyle(t);
	return  s && (
		((s.overflow != 'hidden' || s.overflowX != 'hidden') && (t.scrollWidth != t.offsetWidth) && (t.offsetWidth - 19 - e.clientX < 0)) ||
		((s.overflow != 'hidden' || s.overflowY != 'hidden') && (t.scrollHeight != t.offsetHeight) && (t.offsetHeight - 19 - e.clientY < 0))
	);
};

wm.preloadImage = function(inPath) {
	var i = new Image();
	i.src = inPath;
	(wm.preloaded = (wm.preloaded || [])).push(i);
}

// style

wm.setUnitsBox = function(node, l, t, w, h) {
	with (node.style) {
		l&&(left = l);
		t&&(top = t);
		w&&(width = w);
		h&&(height = h);
	}
}

wm.getNaturalBox = function(node){
	var tn = node.tagName, cs = dojo.getComputedStyle(node), box = dojo._getContentBox(node, cs);
	if(tn=="BUTTON" || tn=="TABLE"){
		var pb = dojo._getPadBorderExtents(node, cs);
		box.w += pb.w;
		box.h += pb.h;
	}
	return box;
}

wm.calcOffset = function(inNode, inAncestor, inAdjustMargin) {
	var o = { x:0, y: 0}, n = inNode, cs, mb, be;
	while (n && n != inAncestor && n != document) {
		cs = dojo.getComputedStyle(n);
		mb = dojo._getMarginBox(n, cs);
		be = dojo._getBorderExtents(n, cs);
		me = inAdjustMargin ? dojo._getMarginExtents(n, cs) : {l:0, t:0};
		o.x += mb.l + be.l + me.l - (n.scrollLeft || 0);
		o.y += mb.t + be.t + me.t - (n.scrollTop || 0);
		n = n.parentNode;
	}
	return o;
}

wm.addRemoveClass = function(node, classn, addRemove) {
	dojo[addRemove ? "addClass" : "removeClass"](node, classn);
}

// misc

wm.onidle = function( /*hitch args*/ ) {
    var args = [];
    for (var i = 0; i in arguments; i++) {
        args.push(arguments[i]);
    }
    if (app && app.debugDialog) {
        var eventChain = app.debugDialog.cacheEventChain();
    }
    window.setTimeout(function() {
        if (eventChain) {
            app.debugDialog.restoreEventChain(eventChain);
        }
        dojo.hitch.apply(null, args)();
        if (eventChain) {
            app.debugDialog.clearEventChain();
        }
    }, 1);
}
wm.onidleChain = function(functionList, stateObj) {
    if (!stateObj) stateObj = {};
    var f2 = function(methods) {
            window.setTimeout(function() {
                var f = methods.shift();
                if (f) f();
                if (methods.length && !stateObj.canceled) f2(methods);
            }, 1);
        }
    if (!stateObj.canceled) f2(functionList, stateObj);

}
wm.job = function(inName, inDelay, inJob1, inJob2) {
    var inJob;
    if (inJob1 && inJob2) {
        inJob = dojo.hitch(inJob1, inJob2);
    } else if (inJob2) {
        inJob = inJob2;
    } else {
        inJob = inJob1;
    }
    wm.cancelJob(inName);
    if (window["app"] && app.debugDialog) {
        var eventChain = app.debugDialog.cacheEventChain();
    }
    var job = function() {
            delete wm._jobs[inName];
            if (eventChain) {
                app.debugDialog.restoreEventChain(eventChain);
            }
            inJob();
            if (eventChain) {
                app.debugDialog.clearEventChain();
            }
        }
    wm._jobs[inName] = setTimeout(job, inDelay);
}
wm.cancelJob = function(inName) {
    clearTimeout(wm._jobs[inName]);
}
wm._jobs = {};
wm.hasJob = function(inName) {
    return Boolean(wm._jobs[inName]);
}
wm.connectEvents = function(inObject, inNode, inEvents) {
    // FIXME: maybe remove this at some point
    if (!dojo.isArray(inEvents)) {
        throw ("wm.connectEvents: event list must be an array (did you use variable args?)")
    };
    var links = [];
    for (var i = 0, e;
    (e = inEvents[i]); i++) {
        links.push(dojo.connect(inNode, 'on' + e, inObject, e));
    }
    return links;
}

wm._isUniqueName = function(inName, inNameSpaces) {
    for (var j = 0, s;
    (s = inNameSpaces[j]); j++)
    if (s[inName] !== undefined) return false;
    return true;
}

wm.findUniqueName = function(inName, inNameSpaces) {
	if (wm._isUniqueName(inName, inNameSpaces))
		return inName;
	var m = (inName || '').match(/([^\d]*)([\d]*)/);
	var i = m[2] || 1, n0 = m[1] || 'noname';
	do {
		inName = n0 + (i > 0 ? i : '');
		i++;
	} while (!wm._isUniqueName(inName, inNameSpaces));
	return inName;
}

wm.getValidJsName = function(inName) {
    var dc = "_";
    inName = inName.replace(new RegExp("[- ]", "g"), dc);

    /*********************************************************
     * This used to be     inName = inName.replace(new RegExp("[^a-zA-Z0-9_]", "g"), "");
     * however this is unfriendly to valid unicode strings.  Instead
     * we now use an algorithm for determining if we have a valid name and if not, trimming
     * characters until we have a valid name
     */
    var isInvalid = true;
    if (inName.match(/^[0-9]/)) {
        inName = ["zero","one","two","three","four","five","six","seven","eight","nine"][inName[0]] + inName.substring(1);
    }
    for (var i = 0; i < inName.length && isInvalid; i++) {
        try { /* Declare var inName in an inner function so it doesn't polute the window object's name space */
            var result = eval("(function() {var " + inName + " = 5; return " + inName + ";})()");
            if (result == 5) {
                isInvalid = false;
            }
        } catch (e) {};
        if (isInvalid) {
            inName = inName.substring(0, i) + inName.substring(i, i + 1).replace(/[^a-zA-Z0-9]+/g, '') + inName.substring(i + 1);
            var result = eval("(function() {var " + inName + " = 5; return " + inName + ";})()"); // if the name is still invalid, throw an error
        }
    }

    /*
    if (inName.match(new RegExp("^[0-9]")) || !inName)
    inName = dc + inName;
    */
    if (inName == "_") inName = "";
    return inName;
}

wm._modules = [];
wm.loadModule = function(inModule) {
	if (!wm._modules[inModule]) {
		tag = [ '<scrip', 't type="text/javascript" src="', inModule, '.js"></scrip', 't>' ].join('');
		document.write(tag);
		wm._modules[inModule] = true;
	}
}

wm.widgetIsShowing = function(inWidget) {
	var w = inWidget, p;
	while (w) {
		p = w.parent;
		if (!w.showing || (w.isActive && !w.isActive()))
			return false;
		w = p;
	}
	return true;
}

wm.forEachWidget = function(inWidget, inFunc, inIgnoreBuiltin) {
	if (inFunc&&inFunc(inWidget) === false)
		return false;
	if (!inWidget)
		return false;

    /* TODO: if inIgnoreBuiltin is false, perhaps we should use inWidget.widgets instead of getOrderedWidgets */
    for (var i=0, ws = inIgnoreBuiltin && inWidget instanceof wm.PageContainer ? [] : inWidget.getOrderedWidgets(), r, w; w=ws[i]; i++) {

		if (w.forEachWidget && !inIgnoreBuiltin) {
		    r = inFunc(w);
		    if (r !== false)
			r = w.forEachWidget(inFunc);
		} else {
		    r = wm.forEachWidget(w, inFunc, inIgnoreBuiltin);
		}

	    if (r === false)
		return false;
	}
}

// if inFunc returns false, do not call on its widgets; unlike wm.forEachWidgets though, it does NOT mean cancel calling on other subtrees
wm.forEachVisibleWidget = function(inWidget, inFunc, inIgnoreBuiltin) {
    var result;
    if (inFunc && inWidget && !inWidget.isAncestorHidden()) result = inFunc(inWidget);

    if (result !== false && (!inIgnoreBuiltin || !wm.isInstanceType(inWidget, [wm.PageContainer, wm.Composite]))) {
        for (var i = 0, ws = inWidget.getOrderedWidgets(), r, w; w = ws[i]; i++) {
            if (w.forEachVisibleWidget && !inIgnoreBuiltin) {
                w.forEachVisibleWidget(inFunc);
            } else {
                 wm.forEachVisibleWidget(w, inFunc, inIgnoreBuiltin);
            }
        }
    }
}

// themes
wm.theme = {
	getPath: function() {
			return dojo.moduleUrl("lib.wm.base","widget/themes/" + "default/");
	},
	getImagesPath: function() {
		return wm.theme.getPath() + "images/";
	}
};

//utility: ensure dijit tooltip is hidden
wm.hideToolTip = function(inImmediate) {
	var tt = dijit._masterTT;
	if (tt) {
		dijit.hideTooltip(tt.aroundNode);
		tt._onDeck=null;
		if (inImmediate && tt.fadeOut) {
			tt.fadeOut.stop(true);
			dojo.style(tt.fadeOut.node, "opacity", 0);
		}
	}
};

wm.focusContainer = function(inContainer) {
	wm.onidle(function() {
		wm.forEachWidget(inContainer, function(w) {
			if (w && w.focus && (!w.canFocus || w.canFocus())) {
				w.focus();
				return false;
			}
		});
	});
}

/*
wm.isInstanceType = function(obj, type){
	try
	{
		if (!obj)
			return false;
		if (obj.instanceType)
			return obj.instanceType[type];
		else
			return (obj instanceof dojo.getObject(type));
	}
	catch(e)
	{
		console.info('failed responding to instanceType query with obj = ', obj, ' and type = ', type);
	}

	return false;
}
*/


wm.isClassInstanceType = function(inClass, type) {
    try {
        return type && inClass.prototype instanceof type;
    } catch(e) {}
    return false;
}
wm.isInstanceType = function(obj, types){
    if (types && typeof types == "object" && types.length) {
	for (var i = 0; i < types.length; i++) {
	    if (types[i] && obj instanceof types[i]) return true;
	}
	return false;
    } else {
	return types && obj instanceof types;
    }
}


wm.getWidgetByDomNode = function(element) {
        if (!element) return;
        if (dojo.isString(element))
                element = dojo.byId(element);
        if (!element) return;
        var pageName = app._page.name;
        var reg = new RegExp("^(" + pageName + "|app)_?");

        // If the node has no ID, then its a subnode of one of our widgets, find the node with the REAL ID.
        while ((!element.id || !element.id.match(reg)) && element.parentNode) element = element.parentNode;
        var id = element.id;
        if (!id) return;

        var originalId = id;
        var id = id.replace(reg,"");
        var elements = id.split(/_+/);
        var name = "";
        var widget = (originalId.match(/^app_/)) ? app : app._page;
        for (var i = 0; i < elements.length; i++) {
            if (wm.isInstanceType(widget, wm.PageDialog)) {
                widget = widget.pageContainer;
            }
                if (wm.isInstanceType(widget, wm.PageContainer) || wm.isInstanceType(widget, wm.pageContainerMixin)) {
                        widget = widget.page;
                        name = "";
                } else {
                        name += ((name) ? "_" : "") + elements[i];
                        if (wm.isInstanceType(widget, wm.Application)) {
                                if (widget[name]) {
                                        widget = widget[name];
                                        name = "";
                                }

                        } else {
                                if (widget.$[name]) {
                                        widget = widget.$[name];
                                        name = "";
                                }
                        }
                }
        }
        return widget;
}

wm.isNode = function(inObject) {
    if (window["Node"]) return inObject instanceof Node;
    if (typeof inObject == "object" && inObject) return "nodeType" in inObject && "appendChild" in inObject;
}

if (!wm.Array) wm.Array = {};

/* Side effect: alters input inArray Object.  Returns inArray Object; Return is mostly used for chaining operations together */
wm.Array.removeElementAt = function(inArray, inIndex) {
    inArray.splice(inIndex, 1);
    return inArray;
}

wm.Array.insertElementAt = function(inArray, inElement, inIndex) {
    inArray.splice(inIndex, 0, inElement);
}

/* Side effect: alters input inArray Object.  Returns inArray Object; Return is mostly used for chaining operations together */
wm.Array.removeElement = function(inArray, inElement) {
    var index = dojo.indexOf(inArray, inElement);
    if (index >= 0)
	inArray.splice(index, 1);
    return inArray;
}

wm.Array.equals = function(a, b,optionalCallback) {
    if (a == b) return true;
    if (!a || !b) return false;
    if (a.length != b.length) return false;
    for (var i = 0; i < a.length; i++) {
	if (optionalCallback) {
	    if (!optionalCallback(a[i],b[i])) return false;
	} else {
	    if (a[i] != b[i]) return false;
	}
    }
    return true;
}


wm.Array.indexOf = function(inArray, inValue, inCallback) {
    for (var i = 0; i < inArray.length; i++) {
        if (inCallback(inArray[i], inValue))
            return i;
    }
    return -1;
}

wm.Array.last = function(inArray) {
    return inArray[inArray.length-1];
}

if (!wm.String) wm.String = {};
wm.String.endStringWith = function(inString, inEnd) {
    if (!inString.match(new RegExp(inEnd + "$")))
	return inString + inEnd;
    else
	return inString;
}



setCss = function(inSheetId, inCss){
	var sheet = dojo.byId(inSheetId);
	if (!sheet)
		return;
	inCss = inCss || "";
	if(sheet.styleSheet) {//IE
		// must make sure to set cssText to at least empty string or IE can crash
		if (dojo.isIE < 7)
			setIe6Css(sheet, inCss);
		else
			sheet.styleSheet.cssText = inCss;
	} else {
		sheet.firstChild && sheet.removeChild(sheet.firstChild);
		sheet.appendChild(document.createTextNode(inCss));
	}
}

// IE6 doesn't allow setting cssText so replace the style node completely
setIe6Css = function(inSheet, inCss) {
	var c = document.documentElement.firstChild, id = inSheet.id;
	c.removeChild(inSheet);
	var n = document.createElement("style");
	n.id = id;
	n.type = "text/css";
	if (n.styleSheet)
		n.styleSheet.cssText = inCss;
	else
		n.appendChild(document.createTextNode(inCss));
	c.appendChild(n);
}

/* Stupid hack to hide a conditional dojo.require package from the build system
   so that something like touchscroll doesn't get built into the core libraries -- especially
   since nonwebkit browsers break on touchscroll and its a useless library for desktop apps.
   The bulid system searches for "dojo.require", by using dojo["require"] the
   build system ignores this and doesn't try to add this package into the layer.
 */
wm.conditionalRequire = function(packageName, condition) {
    if (arguments.length == 1 || condition)
	dojo["require"](packageName);
}


wm.getBackgroundStyle = function(startColor, endColor, colorStop, direction, browser) {
    if (!browser) {
	if (dojo.isWebKit) {
	    browser = "webkit";
	} else if (dojo.isMoz) {
	    browser = "moz";
	} else if (dojo.isOpera) {
	    browser = "opera";
	} else if (dojo.isIE < 10) {
	    browser = "ieold";
	} else if (dojo.isIE >= 10) {
	    browser = "ie10";
	}
    }
    var result = "-linear-gradient(" + (direction == "vertical" ? "top" : "left") + ", " + startColor + " 0%," + endColor + " " + colorStop + "%," + endColor + " 100%)";
	switch(browser) {
	case "webkit":
	    // return  "-webkit" + result; sadly some mobile webkit browsers don't support this
	    return "-webkit-gradient(linear, " + (direction == "vertical" ? "center top, center bottom" : "left center, right center") + ", from(" + startColor + "), color-stop(" + colorStop + "%," + endColor+"), to(" + endColor+"))";
	case "moz":
	    return  "-moz" + result;
	case "ieold":
	    return  "progid:DXImageTransform.Microsoft.gradient( startColorstr='" + startColor + "', endColorstr='" + endColor + "',GradientType=" + (direction == "vertical" ? 0 : 1) + ")";
	case "ie10":
	    return  "-ms" + result;
	case "opera":
	    return "-o" + result;
	}


    }


 wm.getStyleFromNode = function(inNode, inStyle){
	var result = "";
	if(document.defaultView && document.defaultView.getComputedStyle){
		result = document.defaultView.getComputedStyle(inNode, "").getPropertyValue(inStyle);
	}
	else if(inNode.currentStyle){
		inStyle = inStyle.replace(/\-(\w)/g, function (ignore, dashLetter){
			return dashLetter.toUpperCase();
		});
		result = inNode.currentStyle[inStyle];
	}
	return result;
}

/* Moved to here because both DataForm and LiveForm layers need these */
wm.getParentForm = function(inWidget) {
	var w = inWidget.parent;
	var r = inWidget.getRoot();
	r = r && r.root;
	while (w && w != r) {
	    if (wm.isInstanceType(w, [wm.LiveFormBase,wm.DataForm])) {
			return w;
		}
		w = w.parent;
	}
}

wm.getFormLiveView = function(inForm) {
	var lv = inForm && inForm.findLiveVariable();
	return lv && lv.liveView;
}

wm.getFormField = function(inWidget) {
	var a = [], w = inWidget;
        while (w && !(wm.isInstanceType(w, wm.LiveForm))) {
		if (w.formField)
			a.unshift(w.formField);
		w = wm.getParentForm(w);
	}
	return a.join('.');
}

}

if(!dojo._hasResource["dojo.date"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.date"] = true;
dojo.provide("dojo.date");


dojo.getObject("date", true, dojo);

/*=====
dojo.date = {
	// summary: Date manipulation utilities
}
=====*/

dojo.date.getDaysInMonth = function(/*Date*/dateObject){
	//	summary:
	//		Returns the number of days in the month used by dateObject
	var month = dateObject.getMonth();
	var days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
	if(month == 1 && dojo.date.isLeapYear(dateObject)){ return 29; } // Number
	return days[month]; // Number
};

dojo.date.isLeapYear = function(/*Date*/dateObject){
	//	summary:
	//		Determines if the year of the dateObject is a leap year
	//	description:
	//		Leap years are years with an additional day YYYY-02-29, where the
	//		year number is a multiple of four with the following exception: If
	//		a year is a multiple of 100, then it is only a leap year if it is
	//		also a multiple of 400. For example, 1900 was not a leap year, but
	//		2000 is one.

	var year = dateObject.getFullYear();
	return !(year%400) || (!(year%4) && !!(year%100)); // Boolean
};

// FIXME: This is not localized
dojo.date.getTimezoneName = function(/*Date*/dateObject){
	//	summary:
	//		Get the user's time zone as provided by the browser
	// dateObject:
	//		Needed because the timezone may vary with time (daylight savings)
	//	description:
	//		Try to get time zone info from toString or toLocaleString method of
	//		the Date object -- UTC offset is not a time zone.  See
	//		http://www.twinsun.com/tz/tz-link.htm Note: results may be
	//		inconsistent across browsers.

	var str = dateObject.toString(); // Start looking in toString
	var tz = ''; // The result -- return empty string if nothing found
	var match;

	// First look for something in parentheses -- fast lookup, no regex
	var pos = str.indexOf('(');
	if(pos > -1){
		tz = str.substring(++pos, str.indexOf(')'));
	}else{
		// If at first you don't succeed ...
		// If IE knows about the TZ, it appears before the year
		// Capital letters or slash before a 4-digit year
		// at the end of string
		var pat = /([A-Z\/]+) \d{4}$/;
		if((match = str.match(pat))){
			tz = match[1];
		}else{
		// Some browsers (e.g. Safari) glue the TZ on the end
		// of toLocaleString instead of putting it in toString
			str = dateObject.toLocaleString();
			// Capital letters or slash -- end of string,
			// after space
			pat = / ([A-Z\/]+)$/;
			if((match = str.match(pat))){
				tz = match[1];
			}
		}
	}

	// Make sure it doesn't somehow end up return AM or PM
	return (tz == 'AM' || tz == 'PM') ? '' : tz; // String
};

// Utility methods to do arithmetic calculations with Dates

dojo.date.compare = function(/*Date*/date1, /*Date?*/date2, /*String?*/portion){
	//	summary:
	//		Compare two date objects by date, time, or both.
	//	description:
	//  	Returns 0 if equal, positive if a > b, else negative.
	//	date1:
	//		Date object
	//	date2:
	//		Date object.  If not specified, the current Date is used.
	//	portion:
	//		A string indicating the "date" or "time" portion of a Date object.
	//		Compares both "date" and "time" by default.  One of the following:
	//		"date", "time", "datetime"

	// Extra step required in copy for IE - see #3112
	date1 = new Date(+date1);
	date2 = new Date(+(date2 || new Date()));

	if(portion == "date"){
		// Ignore times and compare dates.
		date1.setHours(0, 0, 0, 0);
		date2.setHours(0, 0, 0, 0);
	}else if(portion == "time"){
		// Ignore dates and compare times.
		date1.setFullYear(0, 0, 0);
		date2.setFullYear(0, 0, 0);
	}
	
	if(date1 > date2){ return 1; } // int
	if(date1 < date2){ return -1; } // int
	return 0; // int
};

dojo.date.add = function(/*Date*/date, /*String*/interval, /*int*/amount){
	//	summary:
	//		Add to a Date in intervals of different size, from milliseconds to years
	//	date: Date
	//		Date object to start with
	//	interval:
	//		A string representing the interval.  One of the following:
	//			"year", "month", "day", "hour", "minute", "second",
	//			"millisecond", "quarter", "week", "weekday"
	//	amount:
	//		How much to add to the date.

	var sum = new Date(+date); // convert to Number before copying to accomodate IE (#3112)
	var fixOvershoot = false;
	var property = "Date";

	switch(interval){
		case "day":
			break;
		case "weekday":
			//i18n FIXME: assumes Saturday/Sunday weekend, but this is not always true.  see dojo.cldr.supplemental

			// Divide the increment time span into weekspans plus leftover days
			// e.g., 8 days is one 5-day weekspan / and two leftover days
			// Can't have zero leftover days, so numbers divisible by 5 get
			// a days value of 5, and the remaining days make up the number of weeks
			var days, weeks;
			var mod = amount % 5;
			if(!mod){
				days = (amount > 0) ? 5 : -5;
				weeks = (amount > 0) ? ((amount-5)/5) : ((amount+5)/5);
			}else{
				days = mod;
				weeks = parseInt(amount/5);
			}
			// Get weekday value for orig date param
			var strt = date.getDay();
			// Orig date is Sat / positive incrementer
			// Jump over Sun
			var adj = 0;
			if(strt == 6 && amount > 0){
				adj = 1;
			}else if(strt == 0 && amount < 0){
			// Orig date is Sun / negative incrementer
			// Jump back over Sat
				adj = -1;
			}
			// Get weekday val for the new date
			var trgt = strt + days;
			// New date is on Sat or Sun
			if(trgt == 0 || trgt == 6){
				adj = (amount > 0) ? 2 : -2;
			}
			// Increment by number of weeks plus leftover days plus
			// weekend adjustments
			amount = (7 * weeks) + days + adj;
			break;
		case "year":
			property = "FullYear";
			// Keep increment/decrement from 2/29 out of March
			fixOvershoot = true;
			break;
		case "week":
			amount *= 7;
			break;
		case "quarter":
			// Naive quarter is just three months
			amount *= 3;
			// fallthrough...
		case "month":
			// Reset to last day of month if you overshoot
			fixOvershoot = true;
			property = "Month";
			break;
//		case "hour":
//		case "minute":
//		case "second":
//		case "millisecond":
		default:
			property = "UTC"+interval.charAt(0).toUpperCase() + interval.substring(1) + "s";
	}

	if(property){
		sum["set"+property](sum["get"+property]()+amount);
	}

	if(fixOvershoot && (sum.getDate() < date.getDate())){
		sum.setDate(0);
	}

	return sum; // Date
};

dojo.date.difference = function(/*Date*/date1, /*Date?*/date2, /*String?*/interval){
	//	summary:
	//		Get the difference in a specific unit of time (e.g., number of
	//		months, weeks, days, etc.) between two dates, rounded to the
	//		nearest integer.
	//	date1:
	//		Date object
	//	date2:
	//		Date object.  If not specified, the current Date is used.
	//	interval:
	//		A string representing the interval.  One of the following:
	//			"year", "month", "day", "hour", "minute", "second",
	//			"millisecond", "quarter", "week", "weekday"
	//		Defaults to "day".

	date2 = date2 || new Date();
	interval = interval || "day";
	var yearDiff = date2.getFullYear() - date1.getFullYear();
	var delta = 1; // Integer return value

	switch(interval){
		case "quarter":
			var m1 = date1.getMonth();
			var m2 = date2.getMonth();
			// Figure out which quarter the months are in
			var q1 = Math.floor(m1/3) + 1;
			var q2 = Math.floor(m2/3) + 1;
			// Add quarters for any year difference between the dates
			q2 += (yearDiff * 4);
			delta = q2 - q1;
			break;
		case "weekday":
			var days = Math.round(dojo.date.difference(date1, date2, "day"));
			var weeks = parseInt(dojo.date.difference(date1, date2, "week"));
			var mod = days % 7;

			// Even number of weeks
			if(mod == 0){
				days = weeks*5;
			}else{
				// Weeks plus spare change (< 7 days)
				var adj = 0;
				var aDay = date1.getDay();
				var bDay = date2.getDay();

				weeks = parseInt(days/7);
				mod = days % 7;
				// Mark the date advanced by the number of
				// round weeks (may be zero)
				var dtMark = new Date(date1);
				dtMark.setDate(dtMark.getDate()+(weeks*7));
				var dayMark = dtMark.getDay();

				// Spare change days -- 6 or less
				if(days > 0){
					switch(true){
						// Range starts on Sat
						case aDay == 6:
							adj = -1;
							break;
						// Range starts on Sun
						case aDay == 0:
							adj = 0;
							break;
						// Range ends on Sat
						case bDay == 6:
							adj = -1;
							break;
						// Range ends on Sun
						case bDay == 0:
							adj = -2;
							break;
						// Range contains weekend
						case (dayMark + mod) > 5:
							adj = -2;
					}
				}else if(days < 0){
					switch(true){
						// Range starts on Sat
						case aDay == 6:
							adj = 0;
							break;
						// Range starts on Sun
						case aDay == 0:
							adj = 1;
							break;
						// Range ends on Sat
						case bDay == 6:
							adj = 2;
							break;
						// Range ends on Sun
						case bDay == 0:
							adj = 1;
							break;
						// Range contains weekend
						case (dayMark + mod) < 0:
							adj = 2;
					}
				}
				days += adj;
				days -= (weeks*2);
			}
			delta = days;
			break;
		case "year":
			delta = yearDiff;
			break;
		case "month":
			delta = (date2.getMonth() - date1.getMonth()) + (yearDiff * 12);
			break;
		case "week":
			// Truncate instead of rounding
			// Don't use Math.floor -- value may be negative
			delta = parseInt(dojo.date.difference(date1, date2, "day")/7);
			break;
		case "day":
			delta /= 24;
			// fallthrough
		case "hour":
			delta /= 60;
			// fallthrough
		case "minute":
			delta /= 60;
			// fallthrough
		case "second":
			delta /= 1000;
			// fallthrough
		case "millisecond":
			delta *= date2.getTime() - date1.getTime();
	}

	// Round for fractional values and DST leaps
	return Math.round(delta); // Number (integer)
};

}

if(!dojo._hasResource["dojo.cldr.supplemental"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.cldr.supplemental"] = true;
dojo.provide("dojo.cldr.supplemental");



dojo.getObject("cldr.supplemental", true, dojo);

dojo.cldr.supplemental.getFirstDayOfWeek = function(/*String?*/locale){
// summary: Returns a zero-based index for first day of the week
// description:
//		Returns a zero-based index for first day of the week, as used by the local (Gregorian) calendar.
//		e.g. Sunday (returns 0), or Monday (returns 1)

	// from http://www.unicode.org/cldr/data/common/supplemental/supplementalData.xml:supplementalData/weekData/firstDay
	var firstDay = {/*default is 1=Monday*/
		mv:5,
		ae:6,af:6,bh:6,dj:6,dz:6,eg:6,er:6,et:6,iq:6,ir:6,jo:6,ke:6,kw:6,
		ly:6,ma:6,om:6,qa:6,sa:6,sd:6,so:6,sy:6,tn:6,ye:6,
		ar:0,as:0,az:0,bw:0,ca:0,cn:0,fo:0,ge:0,gl:0,gu:0,hk:0,
		il:0,'in':0,jm:0,jp:0,kg:0,kr:0,la:0,mh:0,mn:0,mo:0,mp:0,
		mt:0,nz:0,ph:0,pk:0,sg:0,th:0,tt:0,tw:0,um:0,us:0,uz:0,
		vi:0,zw:0
// variant. do not use?		gb:0,
	};

	var country = dojo.cldr.supplemental._region(locale);
	var dow = firstDay[country];
	return (dow === undefined) ? 1 : dow; /*Number*/
};

dojo.cldr.supplemental._region = function(/*String?*/locale){
	locale = dojo.i18n.normalizeLocale(locale);
	var tags = locale.split('-');
	var region = tags[1];
	if(!region){
		// IE often gives language only (#2269)
		// Arbitrary mappings of language-only locales to a country:
		region = {de:"de", en:"us", es:"es", fi:"fi", fr:"fr", he:"il", hu:"hu", it:"it",
			ja:"jp", ko:"kr", nl:"nl", pt:"br", sv:"se", zh:"cn"}[tags[0]];
	}else if(region.length == 4){
		// The ISO 3166 country code is usually in the second position, unless a
		// 4-letter script is given. See http://www.ietf.org/rfc/rfc4646.txt
		region = tags[2];
	}
	return region;
};

dojo.cldr.supplemental.getWeekend = function(/*String?*/locale){
// summary: Returns a hash containing the start and end days of the weekend
// description:
//		Returns a hash containing the start and end days of the weekend according to local custom using locale,
//		or by default in the user's locale.
//		e.g. {start:6, end:0}

	// from http://www.unicode.org/cldr/data/common/supplemental/supplementalData.xml:supplementalData/weekData/weekend{Start,End}
	var weekendStart = {/*default is 6=Saturday*/
		'in':0,
		af:4,dz:4,ir:4,om:4,sa:4,ye:4,
		ae:5,bh:5,eg:5,il:5,iq:5,jo:5,kw:5,ly:5,ma:5,qa:5,sd:5,sy:5,tn:5
	};

	var weekendEnd = {/*default is 0=Sunday*/
		af:5,dz:5,ir:5,om:5,sa:5,ye:5,
		ae:6,bh:5,eg:6,il:6,iq:6,jo:6,kw:6,ly:6,ma:6,qa:6,sd:6,sy:6,tn:6
	};

	var country = dojo.cldr.supplemental._region(locale);
	var start = weekendStart[country];
	var end = weekendEnd[country];
	if(start === undefined){start=6;}
	if(end === undefined){end=0;}
	return {start:start, end:end}; /*Object {start,end}*/
};

}

if(!dojo._hasResource["dojo.string"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.string"] = true;
dojo.provide("dojo.string");


dojo.getObject("string", true, dojo);

/*=====
dojo.string = {
	// summary: String utilities for Dojo
};
=====*/

dojo.string.rep = function(/*String*/str, /*Integer*/num){
	//	summary:
	//		Efficiently replicate a string `n` times.
	//	str:
	//		the string to replicate
	//	num:
	//		number of times to replicate the string
	
	if(num <= 0 || !str){ return ""; }
	
	var buf = [];
	for(;;){
		if(num & 1){
			buf.push(str);
		}
		if(!(num >>= 1)){ break; }
		str += str;
	}
	return buf.join("");	// String
};

dojo.string.pad = function(/*String*/text, /*Integer*/size, /*String?*/ch, /*Boolean?*/end){
	//	summary:
	//		Pad a string to guarantee that it is at least `size` length by
	//		filling with the character `ch` at either the start or end of the
	//		string. Pads at the start, by default.
	//	text:
	//		the string to pad
	//	size:
	//		length to provide padding
	//	ch:
	//		character to pad, defaults to '0'
	//	end:
	//		adds padding at the end if true, otherwise pads at start
	//	example:
	//	|	// Fill the string to length 10 with "+" characters on the right.  Yields "Dojo++++++".
	//	|	dojo.string.pad("Dojo", 10, "+", true);

	if(!ch){
		ch = '0';
	}
	var out = String(text),
		pad = dojo.string.rep(ch, Math.ceil((size - out.length) / ch.length));
	return end ? out + pad : pad + out;	// String
};

dojo.string.substitute = function(	/*String*/		template,
									/*Object|Array*/map,
									/*Function?*/	transform,
									/*Object?*/		thisObject){
	//	summary:
	//		Performs parameterized substitutions on a string. Throws an
	//		exception if any parameter is unmatched.
	//	template:
	//		a string with expressions in the form `${key}` to be replaced or
	//		`${key:format}` which specifies a format function. keys are case-sensitive.
	//	map:
	//		hash to search for substitutions
	//	transform:
	//		a function to process all parameters before substitution takes
	//		place, e.g. mylib.encodeXML
	//	thisObject:
	//		where to look for optional format function; default to the global
	//		namespace
	//	example:
	//		Substitutes two expressions in a string from an Array or Object
	//	|	// returns "File 'foo.html' is not found in directory '/temp'."
	//	|	// by providing substitution data in an Array
	//	|	dojo.string.substitute(
	//	|		"File '${0}' is not found in directory '${1}'.",
	//	|		["foo.html","/temp"]
	//	|	);
	//	|
	//	|	// also returns "File 'foo.html' is not found in directory '/temp'."
	//	|	// but provides substitution data in an Object structure.  Dotted
	//	|	// notation may be used to traverse the structure.
	//	|	dojo.string.substitute(
	//	|		"File '${name}' is not found in directory '${info.dir}'.",
	//	|		{ name: "foo.html", info: { dir: "/temp" } }
	//	|	);
	//	example:
	//		Use a transform function to modify the values:
	//	|	// returns "file 'foo.html' is not found in directory '/temp'."
	//	|	dojo.string.substitute(
	//	|		"${0} is not found in ${1}.",
	//	|		["foo.html","/temp"],
	//	|		function(str){
	//	|			// try to figure out the type
	//	|			var prefix = (str.charAt(0) == "/") ? "directory": "file";
	//	|			return prefix + " '" + str + "'";
	//	|		}
	//	|	);
	//	example:
	//		Use a formatter
	//	|	// returns "thinger -- howdy"
	//	|	dojo.string.substitute(
	//	|		"${0:postfix}", ["thinger"], null, {
	//	|			postfix: function(value, key){
	//	|				return value + " -- howdy";
	//	|			}
	//	|		}
	//	|	);

	thisObject = thisObject || dojo.global;
	transform = transform ?
		dojo.hitch(thisObject, transform) : function(v){ return v; };

	return template.replace(/\$\{([^\s\:\}]+)(?:\:([^\s\:\}]+))?\}/g,
		function(match, key, format){
			var value = dojo.getObject(key, false, map);
			if(format){
				value = dojo.getObject(format, false, thisObject).call(thisObject, value, key);
			}
			    /* Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved. Licensed under the Apache License 2.0 - http://www.apache.org/licenses/LICENSE-2.0 
			     * WaveMaker: Added try/catch block to make localization more stable */
		        try {
			    return transform(value, key).toString();
			} catch(e) {return "";}
		}); // String
};

/*=====
dojo.string.trim = function(str){
	//	summary:
	//		Trims whitespace from both sides of the string
	//	str: String
	//		String to be trimmed
	//	returns: String
	//		Returns the trimmed string
	//	description:
	//		This version of trim() was taken from [Steven Levithan's blog](http://blog.stevenlevithan.com/archives/faster-trim-javascript).
	//		The short yet performant version of this function is dojo.trim(),
	//		which is part of Dojo base.  Uses String.prototype.trim instead, if available.
	return "";	// String
}
=====*/

dojo.string.trim = String.prototype.trim ?
	dojo.trim : // aliasing to the native function
	function(str){
		str = str.replace(/^\s+/, '');
		for(var i = str.length - 1; i >= 0; i--){
			if(/\S/.test(str.charAt(i))){
				str = str.substring(0, i + 1);
				break;
			}
		}
		return str;
	};

}

if(!dojo._hasResource["dojo.date.locale"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.date.locale"] = true;
dojo.provide("dojo.date.locale");








dojo.getObject("date.locale", true, dojo);

// Localization methods for Date.   Honor local customs using locale-dependent dojo.cldr data.


// Load the bundles containing localization information for
// names and formats

//NOTE: Everything in this module assumes Gregorian calendars.
// Other calendars will be implemented in separate modules.

(function(){
	// Format a pattern without literals
	function formatPattern(dateObject, bundle, options, pattern){
		return pattern.replace(/([a-z])\1*/ig, function(match){
			var s, pad,
				c = match.charAt(0),
				l = match.length,
				widthList = ["abbr", "wide", "narrow"];
			switch(c){
				case 'G':
					s = bundle[(l < 4) ? "eraAbbr" : "eraNames"][dateObject.getFullYear() < 0 ? 0 : 1];
					break;
				case 'y':
			    /* Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved. Licensed under the Apache License 2.0 - http://www.apache.org/licenses/LICENSE-2.0 
			     * WaveMaker: Added "Y" because our users are likely to enter it */
				case 'Y':
					s = dateObject.getFullYear();
					switch(l){
						case 1:
							break;
						case 2:
							if(!options.fullYear){
								s = String(s); s = s.substr(s.length - 2);
								break;
							}
							// fallthrough
						default:
							pad = true;
					}
					break;
				case 'Q':
				case 'q':
					s = Math.ceil((dateObject.getMonth()+1)/3);
//					switch(l){
//						case 1: case 2:
							pad = true;
//							break;
//						case 3: case 4: // unimplemented
//					}
					break;
				case 'M':
					var m = dateObject.getMonth();
					if(l<3){
						s = m+1; pad = true;
					}else{
						var propM = ["months", "format", widthList[l-3]].join("-");
						s = bundle[propM][m];
					}
					break;
				case 'w':
					var firstDay = 0;
					s = dojo.date.locale._getWeekOfYear(dateObject, firstDay); pad = true;
					break;
				case 'd':
					s = dateObject.getDate(); pad = true;
					break;
				case 'D':
					s = dojo.date.locale._getDayOfYear(dateObject); pad = true;
					break;
				case 'E':
					var d = dateObject.getDay();
					if(l<3){
						s = d+1; pad = true;
					}else{
						var propD = ["days", "format", widthList[l-3]].join("-");
						s = bundle[propD][d];
					}
					break;
				case 'a':
					var timePeriod = (dateObject.getHours() < 12) ? 'am' : 'pm';
					s = options[timePeriod] || bundle['dayPeriods-format-wide-' + timePeriod];
					break;
				case 'h':
				case 'H':
				case 'K':
				case 'k':
					var h = dateObject.getHours();
					// strange choices in the date format make it impossible to write this succinctly
					switch (c){
						case 'h': // 1-12
							s = (h % 12) || 12;
							break;
						case 'H': // 0-23
							s = h;
							break;
						case 'K': // 0-11
							s = (h % 12);
							break;
						case 'k': // 1-24
							s = h || 24;
							break;
					}
					pad = true;
					break;
				case 'm':
					s = dateObject.getMinutes(); pad = true;
					break;
				case 's':
					s = dateObject.getSeconds(); pad = true;
					break;
				case 'S':
					s = Math.round(dateObject.getMilliseconds() * Math.pow(10, l-3)); pad = true;
					break;
				case 'v': // FIXME: don't know what this is. seems to be same as z?
				case 'z':
					// We only have one timezone to offer; the one from the browser
					s = dojo.date.locale._getZone(dateObject, true, options);
					if(s){break;}
					l=4;
					// fallthrough... use GMT if tz not available
				case 'Z':
					var offset = dojo.date.locale._getZone(dateObject, false, options);
					var tz = [
						(offset<=0 ? "+" : "-"),
						dojo.string.pad(Math.floor(Math.abs(offset)/60), 2),
						dojo.string.pad(Math.abs(offset)% 60, 2)
					];
					if(l==4){
						tz.splice(0, 0, "GMT");
						tz.splice(3, 0, ":");
					}
					s = tz.join("");
					break;
//				case 'Y': case 'u': case 'W': case 'F': case 'g': case 'A': case 'e':
//					console.log(match+" modifier unimplemented");
				default:
					throw new Error("dojo.date.locale.format: invalid pattern char: "+pattern);
			}
			if(pad){ s = dojo.string.pad(s, l); }
			return s;
		});
	}

/*=====
	dojo.date.locale.__FormatOptions = function(){
	//	selector: String
	//		choice of 'time','date' (default: date and time)
	//	formatLength: String
	//		choice of long, short, medium or full (plus any custom additions).  Defaults to 'short'
	//	datePattern:String
	//		override pattern with this string
	//	timePattern:String
	//		override pattern with this string
	//	am: String
	//		override strings for am in times
	//	pm: String
	//		override strings for pm in times
	//	locale: String
	//		override the locale used to determine formatting rules
	//	fullYear: Boolean
	//		(format only) use 4 digit years whenever 2 digit years are called for
	//	strict: Boolean
	//		(parse only) strict parsing, off by default
		this.selector = selector;
		this.formatLength = formatLength;
		this.datePattern = datePattern;
		this.timePattern = timePattern;
		this.am = am;
		this.pm = pm;
		this.locale = locale;
		this.fullYear = fullYear;
		this.strict = strict;
	}
=====*/

dojo.date.locale._getZone = function(/*Date*/dateObject, /*boolean*/getName, /*dojo.date.locale.__FormatOptions?*/options){
	// summary:
	//		Returns the zone (or offset) for the given date and options.  This
	//		is broken out into a separate function so that it can be overridden
	//		by timezone-aware code.
	//
	// dateObject:
	//		the date and/or time being formatted.
	//
	// getName:
	//		Whether to return the timezone string (if true), or the offset (if false)
	//
	// options:
	//		The options being used for formatting
	if(getName){
		return dojo.date.getTimezoneName(dateObject);
	}else{
		return dateObject.getTimezoneOffset();
	}
};


dojo.date.locale.format = function(/*Date*/dateObject, /*dojo.date.locale.__FormatOptions?*/options){
	// summary:
	//		Format a Date object as a String, using locale-specific settings.
	//
	// description:
	//		Create a string from a Date object using a known localized pattern.
	//		By default, this method formats both date and time from dateObject.
	//		Formatting patterns are chosen appropriate to the locale.  Different
	//		formatting lengths may be chosen, with "full" used by default.
	//		Custom patterns may be used or registered with translations using
	//		the dojo.date.locale.addCustomFormats method.
	//		Formatting patterns are implemented using [the syntax described at
	//		unicode.org](http://www.unicode.org/reports/tr35/tr35-4.html#Date_Format_Patterns)
	//
	// dateObject:
	//		the date and/or time to be formatted.  If a time only is formatted,
	//		the values in the year, month, and day fields are irrelevant.  The
	//		opposite is true when formatting only dates.

	options = options || {};

	var locale = dojo.i18n.normalizeLocale(options.locale),
		formatLength = options.formatLength || 'short',
		bundle = dojo.date.locale._getGregorianBundle(locale),
		str = [],
		sauce = dojo.hitch(this, formatPattern, dateObject, bundle, options);
	if(options.selector == "year"){
		return _processPattern(bundle["dateFormatItem-yyyy"] || "yyyy", sauce);
	}
	var pattern;
	if(options.selector != "date"){
		pattern = options.timePattern || bundle["timeFormat-"+formatLength];
		if(pattern){str.push(_processPattern(pattern, sauce));}
	}
	if(options.selector != "time"){
		pattern = options.datePattern || bundle["dateFormat-"+formatLength];
		if(pattern){str.push(_processPattern(pattern, sauce));}
	}

	return str.length == 1 ? str[0] : bundle["dateTimeFormat-"+formatLength].replace(/\{(\d+)\}/g,
		function(match, key){ return str[key]; }); // String
};

dojo.date.locale.regexp = function(/*dojo.date.locale.__FormatOptions?*/options){
	// summary:
	//		Builds the regular needed to parse a localized date

	return dojo.date.locale._parseInfo(options).regexp; // String
};

dojo.date.locale._parseInfo = function(/*dojo.date.locale.__FormatOptions?*/options){
	options = options || {};
	var locale = dojo.i18n.normalizeLocale(options.locale),
		bundle = dojo.date.locale._getGregorianBundle(locale),
		formatLength = options.formatLength || 'short',
		datePattern = options.datePattern || bundle["dateFormat-" + formatLength],
		timePattern = options.timePattern || bundle["timeFormat-" + formatLength],
		pattern;
	if(options.selector == 'date'){
		pattern = datePattern;
	}else if(options.selector == 'time'){
		pattern = timePattern;
	}else{
		pattern = bundle["dateTimeFormat-"+formatLength].replace(/\{(\d+)\}/g,
			function(match, key){ return [timePattern, datePattern][key]; });
	}

	var tokens = [],
		re = _processPattern(pattern, dojo.hitch(this, _buildDateTimeRE, tokens, bundle, options));
	return {regexp: re, tokens: tokens, bundle: bundle};
};

dojo.date.locale.parse = function(/*String*/value, /*dojo.date.locale.__FormatOptions?*/options){
	// summary:
	//		Convert a properly formatted string to a primitive Date object,
	//		using locale-specific settings.
	//
	// description:
	//		Create a Date object from a string using a known localized pattern.
	//		By default, this method parses looking for both date and time in the string.
	//		Formatting patterns are chosen appropriate to the locale.  Different
	//		formatting lengths may be chosen, with "full" used by default.
	//		Custom patterns may be used or registered with translations using
	//		the dojo.date.locale.addCustomFormats method.
	//
	//		Formatting patterns are implemented using [the syntax described at
	//		unicode.org](http://www.unicode.org/reports/tr35/tr35-4.html#Date_Format_Patterns)
	//		When two digit years are used, a century is chosen according to a sliding
	//		window of 80 years before and 20 years after present year, for both `yy` and `yyyy` patterns.
	//		year < 100CE requires strict mode.
	//
	// value:
	//		A string representation of a date

	// remove non-printing bidi control chars from input and pattern
	var controlChars = /[\u200E\u200F\u202A\u202E]/g,
		info = dojo.date.locale._parseInfo(options),
		tokens = info.tokens, bundle = info.bundle,
		re = new RegExp("^" + info.regexp.replace(controlChars, "") + "$",
			info.strict ? "" : "i"),
		match = re.exec(value && value.replace(controlChars, ""));

	if(!match){ return null; } // null

	var widthList = ['abbr', 'wide', 'narrow'],
		result = [1970,0,1,0,0,0,0], // will get converted to a Date at the end
		amPm = "",
		valid = dojo.every(match, function(v, i){
		if(!i){return true;}
		var token=tokens[i-1];
		var l=token.length;
		switch(token.charAt(0)){
			case 'y':
				if(l != 2 && options.strict){
					//interpret year literally, so '5' would be 5 A.D.
					result[0] = v;
				}else{
					if(v<100){
						v = Number(v);
						//choose century to apply, according to a sliding window
						//of 80 years before and 20 years after present year
						var year = '' + new Date().getFullYear(),
							century = year.substring(0, 2) * 100,
							cutoff = Math.min(Number(year.substring(2, 4)) + 20, 99),
							num = (v < cutoff) ? century + v : century - 100 + v;
						result[0] = num;
					}else{
						//we expected 2 digits and got more...
						if(options.strict){
							return false;
						}
						//interpret literally, so '150' would be 150 A.D.
						//also tolerate '1950', if 'yyyy' input passed to 'yy' format
						result[0] = v;
					}
				}
				break;
			case 'M':
				if(l>2){
					var months = bundle['months-format-' + widthList[l-3]].concat();
					if(!options.strict){
						//Tolerate abbreviating period in month part
						//Case-insensitive comparison
						v = v.replace(".","").toLowerCase();
						months = dojo.map(months, function(s){ return s.replace(".","").toLowerCase(); } );
					}
					v = dojo.indexOf(months, v);
					if(v == -1){
//						console.log("dojo.date.locale.parse: Could not parse month name: '" + v + "'.");
						return false;
					}
				}else{
					v--;
				}
				result[1] = v;
				break;
			case 'E':
			case 'e':
				var days = bundle['days-format-' + widthList[l-3]].concat();
				if(!options.strict){
					//Case-insensitive comparison
					v = v.toLowerCase();
					days = dojo.map(days, function(d){return d.toLowerCase();});
				}
				v = dojo.indexOf(days, v);
				if(v == -1){
//					console.log("dojo.date.locale.parse: Could not parse weekday name: '" + v + "'.");
					return false;
				}

				//TODO: not sure what to actually do with this input,
				//in terms of setting something on the Date obj...?
				//without more context, can't affect the actual date
				//TODO: just validate?
				break;
			case 'D':
				result[1] = 0;
				// fallthrough...
			case 'd':
				result[2] = v;
				break;
			case 'a': //am/pm
				var am = options.am || bundle['dayPeriods-format-wide-am'],
					pm = options.pm || bundle['dayPeriods-format-wide-pm'];
				if(!options.strict){
					var period = /\./g;
					v = v.replace(period,'').toLowerCase();
					am = am.replace(period,'').toLowerCase();
					pm = pm.replace(period,'').toLowerCase();
				}
				if(options.strict && v != am && v != pm){
//					console.log("dojo.date.locale.parse: Could not parse am/pm part.");
					return false;
				}

				// we might not have seen the hours field yet, so store the state and apply hour change later
				amPm = (v == pm) ? 'p' : (v == am) ? 'a' : '';
				break;
			case 'K': //hour (1-24)
				if(v == 24){ v = 0; }
				// fallthrough...
			case 'h': //hour (1-12)
			case 'H': //hour (0-23)
			case 'k': //hour (0-11)
				//TODO: strict bounds checking, padding
				if(v > 23){
//					console.log("dojo.date.locale.parse: Illegal hours value");
					return false;
				}

				//in the 12-hour case, adjusting for am/pm requires the 'a' part
				//which could come before or after the hour, so we will adjust later
				result[3] = v;
				break;
			case 'm': //minutes
				result[4] = v;
				break;
			case 's': //seconds
				result[5] = v;
				break;
			case 'S': //milliseconds
				result[6] = v;
//				break;
//			case 'w':
//TODO				var firstDay = 0;
//			default:
//TODO: throw?
//				console.log("dojo.date.locale.parse: unsupported pattern char=" + token.charAt(0));
		}
		return true;
	});

	var hours = +result[3];
	if(amPm === 'p' && hours < 12){
		result[3] = hours + 12; //e.g., 3pm -> 15
	}else if(amPm === 'a' && hours == 12){
		result[3] = 0; //12am -> 0
	}

	//TODO: implement a getWeekday() method in order to test
	//validity of input strings containing 'EEE' or 'EEEE'...

	var dateObject = new Date(result[0], result[1], result[2], result[3], result[4], result[5], result[6]); // Date
	if(options.strict){
		dateObject.setFullYear(result[0]);
	}

	// Check for overflow.  The Date() constructor normalizes things like April 32nd...
	//TODO: why isn't this done for times as well?
	var allTokens = tokens.join(""),
		dateToken = allTokens.indexOf('d') != -1,
		monthToken = allTokens.indexOf('M') != -1;

	if(!valid ||
		(monthToken && dateObject.getMonth() > result[1]) ||
		(dateToken && dateObject.getDate() > result[2])){
		return null;
	}

	// Check for underflow, due to DST shifts.  See #9366
	// This assumes a 1 hour dst shift correction at midnight
	// We could compare the timezone offset after the shift and add the difference instead.
	if((monthToken && dateObject.getMonth() < result[1]) ||
		(dateToken && dateObject.getDate() < result[2])){
		dateObject = dojo.date.add(dateObject, "hour", 1);
	}

	return dateObject; // Date
};

function _processPattern(pattern, applyPattern, applyLiteral, applyAll){
	//summary: Process a pattern with literals in it

	// Break up on single quotes, treat every other one as a literal, except '' which becomes '
	var identity = function(x){return x;};
	applyPattern = applyPattern || identity;
	applyLiteral = applyLiteral || identity;
	applyAll = applyAll || identity;

	//split on single quotes (which escape literals in date format strings)
	//but preserve escaped single quotes (e.g., o''clock)
	var chunks = pattern.match(/(''|[^'])+/g),
		literal = pattern.charAt(0) == "'";

	dojo.forEach(chunks, function(chunk, i){
		if(!chunk){
			chunks[i]='';
		}else{
			chunks[i]=(literal ? applyLiteral : applyPattern)(chunk.replace(/''/g, "'"));
			literal = !literal;
		}
	});
	return applyAll(chunks.join(''));
}

function _buildDateTimeRE(tokens, bundle, options, pattern){
	pattern = dojo.regexp.escapeString(pattern);
	if(!options.strict){ pattern = pattern.replace(" a", " ?a"); } // kludge to tolerate no space before am/pm
	return pattern.replace(/([a-z])\1*/ig, function(match){
		// Build a simple regexp.  Avoid captures, which would ruin the tokens list
		var s,
			c = match.charAt(0),
			l = match.length,
			p2 = '', p3 = '';
		if(options.strict){
			if(l > 1){ p2 = '0' + '{'+(l-1)+'}'; }
			if(l > 2){ p3 = '0' + '{'+(l-2)+'}'; }
		}else{
			p2 = '0?'; p3 = '0{0,2}';
		}
		switch(c){
			case 'y':
				s = '\\d{2,4}';
				break;
			case 'M':
				s = (l>2) ? '\\S+?' : '1[0-2]|'+p2+'[1-9]';
				break;
			case 'D':
				s = '[12][0-9][0-9]|3[0-5][0-9]|36[0-6]|'+p3+'[1-9][0-9]|'+p2+'[1-9]';
				break;
			case 'd':
				s = '3[01]|[12]\\d|'+p2+'[1-9]';
				break;
			case 'w':
				s = '[1-4][0-9]|5[0-3]|'+p2+'[1-9]';
				break;
			case 'E':
				s = '\\S+';
				break;
			case 'h': //hour (1-12)
				s = '1[0-2]|'+p2+'[1-9]';
				break;
			case 'k': //hour (0-11)
				s = '1[01]|'+p2+'\\d';
				break;
			case 'H': //hour (0-23)
				s = '1\\d|2[0-3]|'+p2+'\\d';
				break;
			case 'K': //hour (1-24)
				s = '1\\d|2[0-4]|'+p2+'[1-9]';
				break;
			case 'm':
			case 's':
				s = '[0-5]\\d';
				break;
			case 'S':
				s = '\\d{'+l+'}';
				break;
			case 'a':
				var am = options.am || bundle['dayPeriods-format-wide-am'],
					pm = options.pm || bundle['dayPeriods-format-wide-pm'];
				s = am + '|' + pm;
				if(!options.strict){
					if(am != am.toLowerCase()){ s += '|' + am.toLowerCase(); }
					if(pm != pm.toLowerCase()){ s += '|' + pm.toLowerCase(); }
					if(s.indexOf('.') != -1){ s += '|' + s.replace(/\./g, ""); }
				}
				s = s.replace(/\./g, "\\.");
				break;
			default:
			// case 'v':
			// case 'z':
			// case 'Z':
				s = ".*";
//				console.log("parse of date format, pattern=" + pattern);
		}

		if(tokens){ tokens.push(match); }

		return "(" + s + ")"; // add capture
	}).replace(/[\xa0 ]/g, "[\\s\\xa0]"); // normalize whitespace.  Need explicit handling of \xa0 for IE.
}
})();

(function(){
var _customFormats = [];
dojo.date.locale.addCustomFormats = function(/*String*/packageName, /*String*/bundleName){
	// summary:
	//		Add a reference to a bundle containing localized custom formats to be
	//		used by date/time formatting and parsing routines.
	//
	// description:
	//		The user may add custom localized formats where the bundle has properties following the
	//		same naming convention used by dojo.cldr: `dateFormat-xxxx` / `timeFormat-xxxx`
	//		The pattern string should match the format used by the CLDR.
	//		See dojo.date.locale.format() for details.
	//		The resources must be loaded by dojo.requireLocalization() prior to use

	_customFormats.push({pkg:packageName,name:bundleName});
};

dojo.date.locale._getGregorianBundle = function(/*String*/locale){
	var gregorian = {};
	dojo.forEach(_customFormats, function(desc){
		var bundle = dojo.i18n.getLocalization(desc.pkg, desc.name, locale);
		gregorian = dojo.mixin(gregorian, bundle);
	}, this);
	return gregorian; /*Object*/
};
})();

dojo.date.locale.addCustomFormats("dojo.cldr","gregorian");

dojo.date.locale.getNames = function(/*String*/item, /*String*/type, /*String?*/context, /*String?*/locale){
	// summary:
	//		Used to get localized strings from dojo.cldr for day or month names.
	//
	// item:
	//	'months' || 'days'
	// type:
	//	'wide' || 'narrow' || 'abbr' (e.g. "Monday", "Mon", or "M" respectively, in English)
	// context:
	//	'standAlone' || 'format' (default)
	// locale:
	//	override locale used to find the names

	var label,
		lookup = dojo.date.locale._getGregorianBundle(locale),
		props = [item, context, type];
	if(context == 'standAlone'){
		var key = props.join('-');
		label = lookup[key];
		// Fall back to 'format' flavor of name
		if(label[0] == 1){ label = undefined; } // kludge, in the absence of real aliasing support in dojo.cldr
	}
	props[1] = 'format';

	// return by copy so changes won't be made accidentally to the in-memory model
	return (label || lookup[props.join('-')]).concat(); /*Array*/
};

dojo.date.locale.isWeekend = function(/*Date?*/dateObject, /*String?*/locale){
	// summary:
	//	Determines if the date falls on a weekend, according to local custom.

	var weekend = dojo.cldr.supplemental.getWeekend(locale),
		day = (dateObject || new Date()).getDay();
	if(weekend.end < weekend.start){
		weekend.end += 7;
		if(day < weekend.start){ day += 7; }
	}
	return day >= weekend.start && day <= weekend.end; // Boolean
};

// These are used only by format and strftime.  Do they need to be public?  Which module should they go in?

dojo.date.locale._getDayOfYear = function(/*Date*/dateObject){
	// summary: gets the day of the year as represented by dateObject
	return dojo.date.difference(new Date(dateObject.getFullYear(), 0, 1, dateObject.getHours()), dateObject) + 1; // Number
};

dojo.date.locale._getWeekOfYear = function(/*Date*/dateObject, /*Number*/firstDayOfWeek){
	if(arguments.length == 1){ firstDayOfWeek = 0; } // Sunday

	var firstDayOfYear = new Date(dateObject.getFullYear(), 0, 1).getDay(),
		adj = (firstDayOfYear - firstDayOfWeek + 7) % 7,
		week = Math.floor((dojo.date.locale._getDayOfYear(dateObject) + adj - 1) / 7);

	// if year starts on the specified day, start counting weeks at 1
	if(firstDayOfYear == firstDayOfWeek){ week++; }

	return week; // Number
};

}

if(!dojo._hasResource['wm.base.lib.date']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['wm.base.lib.date'] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide('wm.base.lib.date');


wm.setTimeZoneOffset = function() {
    wm.timezoneOffset = new Date().getTimezoneOffset()/60 + wm.serverTimeOffset/(1000*60*60); // hours offset
    if (isNaN(wm.timezoneOffset))
	wm.timezoneOffset = 0;
}
if (wm.serverTimeOffset !== undefined) wm.setTimeZoneOffset();


wm.convertValueToDate = function(inValue, inParams) {
    if (inValue instanceof Date) return inValue;
	var v = inValue, s = inParams || {selector: "date"};
	if (!v && v !== 0)
	{
		return null;
	}
        else if (Number(v) || typeof(v) == "number")
	{
		return new Date(Number(v));
	}
	else if (dojo.trim(v.toLowerCase()).indexOf('today') != -1)
	{
		// this block handles cases were user might enter:
		// v = today
		// v = today + 20
		// v = 20 + today
		// case and spaces does not matter.
		if (v.indexOf('+') != -1)
		{
			var range = v.toLowerCase().split('+');
			try
			{
				var date1 = dojo.trim(range[0]);
				var date2 = dojo.trim(range[1]);
				if (date1 == 'today')
				{
					v = dojo.date.add(new Date(),"day",date2*1);
				}
				else
				{
					v = dojo.date.add(new Date(),"day",date1*1);
				}

			}
			catch (e)
			{
				// do nothing and later we will pass default today's date.
			}
		}
		else
		{
			v = new Date();
		}

		return v;
	}

	return v != Number(v) ? dojo.date.locale.parse(v, s) : new Date(Number(v));
}

}

if(!dojo._hasResource['wm.base.lib.types']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['wm.base.lib.types'] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide('wm.base.lib.types');

wm.typeManager = {
	types: {},
	initialized: false,
    initTypes: function() {
        if (wm.types && wm.types.types) {
            wm.typeManager.setTypes(wm.types.types);
        } else {
            this.addDefaultTypes();
        }
    },
    setTypes: function(inTypes) {
        this.clearTypes();
        if (inTypes) {

            /* Handle special types that the server fails to fully define for us */
            wm.forEachProperty(inTypes, function(inTypeDef, inName) {
                var matches = inName.match(/\<(.*),(.*)\>/);
                if (matches) {
                    inTypeDef.isList = true;
                    inTypeDef.isHashMap = true;
                    inTypeDef.fields = {
                        name: {
                            include: ["read"],
                            isList: false,
                            type: matches[1]
                        },
                        dataValue: {
                            isList: false,
                            type: matches[2]
                        }
                    };
                }
            });
            dojo.mixin(this.types, inTypes);
        }
        this.addDefaultTypes();

    },

	clearTypes: function() {
		this._publicTypes = {};
	        if (wm.dataSources) {
	            wm.dataSources.clearSources();
		}
		// clear all non-user types
		for (var i in this.types) {
			if (!this.types[i].userType)
				delete this.types[i];
		}
	},
        getPrimaryKey: function(inType) {
	    if (!inType || !inType.fields) return "";
	    for (var fieldName in inType.fields) {
		if (inType.fields[fieldName].include.length)
		    return fieldName;
	    }
	},
	getPrimitiveType: function(inTypeName) {
		return (this.types[inTypeName] || 0).primitiveType;
	},
	isStructuredType: function(inTypeName) {
		return this.types[inTypeName] && !this.getPrimitiveType(inTypeName);
	},
	getService: function(inTypeName) {
		var t = this.types[inTypeName];
		return (t && t.service);
	},
	getLiveService: function(inTypeName) {
		var t = this.types[inTypeName];
		return (t && t.liveService && t.service);
	},
	generatePublicTypes: function() {
		var types = {};
		for (var i in this.types)
			if (this.isPublicType(i))
				types[i] = this.types[i];
		return types;
	},
	getPublicTypes: function() {
		return wm.isEmpty(this._publicTypes) ?
			this._publicTypes = this.generatePublicTypes() : this._publicTypes;
	},
	getLiveServiceTypes: function() {
		var types = this.getPublicTypes(), liveServiceTypes = {};
		for (var i in types)
			if (this.getLiveService(i))
				liveServiceTypes[i] = types[i];
		return liveServiceTypes;
	},
	isPublicType: function(inTypeName) {
		var t = this.types[inTypeName];
		return (t && !t.internal && !t.primitiveType);
	},
	getTypeSchema: function(inTypeName) {
		return (this.types[inTypeName] || 0).fields;
	},
	getType: function(inTypeName) {
		return this.types[inTypeName];
	},
	isType: function(inTypeName) {
		return Boolean(this.getType(inTypeName));
	},
	typeHasField: function(inTypeName, inFieldName) {
	   var typeDef = this.types[inTypeName];
	   if (!typeDef) return false;
	   var fieldNames = inFieldName.split(/\./);
	   for (var i = 0; i < fieldNames.length; i++) {
	       var fieldDef = typeDef.fields[fieldNames[i]];
	       if (!fieldDef) return false;
	       if (i + 1 < fieldNames.length) {
	           typeDef = this.types[fieldDef.type];
	           if (!typeDef) return false;
	       }
	   }	
	   return true;
	},
	getPropertyInfoFromSchema: function(inTypeSchema, inPropName) {
		var
			s = inTypeSchema,
			parts = dojo.isString(inPropName) ? inPropName.split(".") : inPropName,
			p = parts.shift(),
			f = s[p];
		if (!parts.length)
			return f;
		else {
			var
				t = (f || 0).type,
				ts = this.getTypeSchema(t);
			if (ts)
				return this.getPropertyInfoFromSchema(ts, parts);
		}
	},

	getFilteredPropNames: function(inTypeSchema, inFilterFunc) {
		var ts = [], u = [], t, hasFilter = dojo.isFunction(inFilterFunc);
		wm.forEach(inTypeSchema, function(o, i) {
			if (!hasFilter || inFilterFunc(o)) {
				var elem = {};
				elem.info = o;
				elem.name = i;
				ts.push(elem);
			}
		});

		ts.sort(function(a, b) {
			return (a.info.fieldOrder - b.info.fieldOrder);
		});
		for (i=0; (ti=ts[i]); i++) {
			u.push(ti.name);
		}

		return u;
	},
	getSimplePropNames: function(inTypeSchema) {
		return this.getFilteredPropNames(inTypeSchema, function(p) {
			return !wm.typeManager.isStructuredType((p || 0).type);
		});
	},
    

    getFieldList: function(inTypeSchema, inPath, maxDepth) {
        if (typeof inTypeSchema == "string") inTypeSchema = this.getType(inTypeSchema).fields;

        var result = [];
        for (var i in inTypeSchema) {
            if (wm.typeManager.isStructuredType(inTypeSchema[i].type)) {
                if (!inTypeSchema[i].isList &&  !wm.isListType(inTypeSchema[i].type) && (maxDepth === undefined || maxDepth >= 0)) {
                    result = result.concat(this.getFieldList(inTypeSchema[i].type, inPath ? inPath + "." + i : i, maxDepth === undefined ? undefined : maxDepth-1));
                }
            } else {
                result.push({
                    dataIndex: (inPath ? inPath + "." : "") + i,
                    caption: wm.capitalize(i),
                    displayType: wm.capitalize(inTypeSchema[i].type)
                });
            }
        }
        return result;
    },
        getStructuredPropNames: function(inTypeSchema, includeIsList) {
		return this.getFilteredPropNames(inTypeSchema, function(p) {
			return wm.typeManager.isStructuredType((p || 0).type) || includeIsList && p.isList;
		});
	},
	getPropNames: function(inTypeSchema, inStructured) {
		var
			u = this.getSimplePropNames(inTypeSchema),
			s = inStructured ? this.getStructuredPropNames(inTypeSchema) : [];
		return u.concat(s);
	},
	// returns an array of each property part ordered in schema
	getPropertyOrder: function(inType, inPropName) {
		var
			o = [],
			parts = dojo.isString(inPropName) ? inPropName.split(".") : inPropName,
			p = parts.shift(),
			schema = this.getTypeSchema(inType),
			propertyArray = this.getPropNames(schema, true);
		var c, l = propertyArray.length;
		// find property in array
		for (var i=0, n; (n = propertyArray[i]); i++)
			if (p == n) {
				c = i;
				break;
			}
		o.push(c !== undefined ? c : l);
		var
			f = schema && schema[p],
			t = (f || 0).type;
		// if no properties to descend to, return array of indices
		if (!parts.length || !t)
			return o;
		// otherwise recurse
		else
			return o.concat(this.getPropertyOrder(t, parts));
	},
	hasStructuredType: function(inTypeName, inCondition) {
		var s = this.getTypeSchema(inTypeName), p, c = dojo.isFunction(inCondition) && inCondition;
		for (var i in s) {
			p = s[i];
			if (this.isStructuredType(p.type))
				if (c) {
					if (c(p))
						return true;
				} else
					return true;
		}
	},
	// these types can be added indepenedent of server types
	addType: function(inName, inTypeInfo) {
		if (!inTypeInfo || wm.isEmpty(inTypeInfo))
			return;
		inTypeInfo.userType = true;
		this.types[inName] = inTypeInfo;
		if (this.isPublicType(inName) && !wm.isEmpty(this._publicTypes))
			this._publicTypes[inName] = inTypeInfo;
	},
	removeType: function(inName) {
	   if (this._publicTypes) {
	       delete this._publicTypes[inName];
	   }	   
        delete this.types[inName];
	},
	addDefaultTypes: function() {
	    if (!this.initialized) {
		this.initialized = true;
		var d = wm.defaultTypes || {};
		for (var i in d)
			this.addType(i, d[i]);
	    }
	},
	isPropInList: function(inTypeSchema, inPropName) {
		var
			s = inTypeSchema,
			parts = dojo.isString(inPropName) ? inPropName.split(".") : inPropName,
			p = parts.shift(),
			f = s[p];
		if (!f)
			return false;
		else if (f.isList)
			return true;
		else if (parts.length) {
			var
				t = (f || 0).type,
				ts = this.getTypeSchema(t);
			if (ts)
				return this.isPropInList(ts, parts);
		}
	},
    getDisplayField: function(inType) {
	    var typeDef = wm.typeManager.getType(inType);
	    if (!typeDef) return "";
	    var fields = typeDef.fields;
	    var stringFields = {};
	    var literalFields = {};
	    for (fieldName in fields) {
		var field = fields[fieldName];
		if (!field.exclude || field.exclude.length == 0) {
		    if (field.type == "java.lang.String" || field.type == "StringData") {
			stringFields[fieldName] = field;
		    } else if (!wm.typeManager.isStructuredType(field.type)) {
			literalFields[fieldName] = field;
		    }
		}
	    }

	    for (var fieldName in stringFields) {
		var lowestFieldOrder = 100000;
		var lowestFieldName;
		if (!dojo.isFunction(stringFields[fieldName])) { // ace damned changes to object prototype
		    if (stringFields[fieldName].fieldOrder === undefined && !lowestFieldName) {
			lowestFieldName = fieldName;
		    }
		    else if (stringFields[fieldName].fieldOrder !== undefined &&
			stringFields[fieldName].fieldOrder < lowestFieldOrder)
		    {
			lowestFieldOrder = stringFields[fieldName].fieldOrder;
			lowestFieldName = fieldName;
		    }
		}
	    }
	    if (lowestFieldName) {
		return lowestFieldName;
	    }


	    for (var fieldName in literalFields) {
		var lowestFieldOrder = 100000;
		var lowestFieldName;
		if (!dojo.isFunction(literalFields[fieldName])) { // ace damned changes to object prototype
		    if (literalFields[fieldName].fieldOrder === undefined && !lowestFieldName) {
			lowestFieldName = fieldName;
		    }
		    else if (literalFields[fieldName].fieldOrder !== undefined &&
			     literalFields[fieldName].fieldOrder < lowestFieldOrder) {
			lowestFieldOrder = literalFields[fieldName].fieldOrder;
			lowestFieldName = fieldName;
		    }
		}
	    }
	    if (lowestFieldName) {
		return lowestFieldName;
	    }
	    for (fieldName in fields) {
		return fieldName;
	    }
    }

};

wm.defaultTypes = {
	NumberData: {
		fields: {
			dataValue: {type: "Number"}
		}
	},
	BooleanData: {
		fields: {
			dataValue: {type: "Boolean"}
		}
	},
	StringData: {
		fields: {
			dataValue: {type: "String"}
		}
	},
	DateData: {
		fields: {
			dataValue: {type: "Date"}
		}
	},
	EntryData: {
		fields: {
			name: {type: "string"},
		    dataValue: {type: "any",
				"include": ["delete","read","update","insert"]}
		}
	},
	AnyData: {
		fields: {
			dataValue: {type: "any"}
		}
	}
};
/*AnyData: {value: {type: "Any", isList: false, isObject: false}},
StringData: {stringValue: {type: "String", isList: false, isObject: false}},
NumericData: {numericValue: {type: "Number", isList: false, isObject: false}},
ListData: {listValue: {type: "Any", isList: true, isObject: false}}
*/
//wm.types = {};
//wm.primitives = {};

wm.isListType = function(inTypeName) {
	return inTypeName && (inTypeName.charAt(0) == "[" || inTypeName.match(/\<.*,.*\>/));
}
wm.isHashMapType = function(inTypeName) {
    var typeDef = wm.typeManager.getType(inTypeName);
    return typeDef && typeDef.isHashMap;
}
// use forceList to optionally force friendly type to show list.
wm.getFriendlyTypeName = function(inType, inForceList) {
	inType = inType || "(any)";
	var
		s = wm.typeManager.getService(inType),
		isList = wm.isListType(inType),
		t = s && !inType.match(/\</) ? [s, inType.split(".").pop()].join('.') : inType;
	 if (!wm.isHashMapType(inType)) {
        if (isList)
    		t = t.slice(0,-1);
    	if (inForceList || isList)
    		t = t + " list";
    }
	return t;
}

wm.getPrimitiveDisplayType = function(inPrimitiveName) {
	var t = wm.typeManager.getPrimitiveType(inPrimitiveName);
	if (t == "Boolean")
		t = "CheckBox";
	if (!t || t == "String")
		t = "Text";
	return t;
}

wm.getDisplayType = function(propInfo) { //xxx
	var t;
	var subType = propInfo.fieldSubType;
	if (subType != undefined && subType != null && subType.length > 0) {
		if (subType == "picklist")
			t = "Select";
		else if (subType == "textarea")
			t = "LargeTextArea";
		else if (subType == "boolean")
			t = "CheckBox";
		else if (subType == "date")
			t = "Date";
		else if (subType == "datetime")
			t = "Time";
		else if (subType == "currency")
			t = "Currency";
		else
			t = "Text";
	} else {
		t = wm.getPrimitiveDisplayType(propInfo.type);
	}

	return t;
}

}

if(!dojo._hasResource['wm.base.lib.data']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['wm.base.lib.data'] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide('wm.base.lib.data');

wm.data = wm.data || {};

dojo.mixin(wm.data, {
	// returns fields that should be included for type
	getIncludeFields: function(inTypeName) {
		var
			pi, fields=[],
			schema = wm.typeManager.getTypeSchema(inTypeName);
		for (var i in schema) {
			pi = schema[i];
			if (pi.include && pi.include.length) {
				// composite key
				if (wm.typeManager.isStructuredType(pi.type)) {
					var compSchema = wm.typeManager.getTypeSchema(pi.type);
					for (var j in compSchema)
						fields.push(i + "." + j);
				} else
					fields.push(i);
			}
		}
		return fields;
	},
	// Reports if given data of type has include data.
	// This is equivalent to having primary key information
	// that is necessary for initiating update and delete operations.
	// By default related structured types are not checked for include data
	// That information is typically not required for update / delete operations.
	hasIncludeData: function(inTypeName, inData) {
		if (!inData || wm.isEmpty(inData))
			return false;
		var fields = this.getIncludeFields(inTypeName);
		for (var i=0, f; f=fields[i]; i++)
			if (dojo.getObject(f, false, inData) === undefined)
				return;
		return true;
	},
	// Reports if given data of type contains necessary contents
	// to perform given operation. 
	hasOperationData: function(inOperation, inTypeName, inData) {
		if (!wm.typeManager.getLiveService(inTypeName))
			return false;
		switch(inOperation) {
			// read ok if we provide no data or we have necessary root include data
			case "read":
				return !inData || wm.data.hasIncludeData(inTypeName, inData);
			// root include data is required for delete and update
			case "delete":
			case "update":
				return wm.data.hasIncludeData(inTypeName, inData);
			// for insert all required root and provided related required data is necessary
			case "insert":
				return wm.data.hasRequiredData(inOperation, inTypeName, inData, true);
		}
	},
	// Reports if given data of type contains all required data
	// This info is helpful for determining if there's enough data to perform an insert operation
	// In this case we want to check structured related data also.
	// Operation and the structured data flag are provided for additional flexibility...
	hasRequiredData: function(inOperation, inTypeName, inData, inCheckStructured) {
		var schema = wm.typeManager.getTypeSchema(inTypeName),
			s, d, isStructured, hasData, missingRequired, hasExcluded;
		for (var i in schema) {
			s = schema[i];
			isStructured = wm.typeManager.isStructuredType(s.type);
			d = inData && inData[i];
			// check structured type
			if (isStructured && inCheckStructured) {
				if ((d || s.required) && !s.isList && !this.hasRequiredData(s.type, d, inCheckStructured))
					return false;
			} else {
				hasData = (d !== undefined);
				missingRequired = s.required && !hasData;
				// return false if we have excluded data or missing required data.
				if (dojo.indexOf(s.exclude, inOperation) != -1 ? hasData : missingRequired)
					return false;
			}
		}
		return true;
	},
	// binding
	clearBinding: function(inObject, inTargetProperty) {
		var w = wm.data.getPropWire(inObject, inTargetProperty);
		if (w) {
			var b = w.owner, target = w.target, tp = w.targetProperty;
			// note: removing wire may have side-effects so reset value with care after removing.
			if (b)
				b.removeWire(w.getWireId());
			// reset value here.
			if (target && tp)
				target.setValue(tp, "");
		}
	},
	getPropWire: function(inTargetObject, inTargetProperty) {
		var
			tp = inTargetProperty,
			tobj = inTargetObject,
			binding = tobj && tobj.$.binding,
			// Note: target bindings are stored in wires hash by targetProperty
			// source bindings has targetId appended so they will be ignored below
			w = binding && binding.wires[tp];
		// if there's a target binding, return it
		if (w)
			return w;
		// FIXME: design check...
		var ownerApp = tobj && tobj.isDesignLoaded() ? studio.application : app;
		// otherwise, if the object is owned by the application try to return a source binding.
		if (tobj && tobj.isOwnedBy(ownerApp))
			return wm.data.findSourceWire((tobj||0).getId(), tp);
	},
	findSourceWire: function(inTargetId, inProp) {
		if (inTargetId) {
			var c, o, id, wires, w;
			// search all components, wee...
			for (var i in wm.Component.byId) {
				c = wm.Component.byId[i];
				// FIXME: design check...
				if ((c instanceof wm.Binding) && (c.isDesignLoaded() || !(window.studio && window.studio._isWaveMakerStudio))) {
					var wires = c.findWiresByProps({targetId: inTargetId, targetProperty: inProp});
					if (wires.length)
						return wires[0];
				}
			}
		}
	},
	// FIXME: deprecated
	/*getPropertyBindWire: function(inBinding, inTargetProperty) {
		var wires = inBinding.wires, w;
		for (var i in wires) {
			w = wires[i];
			if (w.targetProperty == inTargetProperty)
				return w;
		}
	},*/
	getPropBindSource: function(inTargetObject, inTargetProperty) {
		var w = wm.data.getPropWire(inTargetObject, inTargetProperty);
		if (w)
			return inTargetObject.getValueById(w.source);
	},
	// a simple comparator
	compare: function(a, b) {
		return a === b ? 0 :
			a === undefined ? -1 :
			b === undefined ? 1 :
			b === null ? 1 :
			a > b ? 1 :
			-1;
	},

    compareNumbers: function(a, b) {
	var na = wm.isNumber(a), nb = wm.isNumber(b);
	return na && nb ? a - b : (na ? -1 : (nb ? 1 : 0));
    }

});

}

if(!dojo._hasResource["wm.base.data.expression"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.data.expression"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide("wm.base.data.expression");

/**
	@class
	Static API for handling data expressions.
	Data expressions are strings can contain valid JavaScript and
	special macros.
	Macros are expanded via preprocessing, and use this syntax:
	<pre class="code">${&lt;id&gt;}</pre>
	&lt;id&gt; supports dot notation, e.g. ${address.name.lastName}.<br/>
	<br/>
	<b>Example:</b>
	<pre class="code">
"Half of " + ${editor1.dataValue} + " is " + ${editor1.dataValue}/2.

<i>// Macros are replaced with quoted JSON and should not be inside of literal strings</i>
"${lastName}, ${firstName}" <i>// bad</i>
${lastName} + ", " + ${firstName} <i>// good</i>
</pre>
*/
wm.expression = {
	/**
		Evaluate expression with given namespace root.
		@param {String} inExpression Valid javascript that is evaluated in global scope. The expression can contain 
			macros.
		@param {String} inRoot The root object under which id macros are evaluated.
		@example 
var exp = '"Half of " + ${editor1.dataValue} + " is " + ${editor1.dataValue}/2.';
wm.expression.getValue(exp, app.main);
	*/
       getValue: function(inExpression, inRoot, inOwner) {
	   var v = wm.expression._getText(inExpression, inRoot);
	   var result = "";
	   try {
	       var f  = function() {	
		   result = eval(v);	
	       }.call(inOwner);
	   } catch(e){}
	   return result;
	   //return wm.evalJs(v,inRoot);
	},
	getSources: function(inExpression) {
		var re = wm.expression._getSourceRegEx

		re.lastIndex = 0;
		var sources = (inExpression || "").match(re, "g") || [];
		for (var i = 0; i < sources.length; i++) {
		  sources[i] = sources[i].substring(2,sources[i].length-1);
		}
		return sources;
	/*
		var m, sources=[];
		while((m = re.exec(inExpression)) != null) {
		  sources.push(m[1]);
		  var mList = m[1].split(".");
		  mList.pop();
		  while(mList.length > 1) {
		    sources.push(mList.join("."));
		    mList.pop();
		  }
		}
		return sources;
		*/
	},
	_getText: function(inExpression, inRoot) {
		//return inExpression.replace(wm.expression._getSourceRegEx(), function(){
		return inExpression.replace(wm.expression._getSourceRegEx, function(){
			try {
			    var inSource = arguments[1];
			    if (inSource.match(/^\[.*\]/)) {
				var matches = inSource.match(/^\[(.*?)\]/);
				inSource = inSource.replace(/^\[(.*?)\]\./, "");
				var root = wm.Page.getPage(matches[1]);
				var v = root ? root.getValue(inSource) : "";
			    } else if (inRoot.getValue){
				var v = inRoot.getValue(inSource);
			    }
			    else if (inSource.indexOf('.') != -1){
					var arr = inSource.split('.');
					var v = inRoot;		
					dojo.forEach(arr, function(prop){
					    if (v != null)
						v = v[prop];
					});
				} else {
				    var v = inRoot[inSource];
				}
				// objects cannot be returned directly since they are eval'd.
				if (v instanceof wm.Component) {
				    return v.getRuntimeId();
				} else if (v instanceof wm.Object || v === undefined)
					v = "";
				
			    if (v instanceof Date)
				return "new Date(" + v.getTime() + ")";
			    else
				return dojo.toJson(v);
			} catch(e) {}
		});
	},
	_getSourceRegEx: new RegExp(/\$\{([^\s\:\}]+)(?:\:([^\s\:\}]+))?\}/g)
	//_getSourceRegEx: function() {
	//	return new RegExp(/\$\{([^\s\:\}]+)(?:\:([^\s\:\}]+))?\}/g);
	//}
}

}

if(!dojo._hasResource["wm.base.Object"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.Object"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide("wm.base.Object");


/**
	Base class that supports property inspection and binding.
	<br/><br/>
	Almost all objects in WaveMaker are instances of <i>wm.Object</i>.
	In particular, all Components and Widgets descend from <i>wm.Object</i>
	<br/><br/>
	<i>wm.Object</i> supports a generalized property system: in order to
	access or modify properties on a <i>wm.Object</i> use the
	<a href="#getValue">getValue</a>/<a href="#setValue">setValue</a> API.
	<br/><br/>
	<a href="#getValue">getValue</a> takes the name of the property to examine.
	<a href="#setValue">setValue</a> takes
	the name of the property and the value to set.
	<a href="#getValue">getValue</a>/<a href="#setValue">setValue</a> support dot notation.
	<br/><br/>
	For all objects that descend from <i>wm.Object</i>.use the
	<a href="#getValue">getValue</a>/<a href="#setValue">setValue</a>
	API to access documented properties
	<br/><br/>
	Examples
	@example
	// To examine the name of a Component
	var n = this.myComponent.getValue("name");
	<br/>
	// To change the name of the Component
	this.myComponent.setValue("name", "newName");
	<br/>
	//"panel1" contains an object named "label1"
	this.panel1.setValue("label1.caption", "hello world");

	@name wm.Object
	@class
*/
dojo.declare("wm.Object", null, {
	/** @lends wm.Object.prototype */
	// hey ma, no props!
	//===========================================================================
	// Construction
	//===========================================================================
	constructor: function() {
		this.type = this.declaredClass;
	},
	/**
		Returns a string identifier (primarily for debugging).
	*/
	toString: function() {
		return '[' + this.declaredClass + ']';
	},
	//===========================================================================
	// Properties
	//===========================================================================
	/** @private */
	getProp: function(inPropertyName) {
		var g = this._getPropWorker(this, inPropertyName, "get");
		if (g)
			return g.call(this, inPropertyName);
		else
			return this._getProp(inPropertyName);
	},
	_getProp: function(inProp) {
		return this[inProp];
	},
	/** @private */
	setProp: function(inProp, inValue) {
		if (this.isDestroyed)
			return;
		var s = this._getPropWorker(this, inProp, "set");
		if (s)
			s.call(this, inValue);
		else
			this._setProp(inProp, inValue);
		this.valueChanged(inProp, this.getProp(inProp));
	},
	_setProp: function(inProp, inValue) {
		if (inProp in this)
			this[inProp] = inValue;
	},
	_getPropWorker: function(inObj, inProp, inPrefix) {
		//if (inProp=="dataValue" || inProp=="value")
		//	return null;
	    if (inProp == "value") return null;
		var w = inObj._isDesignLoaded && inObj[inPrefix + "_" + inProp] || this[inPrefix + inProp.slice(0, 1).toUpperCase() + inProp.slice(1)];
		if (dojo.isFunction(w))
			return w;
	},
	//===========================================================================
	// Values
	//===========================================================================
	/** @private */
	valueChanged: function(inProp, inValue) {
	},
	_getValue: function(inProp) {
		// private API for getting a named value/property
		// for Object, values are props
		return this.getProp(inProp);
	},
	_setValue: function(inProp, inValue) {
		// private API for setting a named value/property
		// for Object, values are props
		this.setProp(inProp, inValue);
	},
	/**
		Get the value of a named property.

		Supports dot notation, e.g.
		@example this.getValue("customer.name.first")

		@param {String} inName Name of property

		@see <a href="#setValue">setValue</a>
	*/
	getValue: function(inName) {
		// public API for getting a named value/property using dot-notation
		// all *actual* getting is delegated, we only manage dots here
		// inProp is like "foo.bar.baz" or ["foo", "bar", "baz"]
		if (!inName)
			return;

		// Replace all [\d+] with .[\d+] so that split will work properly and separate out array index substrings
	    var parts = dojo.isString(inName) ? inName.replace(/([^\.])\[/g, "$1.[").split('.') : inName;

	    // if we get something stupid like "studio.wip.widgetname" thats not going to be resolvable by this object as this object won't
	    // know what studio is.  window does know what studio is...
	    var o = (parts[0] == "studio" && this instanceof wm.Application) ? window : this;
	    var p;
		while (parts.length > 1) {
			p = parts.shift();
			var pmatch;
			// replace ${myVar[5]} with ${myVar.[5]}
			if (this instanceof wm.Variable || this instanceof Array) {
			  pmatch =  p.match(/^\[(\d+)\]$/);
		        }
			if (pmatch && this instanceof wm.Variable)
			  o = o.getItem(pmatch[1]);
			else if (pmatch && this instanceof Array)
			  o = o[pmatch1];
			else
			  o = o.getValue ? o.getValue(p) : o[p];
			if (!o) {
				wm.logging && console.debug(this, "notice: Object.getValue: couldn't marshall property ", p, " for ", inName);
				return;
			}
			if (o.getValue)
				return o.getValue(parts);
		}
		p = parts.shift();
		return o._getValue ? o._getValue(p) : o[p];
	},
	/**
		Set the value of a named property.
		Using this method to set properties is <b>required</b> to support binding.

		Supports dot notation, e.g.
		@example this.setValue("customer.name.first", "Harry")

		@param {String} inName Name of property
		@param {Any} inValue Value to set on property

		@see <a href="#setValue">getValue</a>
	*/
	setValue: function(inName, inValue) {
		// public API for setting a named value/property using dot-notation
		// all *actual* setting is delegated, we only manage dots here
		// inProp is like "foo.bar.baz" or ["foo", "bar", "baz"]
		var parts = dojo.isString(inName) ? inName.split('.') : inName, o=this, p;
		while (parts.length > 1) {
			o = o.getValue(parts.shift());
			// it's possible this value is not yet settable
			if (!o)
				return;
			if (o instanceof wm.Object)
				return o.setValue(parts, inValue);
		}
		p = parts.shift();
		o._setValue ? o._setValue(p, inValue) : o[p] = inValue;
	}
});

//===========================================================================
// Class Properties
//===========================================================================
/** @lends wm.Object */
dojo.mixin(wm.Object, {
	/**
		@private
		Object metadata (aka "schema") is stored using function prototypes
		(aka classes) to take advantage of built-in copy-on-write
		prototype chaining.
		Schema class is stored in a class-property called "schemaClass",
		and an instance of it is made available in the related class prototype
		as "schema".
	*/
	//FIXME: have I confused myself into using a overly complex mechanism?
	makeSchema: function(inClass) {
		//console.info("makeSchema:", inClass.prototype);
		// make an empty function so we get a prototype
		inClass.schemaClass = function(){};
		var superClass = inClass.superclass;
		try{
			if (inClass._meta.parents && inClass._meta.parents.length > 1){
				superClass = inClass._meta.parents[0].prototype;
			}
		}
		catch(e){
			// do nothing.
		}

		// if we have a superclass, chain to it's schema
		if (superClass) {
			var ctor = this.getSchemaClass(superClass.constructor);
			inClass.schemaClass.prototype = new ctor();
		}
		inClass.prototype.schema = new inClass.schemaClass();
		return inClass.schemaClass;
	},
	/** @private */
	// Get the schema class for class inClass. Manufacture the schema class if necessary.
	getSchemaClass: function(inClass) {
		return inClass.schemaClass || wm.Object.makeSchema(inClass);
	},
	/**
		Add entries to a class schema.
		Note that "inClass" is a class (function), not a class-name (string).

		@param {Function} inClass Add schema entries to this class.
		@param {Object} inSchema Schema entries in object notation.

		@example
wm.Object.extendSchema(wm.MyButton, {
	confirmPrompt: { writeonly: 1} // configure flags for confirmPrompt property
});
	*/
    extendSchema: function(inClass, inSchema, skipDictionary) {
	if (!skipDictionary && inSchema) {
	    var className = inClass.prototype.declaredClass;
	    if (wm.extendSchemaDictionary) {
		var dictionary = wm.extendSchemaDictionary[className];
		if (dictionary) {
		    for (var i in dictionary) {
			if (inSchema[i]) {
			    inSchema[i].shortname = dictionary[i];
			} else {
			    inSchema[i] = {shortname: dictionary[i]};
			}
		    }
		}
	    }
	}

	/* This block of code allows the superclass to define the schema and the subclass to modify the schema instead of clobbering the schema.
	 * The only thing that isn't modified is the ignore property; if ignore isn't there, then we assume the subclass isn't ignored.
	 */
	var superSchema = wm.Object.getSchemaClass(inClass).prototype;
	if (superSchema) {
	    for (var propName in inSchema) {
		if (superSchema[propName]) {
		    inSchema[propName] = dojo.mixin(dojo.clone(superSchema[propName]), inSchema[propName], !inSchema[propName].ignore ? {ignore: 0} : {});
		}
	    }
	}
	    dojo.extend(wm.Object.getSchemaClass(inClass), inSchema);
	    // expunge memoized property information
	    delete inClass._publishedProps;
	}
});

//===========================================================================
// Design Schema
//===========================================================================

wm.Object.extendSchema(wm.Object, {
	declaredClass: { ignore: 1 },
	schema: { ignore: 1 },
	schemaClass: { ignore: 1 },
    type: { ignore: 1 },
    setValue: {ignore: 1, group: "method"},
    getValue: {ignore: 1, group: "method", returns: "Any"}
});

//===========================================================================
// Design Time Extensions
//===========================================================================
/** @lends wm.Object.prototype */
/**#@+ @design */
wm.Object.extend({
	//===========================================================================
	// Extensions for property enumeration
	//===========================================================================
	/**
		Hook for subclasses to add flags to the typeInfo structure
		for property <i>inName</i>.
		Called from <a href="#getPropertyType">getPropertyType</a>.
		@param {String} inName Name of property.
		@param {Object} inTypeInfo Type info structure to modify.
	*/
	getPropFlags: function(inName, inTypeInfo) {
	},
	/**
		Get type information for a property.
		Returns a structure containing schema information for property <i>inName</i>,
		including at least the following fields:
		<ul>
			<li>type: <i>(string) name of type</i></li>
			<li>isObject: <i>(boolean) true if property is itself a wm.Object</i></li>
			<li>isEvent: <i>(boolean) true if property represents an event</i></li>
		</ul>
	*/
	getPropertyType: function(inName) {
		var v = this.getProp(inName);
		var t = {
			type: v && v.type || typeof v,
			isObject: v instanceof wm.Object
		}
	        if (t.type == "number" && isNaN(v)) {
		    t.type = "string"; // don't know the correct type, but string being converted to number is how we get NaN, so don't convert!
		}
		this.getPropFlags(inName, t);
		var s = this.schema[inName] || {
		    noprop: Boolean((v === undefined) || (v === null) || inName.charAt(0)=='_' || (dojo.isFunction(v) || dojo.isObject(v)) && !t.isCustomMethod)
		};
		return dojo.mixin(t, s);
	},
	// $ Build property information into ioProps from the properties of
	// $ inSchema filtered by inGetTypeInfo function (or getPropertyType by default).
	_listSchemaProperties: function(ioProps, inSchema, inGetTypeInfo) {
		var getInfo = this[inGetTypeInfo||"getPropertyType"], op = Object.prototype;
		for (var p in inSchema) {
			if (p == 'inherited'){
				//console.info('ignoring inherited function here..... for id = ', inSchema.id);
				continue;
			}

			if (!(p in ioProps) && !(p in op)) {
				var t = getInfo.call(this, p);
				if (!t.noprop)
					ioProps[p] = t;
			}
		}
		return ioProps;
	},
	//$ Combine property information from basic reflection with
	//$ explicit schema information to form a list
	//$ of property information records.
	_listProperties: function() {
		var props = {};
		this._listSchemaProperties(props, this);
		return this._listSchemaProperties(props, this.schema);
	},
	/**
		Return memoized list of property information records.
	*/
	listProperties: function() {
		var props = this.constructor._publishedProps || (this.constructor._publishedProps = this._listProperties());
		return dojo.clone(props);
	},
	/**
		Return memoized list of value information records.
		wm.Object does not distinguish properties from values, so
		the base implementation just calls <a href="#listProperties">listProperties</a>.
	*/
	listDataProperties: function() {
		return this.listProperties();
	}
});

/**#@-*/

//===========================================================================
// One-stop wm.Objects
//===========================================================================
wm.define = function(inClass, inSuperclasses, inProperties) {
	if (arguments.length < 3) {
		inProperties = inSuperclasses;
		inSuperclasses = wm.Control;
	}
	var schema = inProperties.published;
	delete inProperties.published;
	var ctor = dojo.declare(inClass, inSuperclasses, inProperties);
        wm.Object.extendSchema(ctor, schema);
	return ctor;
}

}

if(!dojo._hasResource["wm.base.Component"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.Component"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide("wm.base.Component");

if (!wm.Component ) {
/**
    Base class for all palette objects.
    <br><br>Component:
    <ul>
        <li>can own components, and can itself be owned.</li>
        <li>ensures all owned components have distinct names.</li>
        <li>can be identified by a globally unique string id.</li>
        <li>sends notification messages (via id) when it's values change</li>
        <li>can read or write it's properties to a stream</li>
    @name wm.Component
    @class
    @extends wm.Object
*/

dojo.declare("wm.Component", wm.Object, {
        theme: "wm_tundra", // default theme for all components (including Application and Page)

    /** @lends wm.Component.prototype */
    /**
        Name of this object.
        Must be unique to it's owner.
        @type String
        @example this.label1.setValue("name", "titleLabel");
    */
    name: '',
    /**
        Name of this object.
        Must be unique to it's owner.
        @type String
        @example newButton.setValue("owner", this);
    */
    owner: null,
    //=======================================================
    // Construction
    //=======================================================
    /**
        Component constructor optionally takes a set of properties to initialize on
        the new instance.
        @example
        var foo = new wm.Component({name: "foo"});
        @param {Object} inProperties Properties to initialize on the new instance.
        May be ommitted.
    */
    getParentDialog: function() {
        var w = this;
        while(w) {
            if(w instanceof wm.Dialog) {
                return w;
            } else {
                w = w.parent;
            }
        }
        return null;
    },
    getParentPage: function() {
        if(this instanceof wm.Page || this instanceof wm.PageDialog) return this;
        if(this.owner) return this.owner.getParentPage();
        return null;
    },
    getParentPageOrComposite: function() {
        if(wm.isInstanceType(this, [wm.Page, wm.PageDialog, wm.Composite])) return this;
        if(this.owner) return this.owner.getParentPageOrComposite();
        return null;
    },
    isAncestor: function(inOwner) {
        var o = this.owner;
        while(o && o != inOwner) {
            o = o.owner;
        }
        return(o == inOwner);
    },


    // perhaps should be called getAncestorInstanceOf; returns false if the widget/component lacks parent/owner that
    // is an instance of the specified class, else returns the class itself
    isAncestorInstanceOf: function(inClass) {
        // exit condition
        if (this == app._page || this == app || window["studio"] && (this == studio.application || this == studio.page))
            return false;

        if (wm.isInstanceType(this, inClass)) return this;

        if (this.parent)
            return this.parent.isAncestorInstanceOf(inClass)
        else if (this.owner)
            return this.owner.isAncestorInstanceOf(inClass)
        else
            return false;
    },
    getOwnerApp: function() {
        if (wm.isInstanceType(this, wm.Application)) return this;

        if (!this.isDesignLoaded()) {
            return window.app;
        } else {
            if (this == studio.page)
                return studio.application;
            else
                return this.owner.getOwnerApp();
        }
    },
    constructor: function(inProps) {
        this.$ = this.components = {};
        this._connections = [];
        this._subscriptions = [];
            if (djConfig.isDebug) {
            this._debugSubscriptions = [];
        }
        this._designee = this;
        this.isDestroyed = false;
/* no applicationDestroyed is no longer called
        if (!inProps || !inProps._temporaryComponent) // don't add pointers to this object if its temporary; temporary components may not have destroy called on them properly
        this._subscriptions.push(dojo.subscribe('applicationDestroyed', this, 'destroy')); */
    },
    postscript: function(inProps) {
        this.create(inProps);
        wm.Component.add(this);
    },

    create: function(inProps){
        try {
            this._initializing = true;
        if (wm.debugPerformance) this.startTimerWithName("create",this.declaredClass);
        this.prepare(inProps);
        //this.startTimerWithName("build",this.declaredClass);
        this.build();
        //this.stopTimerWithName("build",this.declaredClass);
        //this.startTimerWithName("init",this.declaredClass);
        this.init();

        if (this._designer)
            wm.fire(this, "designCreate");

        if (!this._loading) {
            this.postInit();
                delete this._initializing;
        }

            if (!this._temporaryComponent)
                dojo.addOnWindowUnload(this, '_unload');
        if (wm.debugPerformance) this.stopTimerWithName("create",this.declaredClass);
    } catch (e) {
        console.error("Error thrown; failed to create " + this.toString() + ": " + e);
    }
    },
    _unload: function() {
    	if (this.owner) this.owner._isUnloading = true;
    	this.destroy();
    },
    /**
        Remove this component from the system and clean up
        all resources.
    */

    destroy: function() {
        if (this.isDestroyed)
            return;
        try
        {
            this._disconnect();
            this._unsubscribe();
            wm.fire(this, "designDestroy");

            var comps = [];
            for (var n in this.components)
                comps.push(this.components[n]);
            for(var i=0, c; (c=comps[i]); i++)
            {
                c.destroy();
                for (var n in c)
                    delete c[n];
                c.isDestroyed = true;
            }
            comps = null;
            delete this.components;
            delete this.$;
            wm.Component.remove(this);
            this.setOwner(null);
            /*
            delete this.owner;
            delete this._designee;
            delete this.target;
            delete this.widgets;
            */
            this.isDestroyed = true;
        }
        catch(e)
        {
            //console.info('error while deleting component', e);
        }
    },
    prepare: function(inProps) {
        this.readProps(inProps);
        dojo.mixin(this, {flags:{}}, inProps);
        this.setOwner(this.owner);
    },
    readProps: function(inProps) {
    },
    build: function() {
    },
    init: function() {
        if (this.isDesignLoaded())
        this._isDesignLoaded = true;

        if (this.manageURL) {
            var connectTo = app ? app : this.getRoot();
            if (wm.Application && connectTo instanceof wm.Application) {
                this.connect(connectTo, "_generateStateUrl", this, "generateStateUrl");
            }
        }

        /* Insure that properties redefined by the theme get the value written to the property
         * rather than just using the prototype's value.  When running studio, a change in the theme
         * can cause properties to change AFTER the component was initialized.
         */
        if (window["studio"] && this.themeableProps) {
            dojo.forEach(this.themeableProps, function(inName) {
                var tmp = this[inName];
                delete this[inName];
                this[inName] = tmp;
            }, this);
        }
    },
    postInit: function() {
        this.valueChanged("", this);
    },
    loaded: function() {
          this._loading = false;
          this.postInit();
           delete this._initializing;
    },
    toString: function(inText) {
        var t = inText || "";
        return '[' + this.declaredClass + ((this.name) ? ':' + this.name : "") +  (this.isDestroyed ? ':' + wm.getDictionaryItem("wm.Component.toString_DESTROYED") : '') + t + ']';
    },
    //=======================================================
    // FIXME: deprecated, remove asap
    //=======================================================
    // Get a named component by ascending owner chain
    getComponent: function(inName) {
        return this.components[inName] || this.owner && this.owner.getComponent(inName);
    },
    //=======================================================
    // Design Support
    //=======================================================
    isDesignedComponent: function() {
/*
        if (!this.isDesignLoaded()) return false;

            var page = this.getParentPage();
        while (page && page.name != "wip")
        page = page.owner;

        return page.name == "wip";
*/
        return this.isDesignLoaded(); // Doh!
        },
    isDesignLoaded: function() {
        if (this._isDesignLoaded !== undefined) return this._isDesignLoaded;

        if (!window.studio || !this.owner) return false;
        if (this.owner == studio.application || this.owner == studio._application) return true; // must come before test for !studio.page
        if (!studio.page && !studio.application && !studio._application) return false;
        if (!this.owner) return false;
        var pp = this.getParentPageOrComposite();
        if (pp && pp == studio.page || this.owner == studio.page) return true; // getParentPage() test failed for PageDialogs owned by studio
        if (this == studio.page) return true;
        if (this.isOwnedBy(studio.application)) return true;
        if (window["app"] && !this.isOwnedBy(window["app"]) && window["app"] != this) return true;
        return false;
    },
    getPath: function() {
        // FIXME: hack, at least move studio awareness to design-only code
        var p = '';
        var o = this.owner;
        while (o && !o._hasCustomPath) o = o.owner;
        if (o && o._hasCustomPath) {
	    return this.owner.getPath();
	} else if (this.isDesignLoaded() && studio.project) {
            p = "projects/" + studio.project.getProjectPath() + "/";
        }

        return p;
    },
    //=======================================================
    // Ownership
    //=======================================================
    addComponent: function(inComponent) {
        var n = inComponent.name;
        //if (this.components[n])
        //  wm.logging && console.debug('Duplicate object name "' + n + '" in owner ' + this);
        this.components[n] = inComponent;
    },
    removeComponent: function(inComponent) {
        if (!this.components)
            return;

        var n = inComponent.name;
        if (this.components[n] == inComponent)
            delete this.components[n];
    },
    setOwner: function(inOwner, nonWritable) {
        var isDesign = this.isDesignLoaded();

        // setOwner is called any time a component is created or destroyed, so is a perfect place for
        // detecting when changes are made
        if (isDesign)
        wm.job("studio.updateDirtyBit",10, function() {studio.updateProjectDirty();});

        var originalOwner = this.owner;
        if (this.owner) {
            this.owner.removeComponent(this);
        }
        this.owner = inOwner;
        //this.cacheRuntimeId = this.getRuntimeId();
        if (this.owner) {
            if (!nonWritable) {
                this.owner.addComponent(this);
                /* It is possible for the owner to have a designer and the child to not have a designer; set this._isDesignLoaded to false to make this happen */
                if (!this._designer && this._isDesignLoaded !== false) {
                    this._designer = this.owner._designer;
                }
            }
            // if the owner has changed between being page and app level, then we need to reset IDs.
            // If there is a way to move components from one page to another, we'll need to do this as well, but
            // that does not yet exist.
            if ((!originalOwner && this.owner instanceof wm.Page == false) ||
            (this.owner != originalOwner && originalOwner &&
            (this.owner instanceof wm.Page == false && originalOwner instanceof wm.Page ||
             this.owner instanceof wm.Page && originalOwner instanceof wm.Page == false)))
            {
            this.updateId();
            // If my id has been changed by this, then so will all of my children's ids...
            if (this.isDesignLoaded())
                this.resetChildIds();
                    }
        }
            delete this.rootId;

    },
    isOwnedBy: function(inOwner) {
        var o = this.owner;
        while (o) {
            if (o == inOwner)
                return true;
            o = o.owner;
        }
    },
    qualifyName: function(inName) {
        inName = this.name + '_' + inName;
        if (window.studio && (window.studio.page == this.owner || window.studio.application == this.owner))
            return inName;
        return this.owner ? this.owner.qualifyName(inName) : inName;
    },
    getUniqueName: function(inName) {
        return wm.findUniqueName(inName, [this, this.components]);
    },
    //=======================================================
    // Name & Id
    //=======================================================
    setName: function(inName) {
        if (!inName)
            return;
        wm.Component.remove(this);
        this.owner.removeComponent(this);
        this.name = inName;
        this.owner.addComponent(this);
        this.updateId();
        wm.Component.add(this);
    },
    updateId: function() {
            var id = this.makeId();
            if (id != this.id) {
            this.id = id;
            delete this.runtimeId;
        }
    },

    // make a streamable id
    // an id is fully qualified within its root
    makeId: function(inName) {
        inName = this.name + (inName ? (this.name ? "." : "") + inName : "");
        return this.owner ? this.owner.getId(inName) : inName;
    },
    /**
        Return a string that can identify a name as a child of
        this component in the namespace of the root object.
        @see <a href="#getRoot">getRoot</a>
        @param {String} inName The name to qualify.
        @returns {String} The qualified id string.
    */
    getId: function(inName) {
        if (inName)  return this.makeId(inName);
        var id = this.id;
        if (!this.id || this.isDesignLoaded()) {
            var id = this.makeId();
            this.id = id;
        }
        return id;
    },
/*
    getBindId: function() {
    var owner = this;
    while(owner && owner instanceof wm.Page == false)
        owner = owner.owner;

    var id = this.getId();

    if (owner == this) {
        return owner.name;
    } else if (owner) {
        return owner.name + "." + id;
    } else {
        return id;
    }
    },
    */
    resetChildIds: function() {
    for(var i in this.components) {
        delete this.components[i].id;
        delete this.components[i].runtimeId;
        delete this.components[i].rootId;
        this.components[i].resetChildIds();
    }
    },

    // get the root object that owns this component and under which its id is qualified
    getRoot: function() {
        if (this.owner)
        return this.owner.getRoot();
        else
        return null;
    },
    // get the root portion of the runtime id
    getRootId: function() {
        if (!this.rootId || this.isDesignLoaded()) {
        var r = this.getRoot();
        r = r ? r.getRuntimeId() : "";
        this.rootId =  r ? r + (r.charAt(r.length-1) == "." ? "" : ".") : "";
        }
        return this.rootId;
    },
    /**
        Return a string that can globally identify a name
        as a child of this component.
        @param {String} inName The name to qualify.
        @returns {String} The qualified id string.
    */
    // make a globally unique runtime id
    getRuntimeId: function(inName) {
        if (!this.runtimeId || this.isDesignLoaded()) {
        this.runtimeId = this.getRootId() + this.getId();
        }
        var result =  (inName) ? this.runtimeId + "." + inName :  this.runtimeId;
        return result;
    },
/*
    getRuntimeId: function(inName) {
        if (this.cacheRuntimeId && this.cacheRuntimeId != '')
        {
            //usingCacheRuntimeId++;
            if (!inName || inName == '')
            {
                return this.cacheRuntimeId;
            }
            else
            {
                return this.cacheRuntimeId + '.' + inName;
            }
        }

        var r = this.getRootId() + this.getId(inName);
        return r;
    },
    */
    // get a value under root using an id
    getValueById: function(inId) {
        /* Not sure if there aren't times when we have a sort of valid ID of 0, "" or false... */
        if (inId === null || inId === undefined) return null;
        var r = this.getRoot();
        r = r && r.getValue(inId);
        var result;
        /* r._wmNull appears to not exist anywhere */
        if (r && r._wmNull) {
          return app.getValue(inId);
        }

        if (r !== undefined) return r;

        if (inId && wm.Component.byId[inId]) {
        return wm.Component.byId[inId];
        }


        // First part of the ID is the page name
        var index = inId.indexOf(".");
        if (index != -1) {
        var pageName = inId.substring(0,index);
        if (pageName.indexOf("[") == 0)
            pageName = pageName.substring(1,pageName.length-1);
        var remainder = inId.substring(index+1);
        var page = wm.Page.getPage(pageName);
        if (page) {
            return page.getValueById(remainder);
        }
        if (this._isDesignLoaded && wm.decapitalize(String(studio.bindDialog.bindSourceDialog.pageContainer.pageName)) == pageName) {
            page = studio.bindDialog.bindSourceDialog.pageContainer.page;
            if (page) {
            return page.getValueById(remainder);
            }
        }
        }

        return undefined;
    },
    /*
    LiveForm does not work with the impovement changes below.
        getValue: function(inName) {
                if (typeof inName != "string" || inName.indexOf(".") != -1)
                        return this.inherited(arguments);
                var s1 = "get" + wm.capitalize(inName);
                var s2 = "get_" + wm.capitalize(inName);
                if (this[s1])
                        return this[s1]();
                else if (this[s2])
                        return this[s2]();
                else
                        return this.inherited(arguments);
        },
        setValue: function(inName, inValue) {
                if (typeof inName != "string" || inName.indexOf(".") != -1)
                        return this.inherited(arguments);
                var s1 = "set" + wm.capitalize(inName);
                var s2 = "set_" + wm.capitalize(inName);
                if (this[s1])
                        return this[s1](inValue);
                else if (this[s2])
                        return this[s2](inValue);
                else
                        return this.inherited(arguments);

        },
    */

    //=======================================================
    // Utility
    //=======================================================
    connect: function() {
        var c = dojo.connect.apply(dojo, arguments);
        this._connections.push(c);
        return c;
    },
    connectOnce: function(sourceObj, sourceMethod, targetObj, targetMethod) {
    var connections = this._connections;
    var args = [sourceObj,sourceMethod];
    if (typeof targetObj == "function") {
        targetMethod = targetObj;
    } else {
        args.push(targetObj);
    }
    args.push(function() {
        dojo.disconnect(c);
        wm.Array.removeElement(connections, c);
        dojo.hitch(this, targetMethod)();
    });

    var c = dojo.connect.apply(dojo,args);

    connections.push(c);
    return c;
    },
    connectEvents: function(inObject, inEvents) {
        this._connections = this._connections.concat(wm.connectEvents(this, inObject, inEvents));
    },

    _disconnect: function(inNode, inEvents) {
        dojo.forEach(this._connections, dojo.disconnect);
        this._connections = [];
    },
    /* Only use this if you want to disconnect a single event from "this" because you plan to keep on using "this".
       If "this" is going to go away, then the destructor takes care of all disconnects */
    disconnectEvent: function(inEvent) {
      this._connections = dojo.filter(this._connections, function(item, index, array) {
        if (item[1] == inEvent) {
          dojo.disconnect(item);
          return false;
        } else
          return true;
        return item[1] != inEvent;
      });
    },
    disconnect: function(connectionObj) {
        dojo.disconnect(connectionObj);
        wm.Array.removeElement(this._connections, connectionObj);
    },
    findConnection: function(inEvent) {
        for (var i = 0; i < this._connections.length; i++) {
        var con = this._connections[i];
        if (con[1] == inEvent)
            return con;
        }
    },
        findSubscription: function(inEvent) {
        for (var i = 0; i < this._subscriptions.length; i++) {
        var con = this._subscriptions[i];
        if (con[0] == inEvent)
            return con;
        }
    },
    subscribe: function() {
            var s = dojo.subscribe.apply(dojo, arguments);
        this._subscriptions.push(s);
        if (djConfig.isDebug) {
        this._debugSubscriptions.push(arguments[0]);
        }
            return s;
    },
        unsubscribe: function(subname) {
            for (var i = this._subscriptions.length-1; i >= 0; i--) {
                if (this._subscriptions[i][0] == subname) {
                    dojo.unsubscribe(this._subscriptions[i]);
                    wm.Array.removeElementAt(this._subscriptions,i);
            if (djConfig.isDebug) {
            wm.Array.removeElementAt(this._debugSubscriptions,i);
            }
                }
            }
        },
    _unsubscribe: function() {
        dojo.forEach(this._subscriptions, dojo.unsubscribe);
        this._subscriptions = [];
            if (djConfig.isDebug) {
            this._debugSubscriptions = [];
        }
    },
    //=======================================================
    // Properties
    //=======================================================
    isEventProp: function(n) {
        if (!this._designee) return false;
        return dojo.isFunction(this._designee[n] || this._designee[n.replace(/\d+$/,"")]) && (n.slice(0,2)=="on");
    },
    isCustomMethodProp: function(n) {
        return dojo.isFunction(this.constructor.prototype[n]) && (n.slice(0,6)=="custom");
    },
    _getProp: function(n) {
        if (this.isEventProp(n))
            return this.eventBindings ? (this.eventBindings[n] || "") : "";
        // do we need this?
        var g = this._getPropWorker(this._designee, n, "get");
        if (g)
            return g.call(this, n);
        return n in this._designee ? this._designee[n] : this.components[n];
    },
    _setProp: function(n, v) {
        if (this.isEventProp(n) && this._isDesignLoaded) {
        this.setEvent(n, v);
        } else if (this.isCustomMethodProp(n) && this._isDesignLoaded) {
        if (v) {
            this._designee[n] = v;
            eventEdit(this, n, v, this.owner == studio.application);
        } else {
            delete this._designee[n];
        }
        } else {
            // do we need this?
            var s = this._getPropWorker(this._designee, n, "set");
            if (s)
                s.call(this, v);
            else
                this._designee[n] = v;
        }
    },
    //=======================================================
    // Values
    //=======================================================
    // id-based notification
    valueChanged: function(inProp, inValue) {
        //console.info('inProp "' + inProp + '" => this.getRootId(): ' + this.getRootId() + ' this.getId(inProp): ' + this.getId(inProp) + ' == '+ this.getRuntimeId(inProp));
        var evtId = this.getRuntimeId(inProp);
        if (evtId == '')
        {
            return;
        }

        //console.info('Event: ' + evtId);
        dojo.publish(evtId + "-changed", [inValue, this]);

        var root = this.getRoot();
        if (root) root = root.getRuntimeId();
        if (root && root.indexOf(".") && evtId.indexOf(root) == 0) {
           var n = evtId.substring(root.length);
        n = root.substring(root.lastIndexOf(".")+1) + n;
        if (n != evtId) {
            var topic = n + "-changed";
            wm.logging && console.group("<== ROOTCHANGED [", topic, "] published by Variable.dataRootChanged");
            dojo.publish(topic, [inValue, this]);
        }
       }

    },
    //=======================================================
    // Streaming In
    //=======================================================
    _create: function(ctor, props) {
        try
        {
          return new ctor(props);
        }
        catch(e)
        {
            console.debug("Component._create: ignoring unknown component type: ", ctor.prototype, props);
        }
        //throw ("Page._create: unknown component type: " + p);
    },
    adjustChildProps: function(inCtor, inProps) {
        dojo.mixin(inProps, {owner: this});
    },
    /**
        Create a component as a child of this component.
        @param inName {String} Name of the new component (may be altered to ensure uniqueness).
        @param inType {String} Type of component to create (note, a string, not a constructor).
        @param inProps {Object} Hash of properties to pass to the new components <a href="#constructor">constructor</a>.
        @param inEvents {Object} Name/value pairs that match events in the new component to functions in the owner.
        @param inChildren {Object} Name/value pairs that describe child components to create on this object.
        @param inOwner {Object} Optional. Override automatic value for "owner".
        @example
this.panel1.createComponent("custom", "wm.Panel", {
    // properties
    height: "3em",
}, {
    // events
    onclick: "click" // connect onclick event to owner's "click" function
}, {
    // children
    // name: [ "[type]", { [properties] }, { [events] }, { [children] } ]
    spacer1: [ "wm.Spacer", { width: "300px" } ],
    content: [ "wm.Label", { width: "1flex" } ],
    spacer2: [ "wm.Spacer", { width: "300px" } ]
});
    */
    createComponent: function(inName, inType, inProps, inEvents, inChildren, inOwner) {
           if (wm.debugPerformance) {
         if (inType == "wm.Layout") {
           if (dojo.isFF)
             console.groupCollapsed("CREATE " + inType + ": " + inName + " AT " + startTime);
           else
             console.group("CREATE " + inType + ": " + inName + " AT " + startTime);
         }
           this.startTimer("CreateComponent", inType);
           }


        var ctor = dojo.getObject(inType);
        if (!ctor)
        {
            //console.info('trying to get component from componentList');
            try
            {
                            /* wm.componentList accessed here */
                wm.getComponentStructure(inType);
                ctor = dojo.getObject(inType);
            }
            catch(e)
            {
                console.info('error while getComponentStructure: ' + e);
            }
        }

        if (!ctor) throw(wm.getDictionaryItem("wm.Component.CLASS_NOT_FOUND", {type: inType, name: inName}));
        var props = dojo.mixin({_designer: this._designer, _loading: true}, inProps);
        this.adjustChildProps(ctor, props);

        /* Special case where a Composite being designed opens a PageDialog at designtime where the PageDialog
         * is itself not being designed but is in fact a wizard
         */
        if (inProps._isDesignLoaded === false) delete props._designer;

        if (inOwner)
            props.owner = inOwner;
        //
        // FIXME: avoid unique names if owner root is loading...
        // fix to prevent extra components in application children
        // FIXME: or owner itself is loading (avoids copy/paste sub-components duplication)

        props.name = props.owner.getRoot()._loading || props.owner._loading ? inName : props.owner.getUniqueName(inName);

        // All custom methods should be page methods; page methods have not been evaled, so
        // can not be defined nor invoked at design time
        if (!this.isDesignLoaded()) {
        for (var p in props) {
            if (p.indexOf("custom") == 0 && dojo.isFunction(ctor.prototype[p])) {
            var owner = props.owner;
            props[p] = dojo.hitch(owner, owner[props[p]]);
            }
        }
        }

        //
        var w = this._create(ctor, props);
                if (w.name != inName && wm.pasting && window["studio"])
                    studio.renamedDuringPaste[inName] = w;

        try{
          if (inEvents && w.owner) {
            w.owner.makeEvents(inEvents, w);
          }
          if (inChildren) {
            w.createComponents(inChildren);
          }
        }
        catch(e){
            console.info('error while creating component: ', e);
        }
        finally{
            try {
            w.loaded();
            if (w.owner && w.owner[w.name] === undefined && !w._isDesignLoaded && !wm.isInstanceType(w, wm.Property)) {
                w.owner[w.name] = w;
            }
            } catch(e) {
            console.error("Error in postInit for " + w.toString() + ": " + e);
            }
        }

        if (wm.debugPerformance) this.stopTimerWithName("CreateComponent",inType,1);
        return w;
    },
    createComponents: function(inComponents, inOwner) {
        var result = [];
        for (var i in inComponents) {
            var c = inComponents[i];
            result.push(this.createComponent(i, c[0], c[1], c[2], c[3], inOwner));
        }
        return result;
    },
    _eventArgs: function(c, a) {
        var args = [ c ];
        for (var i=0,l=a.length; i<l; i++){args.push(a[i])};
        return args;
    },
    makeEvents: function(inEvents, inComponent) {
        var e, n, f;
        var eventsArray = [];
        for (n in inEvents) {
            eventsArray.push(n);
        }
        eventsArray.sort();
        for (var i = 0; i < eventsArray.length; i++) {
            var n = eventsArray[i];

            // name of the source
            f = inEvents[n];
            // the target
            e = this[f] || f;
            if (this._designer) {
                // if designing, it helps to have an actual function of the given name, which events ending in numbers
                // should not have
                if (n.match(/\d+$/) && !inComponent[n]) {
                    inComponent[n] = function(){};
                }
                // if designing, note the eventBinding
                wm.fire(inComponent, "setProp", [n, f]);
            } else {
                // otherwise, connect the named event
                this.connect(inComponent._eventSource||inComponent, n.replace(/\d*$/,""), this.makeEvent(e, f, inComponent, n.replace(/\d*$/,"")));
                // For most events, doing connections this way is a bad idea; many uses of
                // events are done from code rather than inEvents; however, for performance
                // reasons and because dynamically setting onRightClick is something I'm ok not
                // suporting, I've made an exception here.
                if (n.match(/^onRightClick\d*$/)) {

                    inComponent.connect(inComponent.domNode, "oncontextmenu", inComponent, function(event) {
                        dojo.stopEvent(event);
                        this.onRightClick(event);
                    });
                    if (dojo.isFF) { // FF 3.6/4.0 on OSX require this, others may as well
                        inComponent.connect(inComponent.domNode, "onmousedown", inComponent, function(event) {
                        if (event.button == 2 || event.ctrlKey) {
                            dojo.stopEvent(event);
                            this.onRightClick(event);
                        }
                        });
                    }

                } else if (n.match(/^onMouseOver\d*$/)) {
                    inComponent.createMouseOverConnect();
                } else if (n.match(/^onMouseOut\d*$/)) {
                    inComponent.createMouseOutConnect();
                } else if (n.match(/^onEnterKeyPress\d*$/) && inComponent instanceof wm.Container) {
                    inComponent.connectOnEnterKey();
                }
            }
        }
    },
    makeEvent: function(inHandler, inName, inComponent, eventName) {
        return dojo.isFunction(inHandler) ? this._makeEvent(inName,inComponent,eventName) : this._makeComponentEvent(inHandler,inComponent,eventName);
    },
    _makeEvent: function(inName, inComponent, eventName) {
        var self = this;
        return function jsEventHandler() {
            var args = arguments;
            var f = function() {
                    if (app.debugDialog && !inComponent.isAncestor(app.debugDialog)) {
                        var eventId = app.debugDialog.newLogEvent({
                            eventType: "javascriptEvent",
                            sourceDescription: (inComponent instanceof wm.Component ? inComponent.getRuntimeId() + "." : "") + eventName + "() has been called",
                            resultDescription: "Calling " + (self instanceof wm.Component ? self.getRuntimeId() + "." : "") + inName + "()",
                            firingId: inComponent instanceof wm.Component ? inComponent.getRuntimeId() : "",
                            affectedId: self.getRuntimeId(),
                            method: inName
                        });

                    }
                    try {
                        self[inName].apply(self, self._eventArgs(this, args));
                    } catch (e) {
                        if (e instanceof Error && e.message == "Abort" || e.toString() == "Abort") throw e;
                        var errorMessage = "Error in " + self.toString() + "." + inName + ": " + e.message;
                        if (djConfig.isDebug) {
                            app.toastError(errorMessage);
                        } else {
                            console.error(errorMessage);
                        }
                    }
                    if (eventId) app.debugDialog.endLogEvent(eventId);
                };

            /* Events should not be fired until the owner has finished loading, as the event may require components that aren't yet generated */
            if (inComponent && eventName && inComponent["_" + eventName + "BeforeStart"]) {
                dojo.hitch(this,f)();
            } else if (self instanceof wm.Page && self._loadingPage) {
                self.connectOnce(self, "start", this, f);
            } else if (self._loading) {
                self.connectOnce(self, "postInit", this, f);
            } else {
                dojo.hitch(this,f)();
            }

        }
    },
    _makeComponentEvent: function(inHandler, inComponent, eventName) {
        var self = this;
        // FIXME: experimental: can call a method on a component
        return function eventHandler(e, optionalTargetComp) {

            // inHandler could be a component
            // or a (string) Id of a component
            // or a (string) Id of a component + a dotted method suffix
            //console.info('inHandler ', inHandler, ' instanceof wm.Component = ' + (inHandler instanceof wm.Component));
            //console.info('wm.isInstanceType = ' + wm.isInstanceType(inHandler, 'wm.Component'));
            var args = arguments;
            var f = function() {
                    var c = wm.isInstanceType(inHandler, wm.Component) ? inHandler : self.getValueById(inHandler);
                    if (wm.isInstanceType(c, wm.Component)) {
                        if (app.debugDialog && !inComponent.isAncestor(app.debugDialog)) {
                            if (c instanceof wm.ServiceVariable) {
                                if (!c._debug) c._debug = {};
                                c._debug = {
                                    trigger: inComponent.getId(),
                                    eventName: eventName,
                                    method: "update",
                                    lastUpdate: new Date()
                                };
                            }
                            var eventId = app.debugDialog.newLogEvent({
                                eventType: "componentEvent",
                                sourceDescription: inComponent.getRuntimeId() + "." + eventName + "() has been called",
                                resultDescription: "Invoking " + c.getRuntimeId(),
                                eventName: eventName,
                                firingId: inComponent.getRuntimeId(),
                                affectedId: c.getRuntimeId(),
                                method: "update"
                            });
                        }
                        if (c.updateInternal) {
                            wm.fire(c, "updateInternal", [e, optionalTargetComp]);
                        } else {
                            wm.fire(c, "update", [e, optionalTargetComp]);
                        }
                        // call a method on a component
                    } else if (dojo.isString(inHandler)) {
                        var o = inHandler.split('.');
                        var m,c;
                        if (o.length > 1) {
                            m = o.pop();
                            c = self.getValueById(o.join("."));
                        } else {
                            c = self;
                            m = o[0];
                        }
                        if (c && c[m]) {
                            if (app.debugDialog && !inComponent.isAncestor(app.debugDialog)) {
                                if (c instanceof wm.ServiceVariable) {
                                    if (!c._debug) c._debug = {};
                                    c._debug = {
                                        trigger: inComponent.getId(),
                                        eventName: eventName,
                                        method: m,
                                        lastUpdate: new Date()
                                    };
                                }
                                var eventId = app.debugDialog.newLogEvent({
                                    eventType: "subcomponentEvent",
                                    sourceDescription: (inComponent instanceof wm.Component ? inComponent.getRuntimeId() + "." : "") + eventName + "() has been called",
                                    resultDescription: "Calling " + c.getRuntimeId() + "." + m + "()",
                                    firingId: inComponent instanceof wm.Component ? inComponent.getRuntimeId() : undefined,
                                    affectedId: c instanceof wm.Component ? c.getRuntimeId() : undefined,
                                    method: m
                                });
                            }
                            // changed from c[m]() so that inSender and all arguments get forwarded
                            try {
                                c[m].apply(c, self._eventArgs(this, args));
                            } catch (e) {
                                if (e instanceof Error && e.message == "Abort" || e.toString() == "Abort") throw e;
                                var errorMessage = "Error in " + self.toString() + "." + m + ": " + e.message;
                                if (djConfig.isDebug) {
                                    app.toastError(errorMessage);
                                } else {
                                    console.error(errorMessage);
                                }
                            }
                        }
                    }

                    if (eventId) app.debugDialog.endLogEvent(eventId);
                };

            /* Events should not be fired until the owner has finished loading, as the event may require components that aren't yet generated */
            if (self instanceof wm.Page && self._loadingPage) {
                self.connectOnce(self, "start", this, f);
            } else if (self._loading) {
                self.connectOnce(self, "postInit", this, f);
            } else {
                dojo.hitch(this,f)();
            }
        }
    },
    readComponents: function(inComponents) {
        var c = dojo.fromJson(inComponents);
        return this.createComponents(c);
    },
     startTimerWithName: function(timerName, componentName) {
      if (!wm.debugPerformance) return;
      if (!this.logTimesWithComponentNames) this.logTimesWithComponentNames = {};
      if (!this.logTimesWithComponentNames[componentName]) this.logTimesWithComponentNames[componentName] = {};
      this.logTimesWithComponentNames[componentName][timerName] = new Date().getTime();
     },
    stopTimerWithName: function(timerName, componentName) {
      if (!wm.debugPerformance) return;
      if (!this.logTimesWithComponentNames) this.logTimesWithComponentNames = {};
      if (!this.logTimesWithComponentNames[componentName]) this.logTimesWithComponentNames[componentName] = {};
      var startTime = this.logTimesWithComponentNames[componentName][timerName];
      if (!startTime) return -1;
      this.logTimesWithComponentNames[componentName][timerName] = 0;

      var result = new Date().getTime() - startTime;

        var timingObj = wm.Component.timingByComponent[componentName];
        if (!timingObj) {
        wm.Component.timingByComponent[componentName] = {};
        timingObj = wm.Component.timingByComponent[componentName];
        }
        if (!timingObj[timerName]) timingObj[timerName] = [];
        timingObj[timerName].push(result);

      return result;
    },
        subtractTimerWithName: function(timerName, componentName,time) {
      if (!wm.debugPerformance) return;
      if (!this.logTimesWithComponentNames) this.logTimesWithComponentNames = {};
      if (!this.logTimesWithComponentNames[componentName]) this.logTimesWithComponentNames[componentName] = {};
      var startTime = this.logTimesWithComponentNames[componentName][timerName];
      if (!startTime) return -1;
        var timingObj = wm.Component.timingByComponent[componentName];
        if (!timingObj) {
        wm.Component.timingByComponent[componentName] = {};
        timingObj = wm.Component.timingByComponent[componentName];
        }
        var tmp = timingObj[timereName];
        tmp[tmp.length-1] -= time;
    },
    startTimer: function(timerName) {
      if (!wm.debugPerformance) return;
      if (!this.logTimes) this.logTimes = {};
      this.logTimes[timerName] = new Date().getTime();
    },
    stopTimer: function(timerName, addToComponentLog) {
      if (!wm.debugPerformance) return;
      if (!this.logTimes) this.logTimes = {};
      var startTime = this.logTimes[timerName];
      if (!startTime) return -1;
      this.logTimes[timerName] = 0;
      var result = new Date().getTime() - startTime;

      if (addToComponentLog) {
        var timingObj = wm.Component.timingByComponent[this.declaredClass];
        if (!timingObj) {
          wm.Component.timingByComponent[this.declaredClass] = {};
          timingObj = wm.Component.timingByComponent[this.declaredClass];
        }
        if (!timingObj[timerName]) timingObj[timerName] = [];
        timingObj[timerName].push(result);
      }
      return result;
    }
});

//=======================================================
// Class Properties
//=======================================================
dojo.mixin(wm.Component, {
    //=======================================================
    // Component registry
    //=======================================================
    /** @lends wm.Component */
    byId: {},
    byShortId: {},
    timingByComponent: {},
    add: function(inComponent){
    if (inComponent._temporaryComponent) return;
    var rid = inComponent.getRuntimeId();
    wm.Component.byId[rid] = inComponent;
    },
    remove: function(inComponent){
    delete wm.Component.byId[inComponent.getRuntimeId()];
    },
    property: {
    }
});
}
//window.$$ = wm.Component.byId;

}

if(!dojo._hasResource["wm.base.Control"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.Control"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
/*global dojo, wm */
dojo.provide("wm.base.Control");
dojo.provide("wm.base.Widget");
wm.splitUnits = function(inUnitValue) {
    if (!dojo.isString(inUnitValue)) return {value: inUnitValue, units: "px"};
    var m = (inUnitValue || "").match(wm.splitUnits.Rx);
    return { value: Number(m[1]) || 0, units: m[2] || "px" };
}
wm.splitUnits.Rx = /(\d*)(.*)/;

/**
   Manages geometry for a rectangle, including margins, borders, and padding and frame-of-reference calculations.
   @class
   @name wm.Bounds
*/
dojo.declare("wm.Bounds", null, {
    /** @lends wm.Bounds.prototype */
    padding: "",
    border: "",
    margin: "",
    constructor: function() {
	this.bounds = {l:0, t:0, w:96, h:64};
	this.borderExtents = {l:0, t:0, r:0, b: 0};
	this.paddingExtents = {l:0, t:0, r:0, b: 0};
	this.marginExtents = {l:0, t:0, r:0, b: 0, w: 0, h:0};
	this.padBorderMargin = {};
	this.calcPadBorderMargin();
    },
    getBounds: function() {
	return this.bounds;
    },
    /**
       Set the outermost area of this box, including margin, border, and padding.
       l, t describe the position of the outer most corner of this box.
       w, h describe the size of the box, including margin, border, and padding.
       @param {Object} inBox {l: Number, t: Number, w: Number, h: Number }
    */
    setBounds: function(inL, inT, inW, inH) {
	if (arguments.length == 1) {
	    return this.setBounds(inL.l, inL.t, inL.w, inL.h)
	}

	var b = this.bounds;
	if (!isNaN(inL) && b.l != inL) {
	    b.l = inL;
	}
	if (!isNaN(inT) && b.t != inT) {
	    b.t = inT;
	}
	if (inW >= 0 && b.w != inW) {
	    b.w = inW;
	    this._boundsDirty = true;
	}
	if (inH >= 0 && b.h != inH) {
	    b.h = inH;
	    this._boundsDirty = true;
	}

	// If b.l, b.w, b.t or b.h is a string like "100", it should be changed to integer before adding.
	// To ensure that we multiple it by 1.
	b.r = b.l*1 + b.w*1;
	b.b = b.t*1 + b.h*1;
	return b;
    },
    setContentBounds: function(inBox) {
	var b= {};
	var sm = this.getScrollMargins();
	if ("w" in inBox) {
	    b.w = inBox.w + this.padBorderMargin.w + sm.w;
	}
	if ("h" in inBox) {
	    b.h = inBox.h + this.padBorderMargin.h + sm.h;
	}
	return this.setBounds(b);
    },
    _parseExtents: function(inExtents) {
	inExtents = String(inExtents);
	var r = {};
	if (typeof inExtents == "number")
	    r = { l: inExtents, t: inExtents, r: inExtents, b: inExtents };
	else {
	    var ex = inExtents.split(",");
	    var l = ex.length;
	    r.t = parseFloat(ex[0]) || 0;
	    r.r = l < 2 ? r.t : parseFloat(ex[1]) || 0;
	    r.b = l < 3 ? r.t : parseFloat(ex[2]) || 0;
	    r.l = l < 4 ? r.r : parseFloat(ex[3]) || 0;
	}
	return r;
    },
    _stringifyExtents: function(inExtents) {
        return inExtents.t + "," + inExtents.r + "," + inExtents.b + "," + inExtents.l;
    },
    /**
       Set padding extents in pixels.
       @param {String||Number} inPadding "t, <r, b, l>" || Number
    */
    setPadding: function(inPadding) {
	this.padding = String(inPadding);
	this.paddingExtents = this._parseExtents(this.padding);
	this.padBorderMarginChanged();
	this.invalidCss = true;
	this.render();
    },
    /**
       Set border extents in pixels.
       @param {String||Number} inBorder "t, <r, b, l>" || Number
    */
    setBorder: function(inBorder) {
	inBorder = String(inBorder);
	inBorder = (inBorder && inBorder.match(/\d/)) ? inBorder : "0";
	if (inBorder !== this.border) {
	    this.border = inBorder;
	    this.borderExtents = this._parseExtents(inBorder);
	    this.padBorderMarginChanged();
	    this.invalidCss = true;
	    this.render();
	}
    },
    /**
       Set margin extents in pixels.
       @param {String||Number} inMargin "t, <r, b, l>" || Number
    */
    setMargin: function(inMargin) {
	this.margin = String(inMargin);
	var me = this.marginExtents = this._parseExtents(this.margin);
	me.h = me.t + me.b;
	me.w = me.l + me.r;
	this.padBorderMarginChanged();
	this.invalidCss = true;
	this.render();
    },
    setOneMargin: function(inMargin,edge) {
        var m = this.marginExtents;
        m[edge] = inMargin;
        this.setMargin(this._stringifyExtents(m));
    },
    /**
       Update metrics when padBorderMargin has changed.
       @protected
    */
    padBorderMarginChanged: function() {
	this.calcPadBorderMargin();
    },
    /**
       Accumulate padBorderMargin extents.
       @private
    */
    _edges: {l:1, t:1, r:1, b:1},
    calcPadBorderMargin: function() {
		var pbm = this.padBorderMargin;
		for(var e in this._edges)
		    pbm[e] = this.borderExtents[e] + this.paddingExtents[e] + this.marginExtents[e];
		if (this._isDesignLoaded && studio.useDesignBorder && wm.isDesignable(this) && (!this.border || this.border === "0")) {pbm.t++;pbm.b++;pbm.r++;pbm.l++;}
		pbm.w = pbm.l + pbm.r;
		pbm.h = pbm.t + pbm.b;
    },
    getScrollMargins: function() {
	return {w:0, h:0};
    },
    /**
       Get an object describing the content-box area.
       l, t describe the position of the origin for objects in this frame.
       w, h describe the size of the content area of the box (inside margin, border, padding, and scrollbars).
       @return {Object} {l: Number, t: Number, w: Number, h: Number}
    */
    getContentBounds: function() {
	var sm = this.getScrollMargins();

	    var b = {
		l: this.paddingExtents.l,
		t: this.paddingExtents.t,
		w: Math.floor(this.bounds.w) - this.padBorderMargin.w - sm.w,
		h: Math.floor(this.bounds.h) - this.padBorderMargin.h - sm.h
	    };

 	if (b.w < 0) b.w = 0;
 	if (b.h < 0) b.h = 0;
	b.r = b.l + b.w;
	b.b = b.t + b.h;
	return b;
    },
    getStyleBounds: function() {
		if (this.isRelativePositioned){
		    return {w: this.width, h: this.height};
		}

		var pbm = (this.dom.node.tagName.toLowerCase() == "button") ? this.marginExtents : this.padBorderMargin;
		    var b = {
			l: this.bounds.l,
			t: this.bounds.t,
			w: this.bounds.w - pbm.w,
			h: this.bounds.h - pbm.h
		    };

	 	if (b.w < 0) b.w = 0;
	 	if (b.h < 0) b.h = 0;
		b.r = b.l + b.w;
		b.b = b.t + b.h;
		return b;
    },
    cloneBounds: function() {
	with (this.bounds) {
	    return {l:l, t:t, w:w, h:h, r:r, b:b};
	}
    }
});

dojo.declare("wm.DomNode", null, {
    constructor: function(inNode, isRelativePositioned) {
	this.node = inNode || document.createElement('div');
	this.isRelativePositioned = isRelativePositioned;
    },
    append: function(inDomNode) {
	this.node.appendChild(inDomNode.node);
    },
    remove: function(inDomNode) {
	this.node.removeChild(inDomNode.node);
    },
    getWidth: function() {
	return this.node.offsetWidth;
    },
    getHeight: function() {
	return this.node.offsetHeight;
    },
    setBox: function(inBox, inSingleLine) {
	var isChanged = false;
	var s = this.node.style;
	//		var style = {};
	if (this.isRelativePositioned){
	    s.width = inBox.w;
	    s.height = inBox.h;
	    return true;
	}

	var bl = inBox.l + "px";
	if (!isNaN(inBox.l) && s.left != bl) {
	    s.left = bl;
	    isChanged = true;
	}
	var bt = inBox.t + "px";
	if (!isNaN(inBox.t) && s.top != bt) {
	    s.top = bt;
	    isChanged = true;
	}
	var bw = inBox.w + "px";
	if (inBox.w >=0 && s.width != bw) {
	    s.width = bw;
	    isChanged = true;
	}
	var bh = inBox.h + "px";
	if (inBox.h >= 0) {
	    //if (s.height != bh)
	    s.height = bh;
	    s.lineHeight = inSingleLine ? bh : "normal";
	    isChanged = true;
	}

	//dojo.style(this.node, style);  proven to be very slow
	return isChanged;
    },
    setCssText: function(inText) {
	this.node.style.cssText += ";" + inText;
    },
    addCssText: function(inText) {
	this.node.style.cssText += inText;
    }
});

/* Appears to be obsolete
   wm.aligns = [
   "topLeft", "center", "bottomRight", "justified"
   ];*/

/**
   Base class for all <i>visual</i> components.
   @name wm.Control
   @class
   @extends wm.Component
*/
wm.define("wm.Control", [wm.Component, wm.Bounds], {
    /** @lends wm.Control.prototype */
    /*
      published: {
      invalidCss: {ignore: 1},
      renderedOnce: {ignore: 1},
      bounds: {ignore: 1},
      border: {group: "style", doc: 1},
      borderColor: {group: "style", doc: 1},
      //backgroundColor: {group: "style"},
      backgroundColor: {ignore: 1},
      margin: {group: "style", doc: 1},
      padding: {group: "style", doc: 1},
      autoScroll: {group: "scrolling", order: 100, ignore: 1, writeonly: 1},
      scrollX: {group: "scrolling", order: 101, ignore: 1, writeonly: 1},
      scrollY: {group: "scrolling", order: 102, ignore: 1, writeonly: 1},
      left: {writeonly: 1, ignore: 1},
      top: {writeonly: 1, ignore: 1}
      },
    */
    mobileFolding: false,
    mobileFoldingIndex: "",
    mobileFoldingCaption: "",

    imageList: "",
    imageIndex: -1,
    renderedOnce: 0,
    invalidCss: 1,
    autoScroll: false,
    backgroundColor: "",
    //border: 1,
    borderColor: "#F0F0F0",
    //binding: '(data binding)',
    classNames: '',
    id: '',
    autoSizeWidth: false,
    autoSizeHeight: false,
    _needsAutoSize: true,
    /*
      flex: '',
      left: '',
      top: '',
    */
    /**
       Display width specified as a string with units.<br>
       <br>
       Supports CSS units and <i>flex</i> units.<br>
       @example
       this.button.setValue("width", "96px");
       this.text.setValue("width", "4em");
       this.box.setValue("width", "1flex");
       @type String
    */
    width: '',
    /**
       Display height specified as a string with units.<br>
       <br>
       Supports CSS units and <i>flex</i> units.<br>
       @example
       this.button.setValue("height", "96px");
       this.text.setValue("height", "4em");
       this.box.setValue("height", "1flex");
       @type String
    */
    height: '',
    minHeight: 0, // number represents pixels
    minWidth: 0,
    minMobileHeight: 0,
    minDesktopHeight: 0,
    enableTouchHeight: false,
    //maxHeight: 0, // number represents pixels
    //maxWidth: 0,

    styles: '',
    /**
       Showing state.<br>
       <br>
       Whether the widget if shown on the display.<br>
       @see <a href="#hide">hide</a>, <a href="#show">show</a>.
       @example
       this.button.setValue("showing", false);
       this.panel.show();
       this.label.hide();
       @type Boolean
    */
    showing: true,
    /**
       Disabled state.<br>
       <br>
       Some widgets change behavior or display based on the disabled state.<br>
       @see <a href="#disable">disable</a>, <a href="#enable">enable</a>.
       @example
       this.button.setValue("disabled", true);
       this.panel.disable();
       this.label.enable();
       @type Boolean
    */
    disabled: false,
    _parentDisabled: false,
    _disabled: false, // combines disabled and _parentDisabled
    container: false,
    _classes: {domNode:[]}, // prototype gets a blank object for us to clone; allows theme to provide default classes
    scrollX: false,
    scrollY: false,

    //===========================================================================
    // Construction
    //===========================================================================
    constructor: function() {
    	this.widgets = {};
    	this._classes = dojo.clone(this._classes);
    },


    // experimental code for supporting dojo.parser
    // TODO:
    // 1. Need a way to find the parent widget (owner[node.parentNode.id]) should work, though we may need to parse "id" to strip out any owner ids
    // 2. Need a way to find the owner component (Page.js will need to set a global app._currentParseOwner before calling dojo.parser; and then restoring the prior value when its done in case Page.js is loading a pagecontainer)
    // 3. Need a way to invoke postInit; probably will need Page.js to do a second traversal after all widgets are created calling postInit on each widget
    markupFactory: function(params, node) {
        var ctor = arguments.callee.arguments[2];
        var domNode = node;
        var owner = wm._dojoParserCurrentOwner;
        var parentid = node.parentNode.id;
        while (parentid.indexOf("_") != -1 && !owner[parentid])
        parentid = parentid.substring(parentid.indexOf("_") + 1);
        var parent = owner[parentid];
        params = dojo.mixin(params, {
            domNode: domNode,
            parentNode: domNode.parentNode,
            parent: parent,
            name: owner.getUniqueName(params.name),
            owner: owner,
            _designer: owner._designer,
            _loading: false
        }); // should be changing this to true... but need to do something about calling postInit in a second pass before we change this
        var result = new ctor(params);
        if (!params.parent && ctor.prototype.declaredClass == "wm.Layout") result.owner.root = result;
        return result;
    },
    prepare: function(inProps) {
        try {
            if (inProps) {
                var owner = inProps.owner;
                if (!owner && parent) {
                    owner = inProps.owner = parent.owner;
                }
                if (owner) owner = owner.getOwnerApp();
                if (owner) owner.loadThemePrototypeForClass(this.constructor, this);
            }
        } catch (e) {
            console.error("What the hell?" + e);
        }
        this.inherited(arguments);
    },
    postscript: function(inProps) {
        this.inherited(arguments);
    },
    create: function() {
        this._cupdating = true;
        this.inherited(arguments);
    },
    build: function() {
        this.domNode = dojo.byId(this.domNode || /*this.id||*/ undefined);
        if (!this.domNode) this.domNode = document.createElement('div');
    },
    initDomNode: function() {
        if (!this.dom) {
            this.dom = new wm.DomNode(this.domNode, this.isRelativePositioned);
            if (!this.isRelativePositioned) this.domNode.style.position = "absolute";
            else this.domNode.style.position = "relative";
            this.setParent(this.parent);
            this.setDomNode(this.domNode);
        }
    },
    init: function() {

        this.initDomNode();
        this.inherited(arguments);
        if (this.ariaRole) dojo.attr(this.domNode, "role", this.ariaRole);

        var isMobile = wm.isMobile || this._isDesignLoaded && studio.currentDeviceType != "desktop";
        if (this.height && String(this.height).match(/\%/)) {
            this.mobileHeight = this.desktopHeight = this.height;
        } else if (!isMobile || !this.enableTouchHeight) {
            if (this.desktopHeight != null) {
                this.height = this.desktopHeight;
            } else if (this.height) {
                this.desktopHeight = this.height;
            } else {
                this.height = this.desktopHeight = this.constructor.prototype.height;
            }
            if (this.minDesktopHeight) {
                this.minHeight = this.minDesktopHeight;
            } else if (this.minHeight) {
                this.minDesktopHeight = this.minHeight;
            } else {
                this.minHeight = this.minDesktopHeight = this.constructor.prototype.minHeight;
            }

        } else {
            if (this._isDesignLoaded && studio.currentDeviceType == "desktop" || this.desktopHeight == undefined) {
                this.desktopHeight = this.height || this.mobileHeight;
            }
            if (this.desktopHeight && typeof this.desktopHeight == "string" && this.desktopHeight.match(/\%/)) {
                this.height = this.mobileHeight = this.desktopHeight;
            } else if (this.mobileHeight) {
                this.height = this.mobileHeight;
            } else if (this.height) {
                this.mobileHeight = this.height;
            } else {
                this.height = this.mobileHeight = this.constructor.prototype.height;
            }
            if (this.minMobileHeight) {
                this.minHeight = this.minMobileHeight;
            } else {
                this.minHeight = this.minMobileHeight = this.constructor.prototype.minHeight;
            }
        }

        //if (() && (!this.owner || this.owner.enableTouchHeight) && this.mobileHeight != undefined && !this.height.match(/\%/) && parseInt(this.mobileHeight) > parseInt(this.height)) this.height = this.mobileHeight;
        this.bc(); // mostly in here to support wm.Container's bc method
        //
        /*
      this.setBorder(this.border);
      this.setMargin(this.margin);
      this.setPadding(this.padding);
    */
        if (this.isDesignLoaded())
        // enable design borders
        this.set_border((this.border) ? String(this.border) : "0");
        else {
            this.border = (this.border) ? String(this.border) : "0";
        }
        this.borderExtents = this._parseExtents(this.border);

        this.padding = String(this.padding);
        this.paddingExtents = this._parseExtents(this.padding);
        this.setMargin(String(this.margin));
        this.doSetSizeBc();
        if (!this.showing) this.setShowing(false, true);

        this._parentDisabled = this.parent ? this.parent.disabled || this.parent._parentDisabled : false;
        this.setDisabled(this.disabled);

        this.appendDOMNode(this.parent);
        this.updateBounds();
    },

    bc: function() {
	// oboslete method; but the version in wm.Container is still required for framework to function
    },

    postInit: function() {
        this._cupdating = false;
        this.inherited(arguments);

        // After we've finished creating the widget, NOW we render() -- just once; not over and over while we're setting borders and
        // margins and everything else.
        this.render(1);


        if (this.addTouchListener && wm.isMobile && !window["studio"]) {
            //this.connect(this._touchNode || this.domNode, wm.isFakeMobile ? "mousedown" : "touchstart", this, "_onTouchStart");
            this.addTouchListener(this._touchNode || this.domNode);
        }

        if (!this.$.binding && this.isDesignLoaded()) {
            new wm.Binding({
                name: "binding",
                owner: this
            });
        }
        if (this.hint) {
            this.setHint(this.hint);
        }
    },


    destroy: function() {
        if (this.isDestroyed || this._isDestroying) return;
        this._isDestroying = true;

        try {
            if (app.toolTipDialog && this == app.toolTipDialog.tipOwner) {
                app.toolTipDialog.hide();
            }

            if (this._layerConnections) delete this._layerConnections;

            if (this.widgets) {
                var wids = [];
                wm.forEachProperty(this.widgets, function(w, name) {
                    wids.push(w);
                });
                for (var i = 0, w;
                (w = wids[i]); i++)
                w.destroy();
                wids = [];
            }

            this.widgets = null;
            this.parentNode = null
            this.setParent(null);
            wm.fire(this.designWrapper, "destroy");
            this.layout = null;
            this.inherited(arguments);
        } catch (e) {
            console.info('Error while destroying : ' + this.name, e);
        } finally {
            if (this.domNode) dojo.destroy(this.domNode);
            this.domNode = null;
            this._designee = null;
            if (this.dom && this.dom.node) {
                dojo.destroy(this.dom.node);
                this.dom.node = null;
                this.dom = null;
            }

        }
    },
    loaded: function() {
        this.inherited(arguments);
        this.initUserClasses();
    },
    setDomNode: function(inDomNode) {
        var n = this.domNode = inDomNode;
        if (dojo.isIE <= 8) {
            // forcing a size on the node now seems to help IE
            // honor auto sizing later
            n.style.width = "0px";
        }
        // id
        this.updateId();
        // classes

	var cNames = this.classNames + (this.owner ? ' ' + (this.owner._appendCssClassName || this.owner.declaredClass.replace(/\./g, "")) + '-' + this.name : '') + (this.isRelativePositioned && this.parent && this.parent.layoutKind == 'left-to-right' ? ' wmInlineDiv' : '');
        dojo.addClass(n, cNames);
        this.initUserClasses();
        //this.updateBounds();
    },


    isAncestorHiddenLayer: function() {
        if (this instanceof wm.Layout && this.owner == app._page) return false;
        if (this instanceof wm.Layer && this.parent instanceof wm.Layers && this.parent.getActiveLayer() != this) return true;
        var parent;
        if (this.parent && this.parent instanceof wm.Control) parent = this.parent;
        else if (this.owner instanceof wm.Page && this.owner.owner instanceof wm.Control) parent = this.owner.owner;
        if (!parent) return false;
        return parent.isAncestorHiddenLayer();
    },
    isAncestorHidden: function() {
        if (!this.showing && this instanceof wm.Layer == false) return true;
        if (this instanceof wm.Layout && this.owner == app._page || this instanceof wm.Dialog) return false;
        if (this instanceof wm.Layer && !this.active) return true;
        var parent;
        if (this.parent && this.parent instanceof wm.Control) parent = this.parent;
        else if (this.owner instanceof wm.Page && this.owner.owner instanceof wm.Control) parent = this.owner.owner;
        if (!parent) return false;
        return parent.isAncestorHidden();
    },

    callOnShowParent: function() {
    	if (this.owner && this.owner._isUnloading) return;
        var self = this;
        wm.forEachVisibleWidget(this, function(w) {
            if (self != w) { /* For internal widget detection of changes to showing state, use _onShowParent */
                if (w._onShowParent) {
                    w._onShowParent();
                }

                /* For public tooled detection use onShow; only call onShow if its been replaced with something other than
                 * the default empty onShow event handler because we can't be making 1000s of empty onShow calls
                 */
                if (w.onShow && w.onShow != w.constructor.prototype.onShow) {
                    w.onShow();
                }

            }
        }, true);
    },
    callOnHideParent: function() {
        var self = this;
        if (!this.isDestroyed) {
            wm.forEachVisibleWidget(this, function(w) {
                if (w.hint && app.toolTipDialog && app.toolTipDialog.tipOwner == self) app.hideToolTip();
                if (self != w) { /* For internal widget detection of changes to hideing state, use _onHideParent */
                    if (w._onHideParent) {
                        w._onHideParent();
                    }

                    /* For public tooled detection use onHide; only call onHide if its been replaced with something other than
                     * the default empty onHide event handler because we can't be making 1000s of empty onHide calls
                     */
                    if (w.onHide && w.onHide != w.constructor.prototype.onHide) {
                        w.onHide();
                    }


                }
            }, true);
        }
    },
    onShow: function(){},
    onHide: function(){},


    // OPTIONAL: Maybe handle all parents showing/hiding but thats a lot of connections
    //           and it may be better to just tell people not to show/hide parents of widgets needing these; just use layers
    // NOTE: Also handles dialogs if "this" is in a dialog; these connections to layers are more about knowing when its hidden/showing
    // and less about the details of whether its a layer or something else.
    // TODO: Verify if this is needed, or if _onShowParent makes this no longer necessary.
    connectToAllLayers: function(obj, callback) {
        var layers = [];
        var dialogs = []; // should only be 0 or 1 dialogs, but arrays work nicely no matter how many elements
        var parentObj = this;
        while (parentObj && (!app._page || parentObj != app._page.root)) {
            if (parentObj instanceof wm.Layer) layers.push(parentObj);
            else if (parentObj instanceof wm.Dialog) dialogs.push(parentObj);
            if (parentObj.parent) parentObj = parentObj.parent;
            else if (parentObj.owner instanceof wm.Page && parentObj.owner.owner instanceof wm.Control) parentObj = parentObj.owner.owner;
            else parentObj = null;
        }

        var f = dojo.hitch(obj, callback);
        this._layerConnections = [];
        dojo.forEach(layers, dojo.hitch(this, function(l) {
            this._layerConnections.push(this.connect(l, "onShow", this, function() {
                if (dojo.every(layers, function(l2) {
                    return l2.isActive();
                }) && dojo.every(dialogs, function(l2) {
                    return l2.showing;
                })) {
                    f();
                }
            }));
        }));

        dojo.forEach(dialogs, dojo.hitch(this, function(d) {
            this._layerConnections.push(this.connect(d, "setShowing", this, function() {
                if (d.showing && !d._transitionToHiding) { // transition handles case where showing is true, but animation is running that will have it hidden very soon
                    if (dojo.every(layers, function(l2) {
                        return l2.isActive();
                    }) && dojo.every(dialogs, function(l2) {
                        return l2.showing;
                    })) {
                        f();
                    }
                }
            }));
        }));

    },
    disconnectFromAllLayers: function() {
        dojo.forEach(this._layerConnections, dojo.hitch(this, function(c) {
            dojo.disconnect(c);
            this._connections = wm.Array.removeElement(this._connections, c);
        }));
        delete this._layerConnections;
    },
    isAncestor: function(inParent) {
        var o = this.parent;
        while (o && o != inParent) {
            o = o.parent;
        }
        return (o == inParent);
    },

    //===========================================================================
    // Name & Id
    //===========================================================================
    updateId: function() {
        this.inherited(arguments);
        if (this.domNode) {
            var rid = this.getRuntimeId();
            this.domNode.rid = rid;
            this.domNode.id = rid.replace(/\./g, "_");
        }
    },
    //===========================================================================
    // Ownership
    //===========================================================================
    getUniqueName: function(inName) {
        return wm.findUniqueName(inName, [this, this.components, this.widgets]);
    },
    //===========================================================================
    // Parentage
    //===========================================================================
    setName: function(inName) {
        if (!inName) return;
        if (this.parent) this.parent.removeWidget(this);
        this.addRemoveDefaultCssClass(false);
        this.inherited(arguments);
        if (this.parent) this.parent.addWidget(this);
        this.addRemoveDefaultCssClass(true);
    },
    addWidget: function(inWidget) {
        this.widgets[inWidget.name] = inWidget;
        var p = this.containerNode || this.domNode;
        if (inWidget.domNode.parentNode != p) {
            p.appendChild(inWidget.domNode);
        }
    },
    /* NOTE: I don't see this called anywhere */
    insertDomNodes: function() {
        wm.forEachProperty(this.widgets, function(w, name) {
            w.insertDomNodes();
        });

        var parentPage = this.getParentPage();
        try {
            var a = 1;
            if ((!parentPage || parentPage._disableRendering) && this.invalidCss) {
                this.renderCss();
                this.invalidCss = false;
            }

            var p = this.containerNode || this.parentNode || this.parent.domNode;
            if (this.domNode.parentNode != p && this.domNode.parentNode != window.document.body) {
                p.appendChild(this.domNode);
            }
        } catch (e) {
            console.log("ERROR INSERTING DOM NODES FOR " + this.name);
        }
        //  }
    },
    leafFirstRenderCss: function() {
        wm.forEachProperty(this.widgets, function(w, name) {
            w.leafFirstRenderCss();
        });
        if (this.invalidCss) {
            this.render(1);
        }
    },
    removeWidget: function(inWidget) {
        if (this.widgets) delete this.widgets[inWidget.name];
    },
    adjustChildProps: function(inCtor, inProps) {
        if (wm.isClassInstanceType(inCtor, wm.Control))
        // assignChildrenToOwner allows a widget to be owned by a container, the container is owned by the page, and that widget's children are also owned by the page
        dojo.mixin(inProps, {
            owner: this._assignChildrenToOwner || this.owner,
            parent: this
        });
        else this.inherited(arguments);
    },


    //===========================================================================
    // Bounds
    //===========================================================================
    // BC -->
    doSetSizeBc: function() {
        /*if (!this.width) {
      this.setSizeProp("width", "100%");
      }
      if (!this.height) {
      this.setSizeProp("height", "100%");
      }*/
        if (this.sizeUnits == "flex") {
            this.setFlex(this.size);
        } else if (this.sizeUnits) {
            var b = this.getParentBox(),
                p = {
                    v: "height",
                    h: "width"
                }[b];
            this.setSizeProp(p, this.size + this.sizeUnits);
        } else if (this.flex) {
            this.setFlex(this.flex);
        }
    },
    setFlex: function(inFlex) {
        var box = this.getParentBox();
        if (box) {
            var ex = {
                h: "width",
                v: "height"
            }[box];
            this.setSizeProp(ex, inFlex * 100 + "%");
            this._boundsDirty = true;
        } else {
            this.setSizeProp("width", inFlex * 100 + "%");
            this.setSizeProp("height", inFlex * 100 + "%");
        }
    },
    /* mkantor: Commented out 4/14/2010; presumed WM 4.x only
       isFlex: function() {
       var box = this.getParentBox();
       if (!box)
       return false;
       var ex = {h: "width", v: "height"}[box];
       return (this[ex].indexOf("flex")>=0);
       },
    */
    // <-- BC
    getScrollMargins: function() {
        if (wm.isMobile) {
            return {
                w: (this.scrollY || this._xscrollY) ? 2 : 0,
                h: (this.scrollX || this._xscrollX) ? 2 : 0
            };
        } else {
            return {
                w: (this.scrollY || this._xscrollY) ? 17 : 0,
                h: (this.scrollX || this._xscrollX) ? 17 : 0
            };
        }
        /*
      if (!this.autoScroll) {
      return {w: (this.scrollY) ? 17 : 0, h: (this.scrollX) ? 17 : 0};
      } else {
      return {w: (this._xscrollY || this.domNode.style.overflow == "auto") ? 17 : 0, h: (this._xscrollX || this.domNode.style.overflow == "auto") ? 17 : 0};
      }
    */
    },
    isReflowEnabled: function() {
        if (this._cupdating) return false;
        if (this.owner) {
            if (wm.isInstanceType(this.owner, wm.Control)) return this.owner.isReflowEnabled();
            else {
                return !this.owner._loadingPage;
            }
        }
        return true;
    },
    padBorderMarginChanged: function() {
        this.inherited(arguments);

        if (!this._doingAutoSize) this._needsAutoSize = true;

        if (this.isReflowEnabled()) {
            if (this.parent) this.parent.reflow();
            else {
                this.render();
                wm.fire(this, "flow");
            }
        }
    },
    /**
       Update width and height properties after bounds change.
    */
    boundsResized: function() {
        var box = dojo.marginBox(this.dom.node);
        if (this.bounds.w != box.w) {
            this.width = this.bounds.w + "px";
        }
        if (this.bounds.h != box.h) {
            this.height = this.bounds.h + "px";
        }
        this.updateBounds();
    },
    /**
       Update bounds and flex properties based on width/height properties
    */
    updateBounds: function() {
        //this.domNode.flex = 0;
        //this.fluidSize = 0;
        this._percEx = {
            w: 0,
            h: 0
        };
        //
        //var pd = this.getParentBox();
        //
        var su = wm.splitUnits(this.width);
        var w = su.value;
        switch (su.units) {
            // FIXME: 'flex' and 'em' are deprecated, probably this should be in BC block
        case "flex":
            w *= 100;
            this._percEx.w = w;
            this.width = w + "%";
            w = NaN;
            break;
        case "em":
            w *= 18;
            this.width = w + "px";
            break;
        case "%":
            this._percEx.w = w;
            w = NaN;
            break;
        }
        //
        su = wm.splitUnits(this.height);
        var h = su.value;
        switch (su.units) {
            // FIXME: 'flex' and 'em' are deprecated, probably this should be in BC block
        case "flex":
            h *= 100;
            this._percEx.h = h;
            this.height = h + "%";
            h = NaN;
            break;
        case "em":
            h *= h * 18;
            this.height = h + "px";
            break;
        case "%":
            this._percEx.h = h;
            h = NaN;
            break;
        }

        this.setBounds(NaN, NaN, w, h);
        //this.setBounds(this.left, this.top, w, h);
    },
    // return the 'box' setting of our parentNode
    getParentBox: function() {
        var n = (this.domNode || 0).parentNode;
        return n && (n.box || (n.getAttribute && n.getAttribute("box"))) || (this.parent || 0).box || '';
    },

    adjustSetSizeProp: function(n, v) {
        return v;
    },
    setSizeProp: function(n, v, inMinSize) {
        // We either have a minSize passed in from user set properties, or we let the widget itself decide what its minimum size should be.
        var minName = "min" + wm.capitalize(n);
        var getMin = "getMin" + wm.capitalize(n) + "Prop";
        var minSize = !wm.isMobile && inMinSize || this[getMin]();

        v = this.adjustSetSizeProp(n, v);

        if (this[n] == v && this[minName] == inMinSize) {
            if (v.match(/px/) && parseInt(v) != this.bounds[(n == "height") ? "h" : "w"]) {;
            } else {
                return;
            }
        }

        this[n] = v;
        this[minName] = inMinSize;

        // If widget suppports resizing, and isn't in the middle of doing an autoSize, then it now needs to be autoResized as its width or height have changed
        if (!this._doingAutoSize) {
            this._needsAutoSize = true;

            // A setSize call that is not made while doing autoSize means we are no longer an autosize widget
            if (this.autoSizeHeight && n == "height") this.autoSizeHeight = false;
            if (this.autoSizeWidth && n == "width") this.autoSizeWidth = false;
        }

        // MK: One line fix added Feb 18 2010:
        // Because the domNode of the designWrapper is not getting updated, we need to set invalidCss to true.  May prove unnecessary.
        if (this.designWrapper) this.designWrapper.invalidCss = true;

        if (!this._loading) this.updateBounds();
        if (this.isReflowEnabled() && this.showing) {
            this.reflowParent();
            if (this._isDesignLoaded && this.parent instanceof wm.Container) {
                var parent = this.parent
                wm.job(parent.getRuntimeId() + ".designResize", 50, function() {
                    parent.designResizeForNewChild();
                });
            }
        }
    },
    setWidth: function(inWidth) {
        this.setSizeProp("width", inWidth, this.minWidth);
    },
    setHeight: function(inHeight) {
        this.setSizeProp("height", inHeight, this.minHeight);
    },
    setMinWidth: function(inMinWidth) {
        inMinWidth = (inMinWidth) ? parseInt(inMinWidth) : 0;
        /*
    if (inMinWidth > this.bounds.w) {
        this.width = inMinWidth + "px";
    }
    */
        this.setSizeProp("width", this.width, inMinWidth);
    },
    setMinHeight: function(inMinHeight) {
        inMinHeight = (inMinHeight) ? parseInt(inMinHeight) : 0;
        /*
    if (inMinHeight > this.bounds.h) {
        this.height = inMinHeight + "px";
    }
    */
        this.setSizeProp("height", this.height, inMinHeight);
    },

    // this method is related to set/getMinWidth/Height, but whereas set/getMinWidth/Height are basic setters/getters of the minWidth/minHeight property,
    // these methods are designed to allow each object to calculate at runtime what its preferred minimum is... unless one has been specified by the user.
    // NOTE: minWidth/minHeight are ignored if size is set in px instead of %.  minHeight/minWidth may also kick in for fitToContent containers.
    getMinWidthProp: function() {
        return parseInt(this.minWidth) || 30;
    },
    getMinHeightProp: function() {
        return parseInt(this.minHeight) || 15;
    },
    /*
      setMaxWidth: function(inMaxWidth) {
      inMaxWidth = parseInt(inMaxWidth) || 0;
      this.setSizeProp("width", this.width, this.minWidth, inMaxWidth);
      },
    */
    setMaxHeight: function(inMaxHeight) {
        inMaxHeight = parseInt(inMaxHeight) || 0;
        this.maxHeight = inMaxHeight;
        if (inMaxHeight > this.bounds.h) this.reflowParent();
    },


    getDomHeight: function() {
        return dojo.coords(this.domNode, false).h;
    },

    // Returns integer value in pixels
    getDomWidth: function() {
        return dojo.coords(this.domNode, false).w;
    },

    /* This should work, but risks the UI being rather jumpy, so best to provide custom method for each widget where possible */
    doAutoSize: function(setSize, force) {
        if (this._doingAutoSize || !this.autoSizeHeight && !this.autoSizeWidth) return;
        if (!force && !this._needsAutoSize) return;

        if (this.isAncestorHidden()) {
            return;
        }


        this._doingAutoSize = true;
        this._needsAutoSize = false;

        if (this.autoSizeWidth) {
            this.domNode.style.width = "";
            var neww = dojo.coords(this.domNode).w;
            if (this.minWidth && this.minWidth > neww) neww = this.minWidth;
            if (setSize) {
                this.setWidth(neww + "px");
            } else {
                this.bounds.w = neww;
                this.domNode.style.width = neww + "px";
            }
        }

        if (this.autoSizeHeight) {
            this.domNode.style.height = "";
            var newh = dojo.coords(this.domNode).h;
            if (this.minHeight && this.minHeight > neww) newh = this.minHeight;
            if (setSize) {
                this.setHeight(newh + "px");
            } else {
                this.bounds.h = newh;
                this.domNode.style.height = newh + "px";
            }
        }
        if (this.isDesignLoaded() && studio.designer.selected == this) setTimeout(dojo.hitch(studio.inspector, "reinspect"), 100);
        this._doingAutoSize = false;
    },

    setAutoSizeWidth: function(inAutoSize) {
        this.autoSizeWidth = inAutoSize;
        if (this.autoSizeWidth) {
            if (this._percEx.w) {
                this.width = this.bounds.w + "px";
                this._percEx.w = 0;
            }
            this.doAutoSize(1, 1);
        }
    },
    setAutoSizeHeight: function(inAutoSize) {
        this.autoSizeHeight = inAutoSize;
        if (this.autoSizeHeight) {
            if (this._percEx.h) {
                this.height = this.bounds.h + "px";
                this._percEx.h = 0;
            }
            this.doAutoSize(1, 1);
        }
    },

    // If its chrome, overflow needs to be turned off, then on again for autoScrolling to be enabled but for the scrollbars to be hidden.
    // Insure that only one onidle is queued per node.
    // appears to be fixed in chrome 11
    disruptChromeOverflow: function(propName) {},
    //===========================================================================
    // Rendering; forceRender is a way to skip the isReflowEnabled test
    //===========================================================================
    render: function(forceRender) {
        if (forceRender || this.isReflowEnabled()) {
            this.renderCss();
        } else {
            this.invalidCss = true;
        }
        return true;
    },

    renderCss: function() {
        if (!this.invalidCss) return;
        this.invalidCss = false;

        // these should be called only once per object
        var cssObj = this.buildCssSetterObj();
        // some browsers are faster to set via cssText... but its NOT faster to reset them via cssText using our method of appending to the css string after an initial set of values have been stored.
        if (!this.renderedOnce && (dojo.isFF || dojo.isSafari || dojo.isChrome)) {
            this.setCssViaCssText(cssObj);
            this.renderedOnce = 1;
        } else {
            this.setCssViaDom(cssObj);
        }

        // handles special case where a call to render bounds neesd to call render which calls renderCss which should NOT
        // then call renderBounds again.
        if (!this.noRenderBounds) this.renderBounds();
    },
    buildCssSetterObj: function() {
        if (!this._appliedStyles) {
            this._appliedStyles = {};
        }

        var marginSplitter = this.getCssSplitter(this.margin);
        var paddingSplitter = this.getCssSplitter(this.padding);
        var borderSplitter = this.getCssSplitter(this.border);


        if (this.margin.indexOf(",") == -1 && this.margin.indexOf(" ") != -1) {
            marginSplitter = " ";
        }

        var paddArr = this.padding.split(paddingSplitter);
        var overflow = ((this.autoScroll || this._xscrollX || this._xscrollY) && (!wm.isFakeMobile || this instanceof wm.Container == false) ? "auto" : "hidden");
        var stylesObj;

        var margins = (this.margin || "0").split(marginSplitter);
        var borders = (this.border || "0").split(borderSplitter);
        var paddings = (this.padding || "0").split(paddingSplitter);


        if (margins.length == 1) {
            margins[1] = margins[2] = margins[3] = margins[0];
        } else if (margins.length == 2) {
            margins[2] = margins[0];
            margins[3] = margins[1];
        }

        if (borders.length == 1) {
            borders[1] = borders[2] = borders[3] = borders[0];
        } else if (borders.length == 2) {
            borders[2] = borders[0];
            borders[3] = borders[1];
        }

        if (paddings.length == 1) {
            paddings[1] = paddings[2] = paddings[3] = paddings[0];
        } else if (paddings.length == 2) {
            paddings[2] = paddings[0];
            paddings[3] = paddings[1];
        }
        /* When the user zooms the browser, border, margin and padding get mucked up, and ruin all of our calculations.
         * Use the ratio in _currentZoomLevel to alter padding/margin/border so that they result in the desired number of pixels.
         * Widths of 10px are NOT altered.  Calculations break down for zoomLevel > 1.4.  High enough zoom level and browsers
         * stop mucking with pixels
         */
        if (app._currentZoomLevel && app._currentZoomLevel > 1 && app._currentZoomLevel < 1.4) {
            for (var i = 0; i < margins.length; i++) {
                if (margins[i] % 10) {
                    margins[i] *= app._currentZoomLevel;
                }
            }
            for (var i = 0; i < paddings.length; i++) {
                if (paddings[i] % 10) {
                    paddings[i] *= app._currentZoomLevel;
                }
            }
            for (var i = 0; i < borders.length; i++) {
                if (borders[i] % 10) {
                    borders[i] *= app._currentZoomLevel;
                }
            }
        }


        if (this.designBorderState) {
            stylesObj = {
                margin: (margins.join("px ") || 0) + "px",
                padding: (paddings.join("px ") || 0) + "px",
                backgroundColor: this.backgroundColor,

                overflowX: this.scrollX ? "auto" : overflow,
                overflowY: this.scrollY ? "auto" : overflow
            };
            var bordersWidth = "", bordersStyle = "", bordersColor = "";
            if (this.designBorderState.t) {
            	bordersWidth += "1px ";
            	bordersStyle += "dashed ";
            	bordersColor += "#C1C1C1 ";
            } else {
            	bordersWidth += this.borderExtents.t + "px ";
            	bordersStyle += "solid ";
            	bordersColor += this.borderColor + " ";
            }
            if (this.designBorderState.r) {
            	bordersWidth += "1px ";
            	bordersStyle += "dashed ";
            	bordersColor += "#C1C1C1 ";
            } else {
            	bordersWidth += this.borderExtents.r + "px ";
            	bordersStyle += "solid ";
            	bordersColor += this.borderColor + " ";
            }
            if (this.designBorderState.b) {
            	bordersWidth += "1px ";
            	bordersStyle += "dashed ";
            	bordersColor += "#C1C1C1 ";
            } else {
            	bordersWidth += this.borderExtents.b + "px ";
            	bordersStyle += "solid ";
            	bordersColor += this.borderColor + " ";
            }
            if (this.designBorderState.l) {
            	bordersWidth += "1px";
            	bordersStyle += "dashed";
            	bordersColor += "#C1C1C1";
            } else {
            	bordersWidth += this.borderExtents.l + "px";
            	bordersStyle += "solid";
            	bordersColor += this.borderColor;
            }
            stylesObj.borderStyle = bordersStyle;
            stylesObj.borderColor = bordersColor;
            stylesObj.borderWidth = bordersWidth;
        } else {
            var device = this._isDesignLoaded ? studio.currentDeviceType : wm.device;
            stylesObj = {
                margin: (margins.join("px ") || 0) + "px",
                padding: (paddings.join("px ") || 0) + "px",
                borderStyle: "solid",
                borderWidth: (borders.join("px ") || 0) + "px",
                borderColor: this.borderColor,
                backgroundColor: this.backgroundColor,
                overflowX: device != "desktop" ? "hidden" : this.scrollX ? "auto" : overflow,
                overflowY: this.scrollY ? "auto" : overflow
            }
        }

        if (this.styles && !wm.isEmpty(this.styles)) {
            stylesObj = dojo.mixin(stylesObj, this.styles);
        }
        return stylesObj;
    },
    setCssViaCssText: function(cssObj) {
        if (!this.domNode) return;

        var cssTextItems = [];
        var skipItems = ["backgroundColor", "padding", "margin",
        "borderTopWidth", "borderTopStyle", "borderTopColor",
        "borderBottomWidth", "borderBottomStyle", "borderBottomColor",
        "borderLeftWidth", "borderLeftStyle", "borderLeftColor",
        "borderRightWidth", "borderRightStyle", "borderRightColor",
        "overflowX", "overflowY"];
        wm.forEachProperty(cssObj, dojo.hitch(this, function(styleValue, styleName) {
        	if (dojo.indexOf(skipItems, styleName) == -1) {
        		if (styleName == "backgroundGradient") {
		            var gradient = cssObj.backgroundGradient;
                if (gradient) {
  		            inValue = wm.getBackgroundStyle(gradient.startColor, gradient.endColor, gradient.colorStop, gradient.direction, "");
  		            if (dojo.isIE < 10) {
  		                cssTextItems.push("filter: " + inValue);
  		            } else {
  		                cssTextItems.push("background: " + inValue);
  		            }
                }
		        } else if (styleName == "borderRadius") {
					var prefix = "";
			   		   		if (dojo.isWebKit) {
								prefix = "-webkit-";
			   		   		}

				   		   	var values = String(styleValue).split(/\s+/);
				           	inValue = "";
							for (var i = 0; i < values.length; i++) {
								if (values[i].match(/^\d+$/)) values[i] += "px";
							}
							if (values.length == 1) values[1] = values[2] = values[3] = values[0];
							if (values.length == 2) {
								values[3] = values[0];
								values[2] = values[1];
							}
							if (values.length == 3) {
								values[3] = "0px";
							}
							cssTextItems.push(prefix + "border-top-left-radius: " + values[0]);
							cssTextItems.push(prefix + "border-top-right-radius: " + values[1]);
							cssTextItems.push(prefix + "border-bottom-left-radius: " + values[2]);
							cssTextItems.push(prefix + "border-bottom-right-radius: " + values[3]);
				   	} else {
    			        if (styleName == "backgroundImage") {
    			        	if (this._isDesignLoaded && (styleValue.indexOf("url") != 0 && styleValue.indexOf("http") !=0 && styleValue.indexOf("/") != 0)) {
    							styleValue = this.getPath() + styleValue;
    						}
    			        	if (styleValue.indexOf("url") != 0) styleValue = "url(" + styleValue + ")";
    			        }
    		            cssTextItems.push(styleName.replace(/([A-Z])/g, function(inLetter) {
    		                return "-" + inLetter.toLowerCase();
    		            }) + ":" + styleValue);
    		        }
		        this._appliedStyles[styleName] = styleValue;
	        }
        }));

        /* margin/padding/border all affect the layout and sizing of widgets and can't be left to stylesheets */
        cssTextItems.push("margin:" + cssObj.margin);
        cssTextItems.push("padding:" + cssObj.padding);
        /*
        if (this.designBorderState) {
            cssTextItems.push("border-top:" + cssObj.borderTopStyle + " " + cssObj.borderTopWidth + " " + cssObj.borderTopColor);
            cssTextItems.push("border-bottom:" + cssObj.borderBottomStyle + " " + cssObj.borderBottomWidth + " " + cssObj.borderBottomColor);
            cssTextItems.push("border-left:" + cssObj.borderLeftStyle + " " + cssObj.borderLeftWidth + " " + cssObj.borderLeftColor);
            cssTextItems.push("border-right:" + cssObj.borderRightStyle + " " + cssObj.borderRightWidth + " " + cssObj.borderRightColor);
        } else {*/
            cssTextItems.push("border-style:" + cssObj.borderStyle);
            cssTextItems.push("border-width:" + cssObj.borderWidth);
            cssTextItems.push("border-color:" + cssObj.borderColor);
//        }
        if (cssObj.backgroundColor) cssTextItems.push("background-color:" + cssObj.backgroundColor);
        cssTextItems.push("overflow-x:" + cssObj.overflowX);
        cssTextItems.push("overflow-y:" + cssObj.overflowY);
        if (wm.isMobile && dojo.isWebKit && (cssObj.overflowY == "auto" || cssObj.overflowY == "scroll")) {
            cssTextItems.push("-webkit-overflow-scrolling: touch");
        }

        // why is it +=?  So that position: absolute isn't blown away; so that any custom widget styles aren't blown away.
        // How efficient is resetting cssText (cssText is "border:5", how efficient is cssText += ";border:10" handled?)
        this.domNode.style.cssText += cssTextItems.join(";");
    },

	setCssViaDom: function(cssObj) {
	    if (!this.domNode) return;
	    var s = this.domNode.style;
	    var borderSet = false;
	    wm.forEachProperty(cssObj, dojo.hitch(this, function(styleValue, styleName) {
		try {

		    if (this._appliedStyles[styleName] != styleValue) {
				if (styleName == "backgroundGradient") {
				    var gradient = cssObj[styleName];
            if (gradient) {
  				    inValue = wm.getBackgroundStyle(gradient.startColor,gradient.endColor,gradient.colorStop,gradient.direction, "");
  				    if (dojo.isIE < 10) {
  					     s.filter = inValue;
  				    } else {
  					     s.background = inValue;
  				    }
            }
				} else {
					if (styleName == "backgroundImage") {
						if (this._isDesignLoaded && (styleValue.indexOf("url") != 0 && styleValue.indexOf("http") !=0 && styleValue.indexOf("/") != 0)) {
							styleValue = this.getPath() + styleValue;
						}
			        	if (styleValue.indexOf("url") != 0) styleValue = "url(" + styleValue + ")";
			        }
				    s[styleName] = styleValue;
				    this._appliedStyles[styleName] = styleValue;
				}
		    }
		    if (wm.isMobile && dojo.isWebKit && (s.overflowY == "scroll" || s.overflowY == "auto")) {
			    s.WebkitOverflowScrolling = "touch";
		    }
		} catch(e) {
		    console.error("Invalid style for " + this.name + "; " + styleName + ": " + cssObj[styleName]);
		}
	    }));
	},
	getCssSplitter: function (value) {
	    var splitter = ",";
	    if (value) {
	        value = dojo.trim(String(value));
		if (value.indexOf(",") == -1 && value.indexOf(" ") != -1)
		{
		    splitter = " ";
		}
	    }
	    return splitter;
	},
	renderBounds: function() {
	    var isChanged = false;
	    if (this.dom) {
		var b = this.getStyleBounds();
		isChanged = this.dom.setBox(b, wm.AbstractEditor && this.singleLine && this instanceof wm.AbstractEditor == false);
	    }
	    // bc
	    if (this.designWrapper) {
		this.designWrapper.controlBoundsChange();
		this.designWrapper.renderBounds();
	    }
	    return isChanged;
	},
	//===========================================================================
	// Flow
	//===========================================================================
	// FIXME: controversial update implementation cribbed from Layers.js
	/*
	  beginUpdate: function() {
	  this.domNode._reflowing = true;
	  },
	  endUpdate: function() {
	  this.domNode._reflowing = false;
	  },
	*/
	reflow: function() {
	    //wm.fire(this.domNode, "reflow");
	},
	reflowParent: function() {
	    wm.fire(this.parent, "reflow");
	    //wm.fire(this.domNode.parentNode, "reflow");
	},
	setScrollX: function(inScrollX) {
	    this.scrollX = inScrollX;
	    this.invalidCss = true;
	    this.render();
	    this.reflowParent();
	},
	setScrollY: function(inScrollY) {
	    this.scrollY = inScrollY;
	    this.invalidCss = true;
	    this.render();
	    this.reflowParent();
	},
	setAutoScroll: function(inAutoScroll) {
	    this.autoScroll = inAutoScroll;
	    if (inAutoScroll) {
			if (this.isDesignLoaded() && (this.scrollX || this.scrollY)) {
			    this.scrollX = false;
			    this.scrollY = false;
	            if (dojo.indexOf(studio.designer.selected, this) != -1) {
					studio.inspector.reinspect();
				}
			}
	    }

	    // Update the css without also updating the bounds (TODO: make this mechanism less cumbersome)
	    this.noRenderBounds=true;
	    this.invalidCss = true;
	    this.renderCss();
	    delete this.noRenderBounds;
	},

	//===========================================================================
	// Convenience
	//===========================================================================
	/**
	   Set <a href="#showing">showing</a> property true.
	*/
	show: function() {
	    this.setValue("showing", true);
	},
	/**
	   Set <a href="#showing">showing</a> property false.
	*/
	hide: function() {
	    this.setValue("showing", false);
	},
	/**
	   Set <a href="#disabled">disabled</a> property true.
	*/
	disable: function() {
	    this.setValue("disabled", true);
	},
	/**
	   Set <a href="#disabled">disabled</a> property false.
	*/
	enable: function() {
	    this.setValue("disabled", false);
	},
	toString: function(inText) {
	    var t = inText || "";
	    if (!this.showing)
		t += " (" + wm.getDictionaryItem("wm.Control.toString_HIDDEN") + ")";
	    return this.inherited(arguments, [t]);
	},
	//===========================================================================
	// Setters
	//===========================================================================
	setParent: function(inParent) {
	    var oldParent = this.parent;
	    var newParent = this.parent = inParent;

	    // Tricky new addition: if the parent has a containerWidget AND the parent OWNS that containerWidget, then switch parents!
	    if (inParent && inParent.containerWidget && inParent.containerWidget.owner == inParent && !wm.isInstanceType(inParent.containerWidget.owner, wm.Composite)) {
		   newParent = this.parent = inParent.containerWidget;
        }
	    // If the new parent is not the same as the old parent, remove the widget from the old parent
	    // and remove the control from the old parent (Note: lookup difference between widget and control)
	    if (oldParent && oldParent != newParent && !oldParent.isDestroyed) {
    		oldParent.removeWidget(this);
    		// BC: we still have non-container parents (e.g. wm.Dialog)
    		if (oldParent.removeControl) {
    		    oldParent.removeControl(this);
            }
	    }

	    if (!this._cupdating) {
    		if (newParent) {
    		    this.appendDOMNode(newParent);
    		} else if (this.domNode && this.domNode.parentNode) {
    		    this.domNode.parentNode.removeChild(this.domNode);
    		}
	    }

	    // If there is a new parent, add this component to its widgets and controls
	    /*
	      if (newParent) {
	      newParent.addWidget(this);
	      // BC: we still have non-container parents (e.g. wm.Dialog)
	      if (newParent.addControl)
	      newParent.addControl(this);
	      }
	      // BC: wm.Layout
	      else if (this.parentNode && this.domNode) {
	      this.parentNode.appendChild(this.domNode);
	      }
	    */
	    if (newParent && oldParent) {
    		dojo.publish("wmwidget-parentChange", [oldParent, newParent, this]);
        }
	    if ((this._isDesignLoaded === undefined ? this.isDesignLoaded() : this._isDesignLoaded) && this.owner == studio.page && !this.owner._loadingPage && inParent instanceof wm.Container) {
    		wm.job(inParent.getRuntimeId() + ".designResize", 50, function() {
    		    inParent.designResizeForNewChild();
    		});
	    }
	},
	appendDOMNode: function(inParent){
	    var newParent = inParent;
	    if (newParent) {
		newParent.addWidget(this);
		// BC: we still have non-container parents (e.g. wm.Dialog)
		if (newParent.addControl)
		    newParent.addControl(this);
	    }
	    // BC: wm.Layout
	    else if (this.parentNode && this.domNode) {
		var node = this.parentNode;
		node.appendChild(this.domNode);
	    }
	},
    getIndexInParent: function() {
    	if (this.parent && this.parent instanceof wm.Container) // wm.Designer is not a container
    	    return this.parent.indexOfControl(this);
    	return -1;
    },
    setIndexInParent: function(inIndex) {
    	if (this.parent)
    	    this.parent.moveControl(this, inIndex);
    },
	canChangeShowing: function() {
	    return true;
	},
	setShowing: function(inShowing,forceChange) {
	    var s = Boolean(inShowing);
	    if (!this.canChangeShowing())
		return;
	    // always show widgets at design time whose showing property is bound
	    if (this._isDesignLoaded && this.$.binding && this.$.binding.wires.showing) {
		s = true;
	    }
	    if (forceChange || this.showing != s) {
		this.showing = s;
		this.domNode.style.display = s ? '' : 'none';
		this.reflowParent();
	    }
	},
	/**
	   Set disabled property for this widget.<br/>
	   <br/>
	   Some widgets change behavior or display based on the disabled state.<br>
	   @param {Boolean} inDisabled True to set disabled.
	*/
	setDisabled: function(inDisabled) {
	    var d = Boolean(inDisabled);
	    this.disabled = d;
	    this._disabled = d || this._parentDisabled;
	    wm.forEachProperty(this.widgets, dojo.hitch(this, function(w, name) {
    		w.setParentDisabled(this._disabled);
	    }));

	    /* foreach property fails on unnamed widgets; but not all widgets have a this.c$ */
	    if (this.c$) {
            dojo.forEach(this.c$, function(w) {
                if (!w.name) {
                    w.setParentDisabled(this._disabled);
                }
            }, this);
        }
	    dojo.toggleClass(this.domNode, "Disabled", this._disabled);
	},
    setParentDisabled: function(inDisabled) {
	this._parentDisabled = inDisabled;
	this.setDisabled(this.disabled);
    },
	setBackgroundColor: function(inColor) {
	    this.backgroundColor = inColor;
	    this.invalidCss = true;
	    this.render();
	},
	setBorderColor: function(inColor) {
	    this.borderColor = inColor;
	    this.invalidCss = true;
	    this.render();
	},
	//===========================================================================
	// Default and User Style Classes
	//===========================================================================
	addRemoveDefaultCssClass: function(inAdd) {
	    if (this.owner)
		dojo[inAdd ? "addClass" : "removeClass"](this.domNode, this.owner.declaredClass + '-' + this.name);
	},
	getUserNodeClasses: function(inNodeName) {
	    var klasses = this._classes;
	    for (var i in klasses) {
		if (inNodeName == i)
		    return klasses[i].join(' ');
	    }
	    return "";
	},
	initUserClasses: function() {
	    // bc
	    if (dojo.isArray(this._classes))
		this._classes = {domNode: this._classes};
	    var klasses = this._classes;
	    for (var i in klasses)
		this.initUserNodeClasses(klasses[i], i);
	},
	initUserNodeClasses: function(inClasses, inNodeName) {
	    var k = inClasses || [], n = this[inNodeName];
	    if (n)
		// add classes together for speed; we don't care about checking if the class is already on the node
		dojo.addClass(n, k.join(' '));
	},
	/**
	   Add CSS class to a widget node.<br/>
	   @param {String} inClass The class to add.
	   @param {String} inNodeName (Optional) a property in this widget that references a node.
	   If ommitted, the default node is used.
	   @example this.panel.addUserClass("hilite-border");
	*/
	addUserClass: function(inClass, inNodeName) {
	    inNodeName = inNodeName || "domNode";
	    var cs = this._classes[inNodeName] = this._classes[inNodeName] || [];
	    cs.push(inClass);
	    var n = this[inNodeName];
	    if (n)
		dojo.addClass(n, inClass);
	},
	/**
	   Remove a CSS class from a widget node.<br/>
	   @param {String} inClass The class to remove.
	   @param {String} inNodeName (Optional) a property in this widget that references a node.
	   If ommitted, the default node is used.
	   @example this.panel.removeUserClass("hilite-border");
	*/
    removeUserClass: function(inClass, inNodeName) {
        inNodeName = inNodeName || "domNode";
        var n = this[inNodeName];
        if (n) dojo.removeClass(n, inClass);
        var cs = this._classes[inNodeName] || [];
        for (var i = 0, c; c = cs[i]; i++) {
            if (c == inClass) {
                cs.splice(i--, 1);
            }
        }
        if (!cs.length) delete this._classes[inNodeName];
    },

    setStyle: function(inStyle, inValue) {
        if (inValue === undefined || inValue === null) inValue = "";
        if (inStyle == "border" || inStyle == "borderColor" || inStyle == "margin" || inStyle == "padding") {
            return this.setProp(inStyle, inValue);
        }

        if (!this.styles) {
            this.styles = {};
        }
        if (inValue === null || inValue === undefined || inValue === "") {
            delete this.styles[inStyle];
        } else {
            this.styles[inStyle] = inValue;
        }

        switch(inStyle) {
	        case "backgroundGradient":

	            if (inValue) {
	                inValue = wm.getBackgroundStyle(inValue.startColor, inValue.endColor, inValue.colorStop, inValue.direction, "");
	            } else {
	                inValue = "";
	            }
	            if (dojo.isIE < 10) {
	                this.domNode.style.filter = inValue;
	            } else {
	                this.domNode.style.background = inValue;
	            }
	            break;
		   case "borderRadius":
				var prefix;
   		   		if (dojo.isWebKit) {
   		   			prefix = "Webkit"; /* Mostly here for android 2 browser */
   		   		}
	   		   	if (prefix) prefix += "B";
	   		   	else prefix = "b";
	           	var values = String(inValue).split(/\s+/);
	           	inValue = "";
				for (var i = 0; i < values.length; i++) {
					if (values[i].match(/^\d+$/)) values[i] += "px";
				}
				if (values.length == 1) values[1] = values[2] = values[3] = values[0];
				if (values.length == 2) {
					values[3] = values[0];
					values[2] = values[1];
				}
				if (values.length == 3) {
					values[3] = "0px";
				}
		   		 this.domNode.style[prefix + "orderTopLeftRadius"] = values[0];
		   		 this.domNode.style[prefix + "orderTopRightRadius"] = values[1];
		   		 this.domNode.style[prefix + "orderBottomLeftRadius"] = values[2];
		   		 this.domNode.style[prefix + "orderBottomRightRadius"] = values[3];
		   		 break;
		   case "backgroundImage":
        		if (this._isDesignLoaded && (inValue.indexOf("url") != 0 && inValue.indexOf("http") !=0 && inValue.indexOf("/") != 0)) {
					inValue = this.getPath() + inValue;
				}
	        	if (inValue.indexOf("url") != 0) inValue = "url(" + inValue + ")";
                this.domNode.style[inStyle] = inValue;
	 	        break;
           default:
	            this.domNode.style[inStyle] = inValue;
        }
    },
    getStyle: function(inStyle) {
        if (inStyle == "border" || inStyle == "borderColor" || inStyle == "margin" || inStyle == "padding") {
            return this.getProp(inStyle);
        } else if (!this.styles) {
            return "";
        } else {
            return this.styles[inStyle] !== undefined ? this.styles[inStyle] : "";
        }
    },

	getOrderedWidgets: function() {
	    return [];
	},
	updatingEvent: function (prop, inValue){
	},

    // Only if you subscribe to these are these connected; if you subscribe then the event stops here
    onRightClick: function(event){
    },
    onMouseOver: function(event){
    },
    onMouseOut: function(event){
    },


    toHtml: function() {return "";},
    toHtmlStyles: function() {
        var style = ""; //"style='margin: " + this.margin + ";padding: " + this.padding + ";'";
        if (this.styles) {
            wm.forEachProperty(this.styles, function(value, name) {
                if (style) style += ";";
                style += name.replace(/([A-Z])/g, function(inLetter) {
                    return "-" + inLetter.toLowerCase();
                }) + ": " + value;
            });
            if (style) style = "style='" + style + "'";
        }
        return style;
    },
    customToHtml: function(inWidth) {return "";},
    print: function() {
        var html = this.toHtml(725); // 725px wide page
        var csspath = dojo.moduleUrl("wm.base.widget.themes.default").path + "print.css";
        var wavemakercsspath = dojo.moduleUrl("wm.base.styles").path + "wavemaker.css";
        var page = this.getParentPage();
        if (page) {
            var name = page.declaredClass;
            var css = wm.load("pages/" + name + "/" + name + ".css");
        }
        html = "<html><head><title>Printing " + app.declaredClass + "</title><link rel='stylesheet' type='text/css' href='" + csspath + "' /><link rel='stylesheet' type='text/css' href='" + wavemakercsspath + "'/><link rel='stylesheet' href='print.css'/>" + (css ? "<style>" + css + "</style>" : "") + "</head><body onload='print()'>" + html + "</body><html>";
        var win = window.open("", "Printing");
        if (win) {
            win.document.open("text/html");
            win.document.write(html);
            win.document.close();
        }
    },

	setHint: function(inHint) {
	    this.hint = inHint;
	    if (inHint) {
		this.createMouseOverConnect();
		this.createMouseOutConnect();
	    }
	},
	createMouseOverConnect: function() {
	    if (this.findConnection("onmouseover")) return;
	    var self = this;
	    this.connect(this.domNode, "onmouseover", function(e) {
		wm.job(self.getRuntimeId() + "MouseOverEvents", 50, function() {
		    self.mouseOver(e);
		});
	    });
	},
	createMouseOutConnect: function() {
	    if (this.findConnection("onmouseout")) return;
	    var self = this;
	    this.connect(this.domNode, "onmouseout", function(e) {
		wm.job(self.getRuntimeId() + "MouseOverEvents", 50, function() {
		    self.mouseOut(e);
		});
	    });
	},
	mouseOver: function(event) {
	    if (this.hint) {
		var self = this;
		wm.cancelJob("app.hint");
		var isShowing =  (app.toolTipDialog && app.toolTipDialog.showing);
		wm.job("app.hint", isShowing ? 0 : app.hintDelay, function() {
		    if (!self.isAncestorHidden()) {
			app.createToolTip(self.hint, self.domNode, event, self);
		    }
		});

	    }
	    this.onMouseOver(event);
	    dojo.stopEvent(event);
	},
	mouseOut: function(event) {
	    if (this.hint && app.toolTipDialog && (app.toolTipDialog.showing || wm.hasJob("app.hint"))) {
		var self = this;
		wm.job("app.hint", 500, function() {
		    if (self == app.toolTipDialog.tipOwner)
			app.hideToolTip();
		});
	    }
	    this.onMouseOut(event);
	    dojo.stopEvent(event);
	},
	onMouseOver: function(event){},
    onMouseOut: function(event){},
    getParentForm: function() {
	var w = this.parent;
	var r = this.getRoot();
	r = r && r.root;
	while (w && w != r) {
	    if (wm.isInstanceType(w, [wm.LiveFormBase, wm.DataForm])) {
			return w;
		}
		w = w.parent;
	}
    },

	setImageList: function(inImageList) {
		this.imageList = inImageList;
		this.imageListChanged();
	},
	setImageIndex: function(inImageIndex) {
		if (inImageIndex !== undefined) {
		    this.imageIndex = Number(inImageIndex);
			this.imageListChanged();
		}
	},
	imageListChanged: function() {
		var iln = this.findImageList();
		this._imageList = iln ? iln instanceof wm.ImageList ? iln : this.owner.getValueById(iln) : null;
	        this.invalidCss = true;
	    this.render(true,true);
        if (this._isDesignLoaded && this._imageList && !this._renameSubscription) {
            this._renameSubscription = this.subscribe("wmwidget-rename", dojo.hitch(this, function(inNewName, inOldName, inComponent) {
                if (inComponent == this._imageList) {
                    this.imageList = inComponent.getId();
                    this.imageListChanged();
                }
            }));
        }
	},
    getCurrentImageIndex: function() {
	    return this.imageIndex;
    },
	findImageList: function() {
		var t = this;
		while (t && !t.imageList) {
			t = t.parent;
		}
		return t ? t.imageList : null;
	},
        update: function() {
	    this.show();
	    if (this.parent) {
		this.parent.update();
	    }
	}

    });

// layout specific

/*
  wm.Control.extend({
  //fluidSize: 0,
  //alignInParent: "justified",
  //setFluidSize: function(inFluidSize) {
  //	this.fluidSize = inFluidSize;
  //	this.reflowParent();
  //}
  });

  wm.Object.extendSchema(wm.Control, {
  //fluidSize: {group: "layout"},
  });
*/

dojo.declare("wm.TouchMixin", null, {
    addTouchListener: function(optionalNode) {
        if (!this._subscriptions) {
            this._subscriptions = [];
            this._connections = [];
            this._debugSubscriptions = [];
            this.subscribe = function() {
                wm.Component.prototype.subscribe.apply(this, arguments);
            };
            this.connect = function() {
                wm.Component.prototype.connect.apply(this, arguments);
            };
            this.disconnectEvent = function() {
                wm.Component.prototype.disconnectEvent.apply(this, arguments);
            };
            // also needs a getRuntimeId method
        }
        this.connect(optionalNode || this.domNode, wm.isFakeMobile ? "mousedown" : "touchstart", this, "_onTouchStart");
        if (!wm.isFakeMobile) {
            this.connect(optionalNode || this.domNode, "touchmove", this, "_onTouchMove");
            this.connect(optionalNode || this.domNode, "touchend", this, "_onTouchEnd");
        }
        this.subscribe("wmTouchMove", dojo.hitch(this, function() {
            wm.cancelJob(this.getRuntimeId() + ".longClick");
        }));
    },
    _onTouchStart: function(e) {
        this._touchMoved = false;
        var target;
        if (e.targetTouches) {
            if (e.targetTouches.length) {
                this._touchStartY = e.targetTouches[0].clientY;
                this._touchStartX = e.targetTouches[0].clientX;
                target = e.targetTouches[0].target;
            }
        } else if ("clientY" in e) {
            this._touchStartY = e.clientY;
            this._touchStartX = e.clientX;
            target = e.target;
            this.connect(document.body, "mousemove", this, "_onTouchMove");
            this.connect(document.body, "mouseup", this, "_onTouchEnd");
        } else {
            delete this._touchStartY;
            delete this._touchStartX;
        }
        if ("_touchStartY" in this) {
            this._touchLastY = this._touchStartY;
            this._touchLastX = this._touchStartX; /* Return any value to declare this touch event ignored */
            if (this.onTouchStart(e, target)) {
                this.disconnectEvent("mousemove");
                this.disconnectEvent("mouseup");
            } else {
                wm.job(this.getRuntimeId() + ".longClick", 1000, this, "_onLongTouch");
            }
        }
    },
    _onLongTouch: function() {
        this.onLongTouch(this._touchStartX, this._touchStartY);

        // Treat an onLongTouch event as an onClick event (onTouchEnd) unless the developer
        // has setup their own onLongTouch handler
        this._onTouchEnd(null, this.onLongTouch != wm.TouchMixinOptional.prototype.onLongTouch);
    },
    onTouchStart: function(event) {},
    _onTouchMove: function(e) {
        //  e.preventDefault(); // commented out so that touching a button and then moving will count as scrolling
        var dyInitial, dyLatest, dxInitial, dxLatest;
        if (e.targetTouches) {
            if (e.targetTouches.length != 1) {
                return false;
            }
            dyInitial = e.targetTouches[0].clientY - this._touchStartY;
            dyLatest = e.targetTouches[0].clientY - this._touchLastY;
            dxInitial = e.targetTouches[0].clientX - this._touchStartX;
            dxLatest = e.targetTouches[0].clientX - this._touchLastX;
            this._touchLastY = e.targetTouches[0].clientY;
            this._touchLastX = e.targetTouches[0].clientX;
        } else {
            dyInitial = e.clientY - this._touchStartY;
            dyLatest = e.clientY - this._touchLastY;
            dxInitial = e.clientX - this._touchStartX;
            dxLatest = e.clientX - this._touchLastX;
            this._touchLastY = e.clientY;
            this._touchLastX = e.clientX;
        }
        var posY = this._touchStartY + dyInitial;
        var posX = this._touchStartX + dxInitial;



        /* If the finger has moved more than 5 pixels, its not an accidental move; */
        if (!this._touchMoved && (Math.abs(dyInitial) > 5 || Math.abs(dxInitial) > 5)) {
            this._touchMoved = true;
            wm.cancelJob(this.getRuntimeId() + ".longClick");
        }
        if (this._touchMoved) {
            this.onTouchMove(e, posY, dyInitial, dyLatest, posX, dxInitial, dxLatest);
        }
    },
    onTouchMove: function(event, yPosition, yChangeFromInitial, yChangeFromLast, xPosition, xChangeFromInitial, xChangeFromLast) {},
    _onTouchEnd: function(e, noEvents) {
        wm.cancelJob(this.getRuntimeId() + ".longClick");
        this.disconnectEvent("mousemove");
        this.disconnectEvent("mouseup");
        if (!noEvents) {
            this.onTouchEnd(e, this._touchMoved);
            if (!this._touchMoved) {
                this.onTouch(this._touchStartX, this._touchStartY);
            }
        }
    },
    onTouchEnd: function(event, isMove) {},
    onTouch: function(posX, posY) {},
    onLongTouch: function(posX, posY) {}
});

dojo.declare("wm.TouchScrollMixin", wm.TouchMixin, {
    onTouchStart: function(event) {
        this._touchTime = new Date().getTime();
        if (this._touchAnimationId) {
            window.clearInterval(this._touchAnimationId);
        }
    },
    onTouchMove: function(event, yPosition, yChangeFromInitial, yChangeFromLast, xPosition, xChangeFromInitial, xChangeFromLast) {
        var node = this._scrollNode || this.domNode;
        node.scrollTop -= yChangeFromLast;
        var newTime = new Date().getTime();
        if (this._touchTime != newTime) {
            this._touchVelocity = yChangeFromLast / (this._touchTime - newTime);
            this._touchTime = newTime;
        }
        dojo.stopEvent(event);
    },
    onTouchEnd: function(event, isMove) {

        if (isMove) {
            if (this._touchVelocity != Infinity && Math.abs(this._touchVelocity) > 0.15) {
                if (this._touchAnimationId) {
                    window.clearInterval(this._touchAnimationId);
                }
                this._touchAnimationId = window.setInterval(dojo.hitch(this, "_onAnimateScroll"), 50);
            }
        }
    },
    _onAnimateScroll: function() {
        var node = this._scrollNode || this.domNode;
        this._touchVelocity *= 0.9;
        var top = node.scrollTop;
        node.scrollTop = node.scrollTop + this._touchVelocity * 50;
        var newTop = node.scrollTop;
        var diff = Math.abs(newTop - top);
        if (diff <= 1) {
            window.clearInterval(this._touchAnimationId);
        }
    }

});


if (wm.isMobile) {
    dojo.declare("wm.TouchMixinOptional", wm.TouchMixin,{});

} else {
    dojo.declare("wm.TouchMixinOptional", null,{
	onLongTouch: function(posX, posY) {}
    });
}

if (wm.isIOS <= 4 || wm.isAndroid <= 2 || wm.isFakeMobile) {
    dojo.declare("wm.TouchScrollMixinOptional", wm.TouchScrollMixin, {});
} else {
    dojo.declare("wm.TouchScrollMixinOptional", null, {});
}
wm.Widget = wm.Control;
dojo.declare("wm.Box", wm.Widget, {}); // mostly obsolete

}

if(!dojo._hasResource["wm.base.Plugin"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.Plugin"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide("wm.base.Plugin");

wm.Plugin = {
	targetClass: null,
	callerFactory: function(inOverrides) {
		return function(inArgs, inNewArgs) {
			var fn = inOverrides[inArgs.callee.nom];
			if (fn)
				return fn.apply(this, inNewArgs || inArgs || []);
		}
	},
	plugin: function(inName, inClass, inProps) {
		var overrides = [];
		for (var p in inProps) {
			if (dojo.isFunction(inProps[p]) && inClass.prototype[p])
				overrides[p] = inClass.prototype[p];
		}
		inProps[inName + 'Socket'] = this.callerFactory(overrides);
		inClass.extend(inProps);
	}
}

}

if(!dojo._hasResource["wm.base.components.Variable"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.components.Variable"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide("wm.base.components.Variable");


// FIXME: because we cannot guarantee the global "app" is a component's application
// (because studio has an app) and the runtimeService must be local to a project
// get the app corresponding to the given component.
wm.getRuntimeService = function(inComponent) {
    var a = dojo.getObject("studio.wip.app") || app;

    return wm.fire(a, "getRuntimeService");
};

//The following lines are not being used now.  They may be used in the future to differenciate requests from Studio from
//requests deployed application.
wm.getRuntimeServiceDesignTime = function(inComponent) {
    var a = dojo.getObject("studio.wip.app") || app;
    return wm.fire(a, "getRuntimeServiceDesignTime");
};

/**
    Base class for all data handling components.
    @name wm.Variable
    @class
    @extends wm.Component
*/
dojo.declare("wm.Variable", wm.Component, {
    /** @lends wm.Variable.prototype */
    json: "",
    /**
        Type of data stored in the variable, or type of each item in the list.
        @type String
    */
    type: "",
    //primaryKeyFields: "",

    /**
        True if this variable contains a list (aka array).
        @type Boolean
    */
        saveInCookie: false,
        saveInPhonegap: false,
    isList: false,
    _updating: 0,
    _dataSchema: {},
    _greedyLoadProps: false,
    _allowLazyLoad: true,
    cursor: 0,
        _uniqueSubnardId: 1,
/*
    constructor: function(inProps) {
    },
    */
    init: function() {
        this.inherited(arguments);
        if (this._isDesignLoaded) {
            this._subscriptions.push(dojo.subscribe("wmtypes-changed", this, "wmTypesChanged"));
        }
    },
    postInit: function() {
        this.inherited(arguments);
        this._inPostInit = true;
        // optimization: we should never need bindings on subNards so not creating them
        if (!this._subNard && !this.$.binding) new wm.Binding({
            name: "binding",
            owner: this
        });
        this.setType(this.type, true);
        if (window["PhoneGap"] && this.saveInPhonegap) {
            var textdata = window.localStorage.getItem(this.getRuntimeId());
            if (textdata) this.json = textdata;
        } else if (this.saveInCookie) {
            var textdata = dojo.cookie(this.getRuntimeId());
            if (textdata) this.json = textdata;
        }
        if (this.json) this.setJson(this.json);
        else this._clearData();

        this._inPostInit = false;

        // need to reinitialize after type is set
        if (!this._updating && this.$.binding) this.$.binding.refresh();

        // widgets bound to this component won't have received any events/initial
        // data or properties if no data has yet been set
        if (this.isEmpty()) {
            this.notify();
        }
    },
    //===========================================================================
    // Type Information
    //===========================================================================
    canSetType: function(inType) {
        // type is locked to dataSet type if it is set
        if (this.dataSet && this.dataSet.type == this.type) {
            wm.logging && console.debug(this.name, "cannot set variable type because this variable has a dataSet");
            return;
        }
        return true;
    },
    setType: function(inType, noNotify) {
        this._hasChanged = false;
        if(inType == this.declaredClass || this.owner instanceof wm.Variable && inType == this.owner.declaredClass) inType = "";

        //this.unsubscribe("TypeChange-" + this.type);
        if(!this.canSetType(inType)) return;

        var t = inType;
        if(wm.isListType(t)) {
            this.isList = true;
            if(t.substring(t.length - 1) == "]") {
                t = t.slice(1, -1);
            }
            // don't reset isList if we have data; also don't reset isList if we're in postInit; the setType call in postInit should
            // not lose the user's isList setting
        } else if(!(this.data && this.data._list) && !this._inPostInit) this.isList = false;

        var hasChanged;
        if (this.type != t) {
            hasChanged = true;
        } else if (this._isDesignLoaded) {
            hasChanged = dojo.toJson(this._getSchemaForType(inType)) != dojo.toJson(this._dataSchema);
        }
        this._hasChanged = hasChanged;
        this.type = t;
        //

        if (this._proxy) {
            this._proxy.setType(this.type);
        }
        this.typeChanged(this.type);
        if (this._query && hasChanged) this._query.setType(this.type);
        if (this.json & hasChanged) {
            this.setJson(this.json);
        }
/*
            if (this._isDesignLoaded) {
                this.subscribe("TypeChange-" + inType, dojo.hitch(this, function() {
                    this.setType(inType); // reset the type if the type definition has changed
                    // Reevaluate the json for the new type
                    if (this.json)
                        this.setJson(this.json);
                }));
            }
        */
        if(!noNotify && hasChanged && inType && inType != "any") this.notify(); //  this will cause anyone bound to this object to treat a change of type as a change in its dataSet
    },
    /* Design time only */
    set_type: function(inType) {
        this.setType(inType);
        studio.reinspect();
        /*
    var oldType = this.type;
    this.setType(inType);
    if (oldType != inType) {
        var keys = wm.getPrimaryKeys(wm.typeManager.getType(inType));
        this.primaryKeyFields = keys.length ? keys.join(",") : "";
    }
    reinspect();
    */
    },
    typeChanged: function(inType) {
        var t = inType;
        var primitive = wm.typeManager.getPrimitiveType(t) || !t || t == "wm.Variable";
        this.isPrimitive = Boolean(primitive);
        var schema = this._getSchemaForType(t);
        if (schema)
            this.setDataSchema(schema);
    },
    _getSchemaForType: function(inType) {
        var p = wm.typeManager.getPrimitiveType(inType);
        if (this.isPrimitive) {
            // we're a string primitive by default
            return {dataValue:{type: p || 'String'/*, isList:this.isList*/}};
        } else {
            return wm.typeManager.getTypeSchema(inType) || {dataValue:{type: p || 'String', isList:this.isList}};
        }
    },
    setDataSchema: function(inSchema) {
        this._dataSchema = inSchema;
    },
    setJson: function(inJson) {
        this.json = inJson;
        try {
            var d = eval("(" + inJson + ")");
        } catch(e) {
          console.error("Json error in " + this.name + ": " + e);
        }
            this.setData(d);
    },
    hasList: function() {
        return this.data && ("list" in this.data);
    },
    getDataTypeInfo: function(inProp) {
        return this._dataSchema[inProp];
    },
    listDataProperties: function() {
        var list = this._listSchemaProperties({}, this._dataSchema, "getDataTypeInfo");
        for (var i in list) {
            list[i].bindable = true;
        };
        return list;
    },
    //===========================================================================
    // Update Buffering
    //===========================================================================
    beginUpdate: function() {
        this._updating++;
    },
    endUpdate: function() {
        this._updating--;
    },
    isUpdating: function() {
        return this._updating > 0;
    },
    //===========================================================================
    // Data API
    //===========================================================================
    /**
        Clear all data values.
    */
    clearData: function() {
        this._clearData();
            this.setType(this.type, true);
            if (this.type && this.type != this.declaredClass && !this._initializing)
            this.notify();
    },
    _clearData: function() {
        this._isNull = false;
        this._nostub = false;
        if (!this.data)
            this.data = {};
        if (this.isList)
            this.data = {_list: []};
        else {
            // maintain any subNards (to one depth anyways), but otherwise clear data
            var d;
            for (var i in this.data) {
                d = this.data[i];
                if (d instanceof wm.Variable && !wm.typeManager.getLiveService(d.type))
                    d._clearData();
                else
                    delete this.data[i];
            }
        }
    },
    _setNull: function(inNull) {
        this._isNull = inNull;
        // owner null can be unset but not set. consequence: all null values != null
        if (!inNull && this._subNard && this.owner) {
            this.owner._setNull(inNull);
        }
    },
    /**
        Copy data into this variable.<br/>
        <br/>
        Input data can be a primitive value, an array, a plain old JavaScript object (POJSO), or a wm.Variable.
        Success of setData requires that the type of the input is compatible with the type of this variable.
        @param {Any} inData Input data.
    */
    // NB: input can be a POJSO or a Variable
    setData: function(inData) {
        /* Don't try setting data to null if we're still initializing components for the page;
         * that just clobbers the cookie/permanent memory with data not yet set
         */
        if (window["PhoneGap"] && this.saveInPhonegap || this.saveInCookie) {
            var ownerPage = this.getParentPage();
            if (ownerPage && ownerPage._loadingPage && !inData) return;
        }

        if (inData instanceof wm.Variable) inData = inData.getData();

        this.onPrepareSetData(inData);

        if (dojo.isArray(inData)) {
            this._setArrayData(inData);
        } else if (this.isPrimitive) {
            this._setPrimitiveData(inData);
        } else {
            this._setObjectData(inData);
        }
        this.notify();
        this.onSetData();

    },

    onPrepareSetData: function(inData) {
    },
    onSetData: function() {},
    notify: function() {
        this.dataOwnerChanged();
        this.dataChanged();
        this.valueChanged("isEmpty", this.isEmpty());
        if (this.isList) {
            this.valueChanged("count", this.getCount());
        }
        if (!this.isUpdating() && this.queriedItems) {
            this.setQuery(this._query);
        }
        this.updatePermanentMemory();
    },
    _setPrimitiveData: function(inValue) {
        if (inValue !== null && typeof inValue == "object") {
            this.data = inValue;
        } else {
            this.data = {
                dataValue: inValue
            };
        }

        this.isList = false;
    },
/*
    _setVariableData: function(inVariable) {
        this.setData(inVariable.getData());
    },
    */
    /* WM-2500: Need a way for the user to change the isList property at design time (but not for subclasses of wm.Variable) */
    setIsList: function(isList) {
        if (isList && !this.isList) {
            this.isList = true;
            if (this.json && !this.data._list) this.setJson("[" + this.json + "]");
            else if (wm.isEmpty(this.data)) this._setArrayData([]);
            else {
                var data = [];
                data.push(this.getData());
                this.setData(data);
            }
        } else if (!isList && this.isList) {
            if (this.json) {
                this.setJson(dojo.toJson(this.getItem(0).getData()));
            } else if (wm.isEmpty(this.data._list)) {
                this.setData(null); // this should change isList automatically
            } else {
                this.setData(this.getItem(0)); // this should change isList automatically unless item(0) is itself a list
            }

        }
    },
    _setArrayData: function(inArray) {
        if (wm.defaultTypes[this.type] && inArray.length && typeof inArray[0] != "object") {
            inArray = dojo.map(inArray, function(v) {return {dataValue: v};});
        }
        this.data = { _list: inArray };
        this.isList = true;
        this._isNull = inArray.length == 0;
    },
    _setObjectData: function(inObject) {
        this.beginUpdate();
        this._clearData();
        this.isList = false;

        delete this.data._list;
        var d, v, nv, isNull = inObject === null, empty = wm.isEmpty(inObject);
        for (var i in this._dataSchema) {
            d = this.data[i];
            v = !empty ? inObject[i] : undefined;
            // nv is parent null or v, called null-checked value
            nv = isNull ? null : v;
            if (this._isVariableProp(i)) {
                // for existing variable props, set null-checked value iff it exists
                if (d instanceof wm.Variable) {
                    if (nv !== undefined) {
                        // we don't need to propagate messages from variable properties
                        // since this variable will propagete them
                        d.beginUpdate();
                        d.setData(nv);
                        d.endUpdate();
                    }
                // for non-existing variable props, set *value* iff it exists
                // (we do not set null values here because that can prompt infinite marshalling)
                } else if (v !== undefined) {
                    this._setDataValue(i, v);
                }
            // for non-variable props, set null-checked value iff it exists
            } else {
                if (nv !== undefined)
                    this._setDataValue(i, nv);
            }
        }
        this._setNull(isNull);
        this.endUpdate();
    },
    /**
        Export data from this variable into a plain old JavaScript object (POJSO).<br/>
        @returns Object
    */
    // NB: output is POJSO
    getData: function(flattenPrimitives) {
        if (!this.data || this.disabled) return;
        if (this._isNull) return null;
        else if (this.isList) {
            // if its a byte list merge it into a single string and change it to a nonlist
            if (this.type == "byte") {
                try {
                    if (this.data._list && this.data._list[0] instanceof wm.Variable) {
                        this.data._list[0] = this.data._list[0].data.dataValue;
                    }
                    this.data = {
                        dataValue: this.data._list.join("")
                    };
                } catch (e) {
                    this.data = null;
                }
                this.isList = false;

                return dojo.clone(this.data); // getData never returns pointers into the datastructure but only copies so that manipulating it doesn't corrupt the wm.Variable
            } else if (wm.Variable.convertToHashMaps && this.data._list && wm.isHashMapType(this.type)) {
                var data = {};
                for (var i = 0, l = this.getCount(), v; i < l; i++) {
                    v = (this.getItem(i) || 0).getData(flattenPrimitives);
                    data[v.name] = v.dataValue;
                }
                return data;
            } else {
                var data = [];
                for (var i = 0, l = this.getCount(), v; i < l; i++) {
                    v = (this.getItem(i) || 0).getData(flattenPrimitives);
                    if (v) data.push(v);
                }
                return data;
            }
        } else if (flattenPrimitives && this.isPrimitive && this.data["dataValue"] !== undefined) {
            return this.data.dataValue;
        } else if (this.isEmpty()) {
            return null;
        } else {
            var data = {};
            var props = this.listDataProperties();
            for (var i in props) {
                var v = this.data[i];
                if (wm.getDataConvertDates && v instanceof Date) {
                    v = v.getTime();
                } else if (props[i] && props[i].type == "Date" && typeof v === "string") {
                	v = this.data[i] = new Date(v).getTime();
                }

                // we may not always want all related junk
                if (v !== undefined) {
                    if (v instanceof wm.Variable) {
                        if (v.isEmpty()) v = null;
                        else v = v.getData(flattenPrimitives)
                    }
                    // don't return undefined or empty, non-null variables properties
                    if (v === undefined || (v !== null && typeof v == "object" && wm.isEmpty(v))) continue;
                    data[i] = v;
                }
            }
            if (!wm.isEmpty(data)) return data;
        }
    },

    //===========================================================================
    // Value API
    //===========================================================================
    _getDataValue: function(n, noMarshal) {
        if (!this.data)
                this.data = {};
        var d, f;
        if (this.isList) {
            f = this.getCursorItem();
            d = f && f.data;
        } else
            d = this.data;
        var v = d && d[n], typeInfo = this._dataSchema[n];
        // FIXME: Encountered a project where _isVariableProp(n) was true, but v was a string
        if (this._isVariableProp(n) && (!v || (v._isStub && v._isStub())) && !noMarshal) {
            v = d[n] = (f || this).marshallVariable(n, typeInfo, v);
        } else if (typeInfo && typeInfo.type == "Date") {
        	v = d[n];
        	if (typeof v == "string") {
				try {
	        		v = d[n] = new Date(v).getTime();
	        	} catch(e) {}
        	}
        }
        return v;
    },
    _setDataValue: function(n, v) {
        // NOTE: variable value is null iff it has been explicitly set to null
        // and no value has subsequently been set to any value, including null.
        if (this._isNull && v !== undefined) this._setNull(false);
        this.beginUpdate();
        var o;
        if (v === null || v === undefined) {
            o = this._getDataValue(n, true);
            if (o === v) {
                this.endUpdate();
                return;
            }
        } else {
            o = this._getDataValue(n);
            if (o === undefined && v instanceof wm.Variable) {
                o = this.data[n] = this.createVariable({type: v.type, _subNard: true, name: n});
            }
        }
        this.endUpdate();
        if (!o && v instanceof wm.Variable) {

        }
        if (o instanceof wm.Variable) {
            // if we are updating, o's listeners will be notified by us
            // o doesn't need to message them directly
            if (this._updating) o._updating++;
            if (this.isList && v instanceof wm.Variable && !v.isList) {
                this.setIsList(false);
            }
            o.setData(v);

            if (this._updating) o._updating--;
            return;
        }
        if (!(v instanceof wm.Variable)) {
            this.data[n] = v;
            this.dataValueChanged(n, v);
        }
    },
    setDisabled: function(inDisabled) {
        var valueWas = this.disabled;
        this.disabled = Boolean(inDisabled);
        if (valueWas != this.disabled) this.notify();
    },
    //===========================================================================
    // List API
    //===========================================================================
    /**
        Return the number of items in the list owned by this variable (only valid if <a href="#isList">isList</a> is true).
        @returns Number
    */
    getCount: function() {
      if (this._isNull) return 0;
      if (this.isList) return (this.data && this.data._list) ? this.data._list.length : 0;
      return 1;
    },

    /* Used by bindings to isEmpty */
    getIsEmpty: function() {
        return this.isEmpty();
    },
    isEmpty: function() {
        if (!this.data) return true;

        if (this.data._list) return !Boolean(this.data._list.length);

        for (var propName in this.data) {
            if (this.data[propName] instanceof wm.Variable) {
                if (!this.data[propName].isEmpty()) return false;
            } else if (this.data[propName] != null) { // covers undefined as well
                return false;
            }
        }
        return true;
    },

    _isEmpty: function(obj) {
        for (var prop in obj) {
            if(obj.hasOwnProperty(prop)) return false;
        }
        return true;
    },
    // Returns a Variable representing item inIndex
    // If the item is currently raw data, it's replaced
    // with a new Variable. Created Variable is initialized
    // with the raw list data unless inData is supplied.
    // If inData is supplied the Variable is populated with
    // inData.
    _needItem: function(inIndex, inData) {
        if (inIndex >= this.getCount() && inData === undefined) return null;
        // fetch the stored data object
        var item = this.data._list[inIndex];
        // optional raw data to initialize the object with
        var data = inData;
        if (!(item instanceof wm.Variable)) {
            // we want to populate with original raw data
            // unless override data iss provided
            data = inData || item;
            // create a new Variable to represent this data
            item = this.createVariable({/*name: "itemProxy",*/ type: this.type, _subNard: true, itemIndex: inIndex});
            this.data._list[inIndex] = item;
        }
        if (data !== undefined) {
            item.beginUpdate();
            item.setData(data);
            item.endUpdate();
        }
        return item;
    },
    /**
        Return an item by numeric index in the list owned by this variable (only valid if <a href="#isList">isList</a> is true).
        @param {Number} inIndex The numeric index of the item to fetch
        @returns Any
    */
    getItem: function(inIndex) {
        return this.isList && this._needItem(inIndex) || !this.isList && this;
    },
    getItemData: function(inIndex) {
        if  (!this.isList) return;
            var item = this.data._list[inIndex];
            if (item instanceof wm.Variable)
                return item.data;
            else
                return item;
    },
    _populateItems: function() {
        for (var i = 0, c = this.getCount(); i < c; i++)
        this.getItem(i);
    },
    forEach: function(inCallback) {
        var count = this.getCount();
        for (var i = 0; i < count; i++) {
            if (inCallback(this.getItem(i), i) === true) break;
        }
    },
    map: function(inCallback) {
        var result = [];
        var count = this.getCount();
        for (var i = 0; i < count; i++) {
            result.push(inCallback(this.getItem(i)));
        }
        return result;
    },
    filterItems: function(inCallback) {
        var result = [];
        this.forEach(function(item, index) {
            if (inCallback(item, index)) {
                result.push(item.getData());
            }
        });
        var v = new wm.Variable({
            type: this.type,
            owner: this
        });
        v.setData(result);
        return v;
    },
    // note: low level sort that requires a comparator function to be used.
    sort: function(inComparator) {
        this._populateItems();
        var l = this.isList && this.data && this.data._list;
        if (l) {
        if (typeof inComparator == "function") {
            l.sort(inComparator);
        } else {
            l.sort(function(a,b) {
            var v1 = a.getValue(inComparator);
            var v2 = b.getValue(inComparator);
            return wm.compareStrings(v1,v2);
            });
        }
            this.notify();
        }
    },

    /**
        Set the cursor by index. When data forms a list, the cursor indicates the item used in calls to getValue.
        @param {Number} inCursor The numeric index of the item to use as the Variable's
        @returns Any
    */
    setCursor: function(inCursor) {
        this.cursor = Math.max(0, Math.min(this.getCount()-1, inCursor));
        this.notify();
    },
    /**
        Increments the cursor.
        @returns Any
    */
    setNext: function() {
        this.setCursor(this.cursor+1);
    },
    /**
        Decrements the cursor.
        @returns Any
    */
    setPrevious: function() {
        this.setCursor(this.cursor-1);
    },
    /**
        Sets the cursor to the first item.
        @returns Any
    */
    setFirst: function() {
        this.setCursor(0);
    },
    /**
        Sets the cursor to the last item.
        @returns Any
    */
    setLast: function() {
        this.setCursor(this.getCount()-1);
    },
    getIndexInOwner: function() {
        if (this.owner instanceof wm.Variable && this.owner.data._list) {
            return dojo.indexOf(this.owner.data._list, this);
        }
        return -1;
    },
    /**
        Retrieves the data item at the current list cursor. If data is not a list, returns the Variable
        @returns wm.Variable
    */
    getCursorItem: function() {
        return this.getItem(this.cursor || 0) || this;
    },
    /**
        Set an item by numeric index in the list owned by this variable (only valid if <a href="#isList">isList</a> is true).
        @param {Number} inIndex The numeric index of the item to set
        @param {Any} inData The data to store
    */
    setItem: function(inIndex, inData) {
        this._setItem(inIndex, inData);
        this.cursor = inIndex;
        this.notify();
    },
    _setItem: function(inIndex, inData) {
        if (this.isList)
            this._needItem(inIndex, inData);
        this.onSetData();
    },
    /**
        Adds an item to the list of data. Only functions if data forms a list.
        @param {wm.Variable or Object} inData The data to add, either a an Object or wm.Variable
        @param {Number} inIndex (Optional) The numeric index at which to insert the data.
        @returns Any
    */
    addItem: function(inData, inIndex) {
        this._addItem(inData, inIndex);
        this.cursor = inIndex;
        this.notify();
    },
    _addItem: function(inData, inIndex) {
        if (this.isList) {
            var c = this.getCount();
            if (inIndex >= 0 && inIndex < c)
                this.data._list.splice(inIndex, 0, {});
            else
                inIndex = this.getCount();
            this._setItem(inIndex, inData);
        }
    },
    /**
        Removes an item from the list of data. Only functions if data forms a list.
        @param {Number} inIndex The numeric index of the item to remove.
        @returns Any
    */
    removeItem: function(inIndex) {
        this._removeItem(inIndex);
        this.cursor = 0;
        this.notify();
    },
    _removeItem: function(inIndex) {
        if (this.isList)
            this.data._list.splice(inIndex, 1);
    },
    // should we store this for faster access? (items have itemIndex, but this is not maintained)
    getItemIndex: function(inVariable) {
        if (!this.isList)
            return -1;
        var list = (this.data || 0)._list || [];
        for (var i=0, l = list.length; i < l; i++) {
            if (inVariable == list[i])
                return i;
        }
        return -1;
    },
    getItemIndexByPrimaryKey: function(inVariable, pkList){
        if (!this.isList || !pkList || pkList.length < 1)
            return -1;
        var obj = inVariable;
        if (obj instanceof wm.Variable){
            obj = inVariable.getData();
        }

        var list = (this.data || 0)._list || [];
        for (var i=0, l = list.length; i < l; i++) {
            obj2 = list[i] instanceof wm.Variable ? list[i].getData() : list[i];
            var isEqual = true;
            for (var j = 0; j < pkList.length; j++){
                var f = pkList[j];
                if (obj[f] != obj2[f]){
                    isEqual = false;
                    break;
                }
            }

            if (isEqual)
                return i;
        }
            return -1;
    },
    getQueriedItems: function() {
        if (!this.queriedItems) {
            this.queriedItems = new wm.Variable({
                isList: true,
                type: this.type,
                name: "queriedItems"
            });
            this.queriedItems.setOwner(this, true);
            // queried items are ALL items until a query has been issued
            this.queriedItems.setDataSet(this);
        }
        return this.queriedItems;
    },
    createQueryVar: function() {
        if (this.owner instanceof wm.Variable == false) {
            this._query = new wm.Variable({type:this.type, isList:false, owner: this, name: "queryVar"});
        }
    },

    // property is named queryVar so getter and setter must be getQueryVar/setQueryVar.  Why not getQuery/setQuery?
    // Because in WM 6.5 we defined a setQuery method and query method, and getQuery/setQuery implies a query property
    // rather than a query method, and the query method is public.
    getQueryVar: function() {
        if (!this._query) this.createQueryVar();
        return this._query;
    },
    setQueryVar: function(query) {return this.setQuery(query);},
    setQuery: function(query) {
        if (!this._query) this.createQueryVar();
        this._query.setData(query);
        if (!this._query.isEmpty()) {
            return this.query(this._query.getData(), true);
        } else {
            this.getQueriedItems().setDataSet(this);
        }
    },
    query: function(inSample, updateQueriedItems) {
        if (!this.isList) return;
        if (!inSample) inSample = {};
        var maxResults = inSample._maxResults || 0;
        delete inSample._maxResults;

        var count = this.getCount();
        var result = [];
        if (inSample instanceof wm.Variable) {
            inSample = inSample.getData() || {};
        }

        for (var i = 0; i < count; i++) {
            var item = this.getItem(i);
            if (this._queryItem(item, inSample, i)) {
                result.push(item);
            }
            if (maxResults) {
                if (result.length >= maxResults) break;
            }
        }
        if (updateQueriedItems) {
            var v = this.getQueriedItems();
        } else {
            var v = new wm.Variable({
                type: this.type,
                isList: true,
                name: "QueryResults"
            });
            v.setOwner(this, true);
        }
        v.setData(result);
        if (maxResults) inSample._maxResults = maxResults; // undo our modifications to the user's structure so they can reuse it
        return v;
    },
/*
    _queryItem: function(inItem, inSample, inIndex) {
    var w = "*";
    var isMatch = true;
    wm.forEachProperty(inSample, function(value, key) {
        var matchStart = true;
        var valueA = inItem.getValue(key);

        var conditions = value;
        wm.forEachProperty(conditions, function(valueB, conditionKey) {
        switch(conditionValue) {
        case ">":
            if (valueB <= valueA)
        case ">=":

        case "<":


        case "<=":

        case: "=":

        case "!=":

        case "in":
        }

        });
        var b = inSample[key];



        var stringB = String(b);
        if (stringB.charAt(0) == w) {
        b = b.substring(1);
        matchStart = false;
        } else if (stringB.charAt(0) == ">") {
        var orEqual = false;
        if (stringB.charAt(1) == "=") {
            orEqual = true;
            b = b.substring(2);
        } else {
            b = b.substring(1);
        }
        if (typeof a == "number") {
            b = Number(b);
        } else if (typeof a == "string") {
            b = b.toLowerCase();
        }
        if (orEqual) {
            if (a < b) return false;
        } else {
            if (a <= b) return false;
        }
        continue;
        } else if (stringB.charAt(0) == "<") {
        var orEqual = false;
        if (stringB.charAt(1) == "=") {
            orEqual = true;
            b = b.substring(2);
        } else {
            b = b.substring(1);
        }
        if (typeof a == "number") {
            b = Number(b);
        } else if (typeof a == "string") {
            b = b.toLowerCase();
        }
        if (orEqual) {
            if (a > b) return false;
        } else {
            if (a >= b) return false;
        }
        continue;
        } else if (stringB.charAt(0) == "!") {
        b = b.substring(1);
        if (typeof a == "number") {
            b = Number(b);
        } else if (typeof a == "string") {
            b = b.toLowerCase();
        }
        var invert = true;
        }
        if (b == w) {
        if (invert) return false;
        else continue;
        }
        if (dojo.isString(a) && dojo.isString(b)) {
        if (b.charAt(b.length-1) == w)
            b = b.slice(0, -1);
        a = a.toLowerCase();
        b = b.toLowerCase();
        var matchIndex = a.indexOf(b);
        if (matchIndex == -1 ||
            matchIndex > 0 && matchStart) {
            if (!invert) return false;
        } else if (invert) {
            return false;
        }
        }
        else if (a !== b) {
        if (invert) continue;
        else return false;
        } else if (invert) {
        return false;
        }
    }
    return true;
    },
    */
    _queryItem: function(inItem, inSample, inIndex) {
        if (dojo.isArray(inSample)) {
            return dojo.some(inSample, function(inSampleElement) {
                return this._queryItem2(inItem, inSampleElement, inIndex);
            }, this);
        } else {
            return this._queryItem2(inItem, inSample, inIndex);
        }
    },
    _queryItem2: function(inItem, inSample, inIndex) {
        var w = "*";

        for (var key in inSample) {
            var matchStart = true;
            var matchEnd = true;
            var a = inItem.getValue(key);
            var b = inSample[key];
            if (typeof b == "function") {
                return b(a);
            } else if (b !== null && typeof b == "object" && wm.typeManager.isStructuredType(inItem._dataSchema[key].type)) {
                var aempty = (!a || a instanceof wm.Variable && a.isEmpty() || a instanceof wm.Variable === false && wm.isEmpty(a));
                var bempty = (!b || b instanceof wm.Variable && b.isEmpty() || b instanceof wm.Variable === false && wm.isEmpty(b));
                if (aempty != bempty) return false;
                if (aempty && bempty) continue;

                /* Don't even TRY to compare isList subvariables */
                if (a instanceof wm.Variable && a.isList) {
                    continue;
                }

                else {
                    var submatch = this._queryItem(a, b, 0);
                    if (!submatch) return false;
                    continue;
                }

            }

            /* NOTE: there is no "!true", rather, your query is either {a: true} or {a: false} to query on "truthiness" */
            else if (typeof b == "boolean") {
                if (Boolean(b) != Boolean(a)) return false;
                else continue; // all other tests beyond this if/else block are for strings
            } else {
                var stringB = String(b);
                if (stringB.charAt(0) == w) {
                    b = b.substring(1);
                    matchStart = false;
                } else if (stringB.charAt(0) == ">") {
                    var orEqual = false;
                    if (stringB.charAt(1) == "=") {
                        orEqual = true;
                        b = b.substring(2);
                    } else {
                        b = b.substring(1);
                    }
                    if (typeof a == "number") {
                        b = Number(b);
                    } else if (typeof a == "string") {
                        b = b.toLowerCase();
                    }
                    if (orEqual) {
                        if (a < b) return false;
                    } else {
                        if (a <= b) return false;
                    }
                    continue;
                } else if (stringB.charAt(0) == "<") {
                    var orEqual = false;
                    if (stringB.charAt(1) == "=") {
                        orEqual = true;
                        b = b.substring(2);
                    } else {
                        b = b.substring(1);
                    }
                    if (typeof a == "number") {
                        b = Number(b);
                    } else if (typeof a == "string") {
                        b = b.toLowerCase();
                    }
                    if (orEqual) {
                        if (a > b) return false;
                    } else {
                        if (a >= b) return false;
                    }
                    continue;
                } else if (stringB.charAt(0) == "!") {
                    b = b.substring(1);
                    if (typeof a == "number") {
                        b = Number(b);
                    } else if (typeof a == "string") {
                        b = b.toLowerCase();
                    }
                    var invert = true;
                }
            }
            if (b == w) {
                if (invert) return false;
                else continue;
            }
            if (dojo.isString(a) && dojo.isString(b)) {
                if (b.charAt(b.length - 1) == w) {
                    b = b.slice(0, -1);
                    matchEnd = false;
                }
                a = a.toLowerCase();
                b = b.toLowerCase();

                var matchIndex = a.indexOf(b);
                var isMatch = true;
                // No match at all
                if (matchIndex == -1) {
                    isMatch = false;
                }
                // Need to match both start and end, and the strings are not equal
                else if (matchStart && matchEnd && a != b) {
                    isMatch = false;
                }
                // Need to match the start, end is "*", and matchIndex starts is not zero then it fails
                else if (matchStart && !matchEnd && matchIndex > 0) {
                    isMatch = false;
                }
                // Need to match the end, but not the start, then matchIndex can be anything, but the
                // ends must be equivalent
                else if (!matchStart && matchEnd && a.lastIndexOf(b) + b.length != a.length) {
                    isMatch = false;
                }
                if (invert) isMatch = !isMatch;
                if (!isMatch) return false;
            } else if (a !== b) {
                if (invert) continue;
                else return false;
            } else if (invert) {
                return false;
            }
        }
        return true;
    },

    //===========================================================================
    // Update Messaging
    //===========================================================================
    dataRootChanged: function() {
        if (this._subNard || !this.owner) return;
        // find first owner after root and send change message on that.
        // this should trigger rule #3 for bindings.
        var o = this.owner,
            p, root = this.getRoot();
        while (o && o != root) {
            p = o;
            o = o && o.owner;
        }
        var n = p ? p.getRuntimeId() : this.getRuntimeId();
        var topic = n + "-rootChanged";
        wm.logging && console.group("<== ROOTCHANGED [", topic, "] published by Variable.dataRootChanged");
        dojo.publish(topic, [n]);

        var root = this.getRoot().getRuntimeId();
        if (root && root.indexOf(".") && n.indexOf(root) == 0) {
            var tmpn = n.substring(root.length);
            tmpn = root.substring(root.lastIndexOf(".") + 1) + tmpn;
            var topic2 = tmpn + "-rootChanged";
            if (topic2 != topic) {
                wm.logging && console.group("<== ROOTCHANGED [", topic2, "] published by Variable.dataRootChanged");
                dojo.publish(topic2, [n]);
            }
        }
        wm.logging && console.groupEnd();
    },
    dataOwnerChanged: function() {
        if (this._updating || !this.owner) return;
        var n = this.getRuntimeId();
        if (!n) return;
        var topic = n + "-ownerChanged";
        wm.logging && console.group("<== OWNERCHANGED [", topic, "] published by Variable.dataOwnerChanged");
        dojo.publish(topic, [n]);

        var root = this.getRoot();
        if (!root) return;
        var rootId = root.getRuntimeId();
        while(rootId && rootId.indexOf(".") && n.indexOf(rootId) == 0) {
            var tmpn = n.substring(rootId.length);
            tmpn = rootId.substring(rootId.lastIndexOf(".") + 1) + tmpn;
            var topic2 = tmpn + "-ownerChanged";
            if (topic2 != topic) {
                wm.logging && console.group("<== ROOTCHANGED [", topic2, "] published by Variable.dataRootChanged");
                dojo.publish(topic2, [n]);
                rootId = tmpn;
            } else {
                break;
            }
        }

        wm.logging && console.groupEnd();
        //
        // send root changed message
        if (this._allowLazyLoad) this.dataRootChanged();
        //
        var v = this.getCursorItem();
        for (var i in v.data) {
            wm.fire(v.data[i], "dataOwnerChanged");
        }
    },
    dataChanged: function() {
        if (this._updating || !this.owner) return;
        var id = this.getRuntimeId();
        if (!id) return;

        var topic = [id, "-changed"].join('');
        wm.logging && console.group("<== CHANGED [", topic, "] published by Variable.dataChanged");
        dojo.publish(topic, [this]);

        var root = this.getRoot();
        if (!root) return;
        var rootId = root.getRuntimeId();
        if (rootId && rootId.indexOf(".") && id.indexOf(rootId) == 0) {
            var tmpn = id.substring(rootId.length);
            tmpn = rootId.substring(rootId.lastIndexOf(".") + 1) + tmpn;
            var topic2 = tmpn + "-changed";
            if (topic2 != topic) {
                wm.logging && console.group("<== ROOTCHANGED [", topic2, "] published by Variable.dataRootChanged");
                dojo.publish(topic2, [this]);
            }
        }



        // Rule: change notification is propagated up through owners
        // propagate change up only if this is a subNard.
        if (this._subNard) wm.fire(this.owner, "dataChanged");
        wm.logging && console.groupEnd();
    },
    updatePermanentMemory: function() {
        /* Don't update permanent memory with values set while loading the page; these
         * are unlikely to be provided as a result of dynamic user or service based calls
         */
        var ownerPage = this.getParentPage();
        if (ownerPage && ownerPage._loadingPage) return;

        if (window["PhoneGap"] && this.saveInPhonegap) {
            var datatext = dojo.toJson(this.getData());
            window.localStorage.setItem(this.getRuntimeId(), datatext);
        } else if (this.saveInCookie) {
            var datatext = dojo.toJson(this.getData());
            dojo.cookie(this.getRuntimeId(), datatext);
        }
    },
    // id-based notification
    dataValueChanged: function(inProp, inValue) {
        if (!this._updating && this.owner) {
            // Can't simply call valueChanged; see note below.
            wm.Component.prototype.valueChanged.call(this, inProp, inValue);
            this.notify();
            this.updatePermanentMemory();
        }
    },
    // id-based notification
    valueChanged: function(inProp, inValue) {
        if (!this.type || this.type == this.declaredClass) return; // if it doesn't yet have any type information, then nobody wants to listen to changes to this component

        // Code exists to deal with collisions between component props and data props in this class.
        // However, the distinction is lost in change notifications. Likely, data props should have
        // special ids to distinguish them. Until then, we simply avoid sending change notification
        // for properties when there is a collision.
        if (!this.isDataProp(inProp))
            this.inherited(arguments);
    },
    //===========================================================================
    // Referencing
    //===========================================================================
    /*
    setDataSet: function(inDataSet) {
        this.dataSet = "";
        if (inDataSet instanceof wm.Variable) {
                this.setType(inDataSet ? inDataSet.type : "wm.Variable", true);
            this.dataSet = inDataSet;
            this.cursor = inDataSet.cursor;
        }
        this.setData(inDataSet);
    },
    */
        getDataSet: function() {
        return this.dataSet || this;
/*
        if (this.dataSet) return this.dataSet;
        else if (!this._isDesignLoaded)
        return this;
        */
    },
    //===========================================================================
    // Property API
    //===========================================================================
    _isVariableProp: function(inPropName) {
        var typeInfo = this._dataSchema[inPropName];
        return Boolean(typeInfo && (typeInfo.isList || wm.typeManager.isStructuredType(typeInfo.type)));
    },
    isDataProp: function(inProp) {
        return inProp in this._dataSchema;
    },
    _getValue: function(inProp) {
        return this.isDataProp(inProp) ? this._getDataValue(inProp) : this.inherited(arguments);
    },
    _setValue: function(n, v) {
        // if setting to default, then don't do data setting
        if ((this._isDesignLoaded && this.schema[n]||0).defaultBindTarget || !this.isDataProp(n))
            this.inherited(arguments);
        else
            this._setDataValue(n, v);
    },
    //===========================================================================
    // Data Marshalling / Lazy Loading
    //===========================================================================
    createVariable: function(inProps, inPropName) {
        if ((window["studio"] || djConfig.isDebug) && inProps.type && !wm.typeManager.getType(inProps.type)) {
        app.toastWarning("A variable of type " + inProps.type + " has been created, but that type does not exist");
        }
        inProps._temporaryComponent = 1;
        if (!inProps.name) {
        inProps.name = this._uniqueSubnardId;
        this._uniqueSubnardId++;
        }
        var v = new wm.Variable(inProps);
        v.owner = this;
        return v;
    },
    marshallVariable: function(inPropName, inTypeInfo, inVariable) {
        var
            p = inPropName, v = inVariable,
            t = inTypeInfo.isList ? '[' + inTypeInfo.type + ']' : inTypeInfo.type;
        if (!(v instanceof wm.Variable)) {
            v = this.createVariable({name: p, type: t, _subNard: true}, p);
            if (inVariable || inVariable === null) {
                v.beginUpdate();
                v.setData(inVariable);
                v.endUpdate();
            }
        }
        // lazy load!
        if (v._isStub() && this.canLazyLoad(inTypeInfo)) {
            this.beginUpdate();
                this.lazyLoadData(p, v);
            this.endUpdate();
        }
        return v;
    },
    _isStub: function() {
        if (!this._nostub && !this._isNull /*&& (!this.isList || !this.hasList())*/) {
            // stub if there is no data
            if (this.data === undefined)
                return true;
            // stub if we're a list and there's no list data
            if (this.isList || this.hasList())
                return !this.data._list || !this.data._list.length;
            // optionally treat as stub if there is any data v. if there is missing data
            // stub if dont' have data for any property not structured / list
            if (this._greedyLoadProps) {
                var schema = this._dataSchema, s;
                for (var i in schema) {
                    s = schema[i];
                    if (!s.isList && (this.data[i] === undefined)
                        && !wm.typeManager.isStructuredType(s.type))
                        return true;
                }
            // stub if we have no data
            } else if (wm.isEmpty(this.data))
                return true;
        }
        this._nostub = true;
        return false;
    },
    lazyLoadData: function(inPropName, inVariable) {
        var s = wm.getRuntimeService(this), v = inVariable;
        try{
            if (s.ready) {
                var d = this.getData();
                if (!wm.isEmpty(d)) {
                    var args = [null, this.type, d, {properties: [inPropName]}];
                    wm.logging && console.log("lazyLoad", inVariable.owner && inVariable.owner.getId(), args);
                    var f = function(r) {
                      var propData = r && r[inPropName];
                      if (propData) {
                        v.beginUpdate();
                        v.setData(propData);
                        v.endUpdate();
                      }
                    }

                    // NOTE: Default is that async doesn't have a value; this feature seems unreliable so far so don't use
                    var d;
                    if (this.async) {
                      d = s.requestAsync("read", args);
                    } else {
                        d = s.requestSync("read", args);
                    }
                    d.addCallback(dojo.hitch(this, function() {
                    f();
                    }));

                };
            }
        }catch(x){}
    },
    canLazyLoad: function(inTypeInfo) {
        if (this._updating || !wm.typeManager.getLiveService(this.type) || !wm.typeManager.getLiveService(inTypeInfo.type))
            return;
        // FIXME: prevent lazy loading if livelayout is not ready
        // reference to studio especially bad.
        if (this.isDesignLoaded() && !studio.isLiveLayoutReady())
            return false;
        var o = this;
        // if this variable or any owner does not allow lazy loading then cannot lazy load!
        while (o instanceof wm.Variable) {
            if (!o._allowLazyLoad || wm.disableLazyLoad)
                return false;
            o = o.owner;
        }
        // lazy load if the type is a list or we have required data to read.
        return inTypeInfo.isList || this._hasRequiredReadData();
    },
    // check our schema and data to see if
    // we have all necessary data that is required
    // for the lazy load "read" operation
    _hasRequiredReadData: function() {
        var ds = this._dataSchema, s, d;
        for (var i in ds) {
            s = ds[i];
            if (s.include && dojo.indexOf(s.include, "read") > -1) {
                d = this.data[i];
                if (d === undefined || d === null)
                    return false;
            }
        }
        return true;
    },

    toString: function(inText) {
    var t = inText || "";
    var isEmpty =  this.isEmpty();
    t += "; " + wm.getDictionaryItem("wm.Variable.toString_TYPE", {type: this.type}) + "; " + wm.getDictionaryItem("wm.Variable.toString_ISEMPTY", {isEmpty: isEmpty});
    return this.inherited(arguments, [t]);
    },
    _end: 0
});

// FIXME: variable should have a data loader which can optionally have a liveView.
// A difficulty is that liveView is responsible both for data to load and storing field info
// that can be used to create ui.
// The issue is made worse by the need to copy variables (and associated liveViews)
// extension to extend Variable to load data with a liveView
wm.Variable.extend({
    _includeListProps: false,
    createVariable: function(inProps, inPropName) {
        inProps = inProps || {};

        if ((window["studio"] && this.isDesignLoaded() || !window["studio"] && djConfig.isDebug) && inProps.type && !this._dataSchema) {
        app.alert(wm.getDictionaryItem("wm.Variable.TYPE_INVALID", {type: inProps.type.replace(/[\[\]]/g,""), name: this.getRuntimeId()}));
        }
        if (!inProps.name) {
        inProps.name = this._uniqueSubnardId;
        this._uniqueSubnardId++;
        }

            inProps._temporaryComponent = 1;
        inProps.liveView = this.liveView;
        var r = this._rootField, n = inPropName;
        inProps._rootField = r && inPropName ? r + "." + inPropName : (inPropName || "");
        var v = new wm.Variable(inProps);
        //v.owner = this;
            v.setOwner(this, true);
        return v;
    },
    setDataSet: function(inDataSet) {
        this.dataSet = "";
        if (inDataSet instanceof wm.Variable) {
            this._rootField = inDataSet._rootField || "";
                if (inDataSet.liveView) {
                this.setLiveView(inDataSet.liveView);
            }
                this.setType(inDataSet ? inDataSet.type : "wm.Variable", true);
            this.dataSet = inDataSet;
            this.cursor = inDataSet.cursor;
        }
        this.setData(inDataSet);
    },
    _getEagerProps: function(inVariable) {
        var
            v = inVariable,
            props = this.liveView ? this.liveView.getSubRelated(v._rootField) : [],
            schema = wm.typeManager.getTypeSchema(v.type);
        return this._includeListProps ? props :
            dojo.filter(props, function(r) {
                return !wm.typeManager.isPropInList(schema, r);
            });
    },
    _getLoadProps: function(inPropName, inVariable) {
        return [inPropName].concat(dojo.map(this._getEagerProps(inVariable), function(r) {
            return [inPropName, r].join(".");
        }));
    },
    // FIXME: avoid sync request
    lazyLoadData: function(inPropName, inVariable) {
        var s = wm.getRuntimeService(this), v = inVariable;
        try{
            if (s.ready) {
                var d = this.getData();
                if (!wm.isEmpty(d)) {
                    var
                        //props = this.liveView ? this._getLoadProps(inPropName, v) : inPropName,
                                props = this._getLoadProps(inPropName, v),
                        args = [null, this.type, d, {properties: props}];
                    //console.log("lazyLoad", this.getId(), args);
                    wm.logging && console.log("lazyLoad", inVariable.owner && inVariable.owner.getId(), args);

                    var f = function(r) {
                      var propData = r && r[inPropName];
                      if (propData) {
                        v.beginUpdate();
                        v.setData(propData);
                        v.endUpdate();
                      }
                    }

                    if (this.async) {
                      s.requestAsync("read", args, f);
                    } else {
                      s.requestSync("read", args);
                      f(s.result);
                    }


                    // FIXME: non-sync, need to protect against multiple requests?
                    // create a queue of requests?
                    /*if (!this._inflight) {
                        var def = s.requestAsync("read", args);
                        this._inflight = true;
                        def.addBoth(dojo.hitch(this, function(r) {
                            this._inflight = false;
                            return r;
                        }));
                        def.addCallback(dojo.hitch(this, function(r) {
                            var propData = r && r[inPropName];
                            if (propData) {
                                v.beginUpdate();
                                v.setData(propData);
                                v.endUpdate();
                                console.log("got data!", "notify!", this.getId(), this._updating);
                                this.owner.notify();
                            }
                            return r;
                        }));
                    }*/
                }
            }
        }catch(x){
            wm.logging && console.log("Failed to lazy load.", args);
        }
    },
    setLiveView: function(inLiveView) {
        this.liveView = inLiveView;
    },
    getViewType: function() {
        return this.liveView  && this.liveView.getSubType(this._rootField);
    },
    getViewFields: function() {
        return (this.liveView && this.liveView.getSubView(this._rootField)) || [];
    },
    getViewListFields: function() {
        return (this.liveView && this.liveView.getListView(this._rootField)) || [];
    },
    getViewRelated: function() {
        return (this.liveView && this.liveView.getSubRelated(this._rootField)) || [];
    }
});



/**#@- @design */

if (0) {
/******
 * this extends wm.Variable to implement the dojo.data.api.Read APIs
 ******/
wm.Variable.extend({
    /* http://dojotoolkit.org/reference-guide/dojo/data/api/Read.html#dojo-data-api-read */
    getFeatures: function() {
    return {
        "dojo.data.api.Read": true
    };
    },

    /*
     * this getValue violates the dojo.data API by not throwin exceptions if inItem is not an item or inAttribute is not a string.
     * Violation is because getValue calls this.inherited in if its not an item
     */
    getValue: function(inItem, inAttribute, defaultValue) {
    if (this.isItem(inItem)) {
        /* This works, but as soon as we get a new dataset from the server, or if the user sorts the variable,
         * all IDs change, so really this is bad
         */
        if (inAttribute == "_id") {
        return inItem.getIndexInOwner();
        }
        console.log(inItem);
        console.log(inAttribute);
        var result = inItem.getValue(inAttribute);
        if (result === undefined)
        result = defaultValue;
        return result;
    } else {
        return this.inherited(arguments);
    }
    },
    getValues: function(inItem, inAttribute) {
    if (this.isItem(inItem) && typeof inAttribute == "string") {
        var result = this.getValue(inItem, inAttribute);
        return [result];
    } else {
        throw "getValues must have a wm.Variable as input; and inAttribute must be a String; perhaps you want getValue?";
    }
    },
    getAttributes: function(inItem) {
    if (this.isItem(inItem)) {
        var type = wm.typeManager.getType(inItem.type);
        var result = [];
        if (type && type.fields) {
        for (var field in type.fields) {
            result.push(field);
        }
        }
        if (!this.identity) {
        result.push("_id");
        }
        return result;
    } else {
        throw "getAttribute must have a wm.Variable as an input";
    }
    },

    hasAttribute: function(inItem, inAttribute) {
    if (this.isItem(inItem) && typeof inAttribute == "string") {
        var value = inItem.getValue(inItem, inAttribute);
        return !(value === undefined || value === null);
    } else {
        throw "getValues must have a wm.Variable as input; and inAttribute must be a String.";
    }
    },

    containsValue: function(inItem, inAttribute, inValue) {
    var values = this.getValues(inItem, inAttribute);
    return dojo.indexOf(values, inValue) != -1;
    },


    isItem: function(inItem) {
    return inItem instanceof wm.Variable;
    },

    /* This is just a placeholder and is not yet implemented */
    isItemLoaded: function(inSomething) {
    return false;
    },

    /* This is just a placeholder and is not yet implemented */
    loadItem: function(keywordArgs) {
    return null;
    },


    /* This method was copied from the basic parts of ItemFileReadStore.js _fetchItems method;
     * I've stripped out the regex stuff which while very cool, would not typically be used and slow things down
     */
    _fetchItems: function(  /* Object */ requestArgs,
    /* Function */ findCallback,
    /* Function */ errorCallback){
    //  summary:
    //      See dojo.data.util.simpleFetch.fetch()

    var opts = requestArgs.queryOptions;
    var items = [];
    var i, key;
    if(requestArgs.query){
        /* Uncomment out the regex stuff if we ever have a need for it; this is dojo's code, probably good, but
         * not needed, and therefore just slows things down
        var value,
        ignoreCase = requestArgs.queryOptions ? requestArgs.queryOptions.ignoreCase : true;
        //See if there are any string values that can be regexp parsed first to avoid multiple regexp gens on the
        //same value for each item examined.  Much more efficient.
        var regexpList = {};
        for(key in requestArgs.query){
        value = requestArgs.query[key];
        if(typeof value === "string"){
            regexpList[key] = dojo.data.util.filter.patternToRegExp(value, ignoreCase);
        }else if(value instanceof RegExp){
            regexpList[key] = value;
        }
        }
        */
        var count = this.getCount();
        for(i = 0; i < count; ++i){
        var match = true;
        var candidateItem = this.getItem(i);
        if(candidateItem instanceof wm.Variable == false){
            match = false;
        }else{
            for(key in requestArgs.query){
            value = requestArgs.query[key];
            if(value != "*" && !this._containsValue(candidateItem, key, value, opts)){
                match = false;
            }
            }
        }
        if(match){
            items.push(candidateItem);
        }
        }
        findCallback(items, requestArgs);
    } else {
        // We want a copy to pass back in case the parent wishes to sort the array.
        // We shouldn't allow resort of the internal list, so that multiple callers
        // can get lists and sort without affecting each other.  We also need to
        // filter out any null values that have been left as a result of deleteItem()
        // calls in ItemFileWriteStore.
        var count = this.getCount();
        for(i = 0; i < count; ++i){
        var item = this.getItem(i);
        if(item !== null){
            items.push(item);
        }
        }
        findCallback(items, requestArgs);
    }
    },

    /* This method was copied from the basic parts of ItemFileReadStore.js _fetchItems method;
     * I've stripped out the regex stuff which while very cool, would not typically be used and slow things down
     */
    _containsValue: function(
        /* item */ item,
        /* attribute-name-string */ attribute,
        /* anything */ value,
    /* Hash with queryOptions */ opts){
        //  summary:
        //      Internal function for looking at the values contained by the item.
        //  description:
        //      Internal function for looking at the values contained by the item.  This
        //      function allows for denoting if the comparison should be case sensitive for
        //      strings or not (for handling filtering cases where string case should not matter)
        //
        //  item:
        //      The data item to examine for attribute values.
        //  attribute:
        //      The attribute to inspect.
        //  value:
        //      The value to match.
        //  opts
        //      The query options; supports exactMatch, ignoreCase; later on should have startsWith, contains and endsWith
        var svalue = String(value);
        var itemvalue = item.getValue(attribute);
        var sitemvalue = String(itemvalue);
        if (value === itemvalue) return true; // quick test...

        if (opts.ignoreCase) {
        if (svalue.toLowerCase() === sitemvalue.toLowerCase())
            return true;
        }

        if (!opts.exactMatch) {
        if (svalue.indexOf(sitemvalue) != -1)
            return true;
        }
        return false;
    },


    // no-op
    close: function(inRequestToClose) {},

    // Before getLabel does more than return undefined, we'll need to decide users should get displayField/displayExpression properties
    getLabel: function(inItem) {
    if (this.displayField) {
        return inItem.getValue(this.displayField);
    } else if (this.displayExpression) {
        return wm.expression.getValue(this.displayExpression, inItem, this.getRoot());
    } else {
        return undefined;
    }
    },


    getLabelAttributes: function(inItem) {
    if (this.displayField) {
        return [this.displayField];
    } else if (this.displayExpression) {
        var results = this.displayExpression.match(wm.expression._getSourceRegEx);
        for (var i = 0; i < results.length; i++) {
        results[i] = results[i].substring(2, results[i].length-1);
        }
        return results;
    } else {
        return this.getAttributes();
    }
    },
    _end: 0
});
// uncomment this when ready to use wm.Variable as a dojo.store: dojo.extend(wm.Variable,dojo.data.util.simpleFetch); // adds in the fetch call


/******
 * this extends wm.Variable to implement the dojo.data.api.Identity APIs
 ******/
wm.Variable.extend({
    getFeatures: function() {
    return {
        "dojo.data.api.Read": true,
        "dojo.data.api.Identity": true
    };
    },
    getIdentity: function(inItem) {
    if (this.identity)
        return inItem.getValue(this.identity);
    else
        return inItem.getIndexInOwner();
    },

    getIdentityAttributes: function(inItem) {
    if (this.identity) {
        return [this.identity];
    } else {
        return ["_id"];
    }
    },

    fetchItemByIdentity: function(/* object */ keywordArgs){
    var item = this.getItem(keywordArgs.identity);
    if (item) {
        keywordArgs.onItem.call(keywordArgs.scope || dojo.global, item, keywordArgs);
    } else {
        keywordArgs.onError.call(keywordArgs.scope || dojo.global, keywordArgs);
    }
    },
    _end: 0
});





wm.Variable.extend({
    forEachItem: function(callback, options) {
    if (!options)
        option = {count: 0,
              stopOnTrue: false};
    var stopOnTrue = options.stopOnTrue;
    var count = this.getCount();
    for (var i = options.start || 0; i < count; i++) {
        var item = this.getItem(i);
        if (callback(item) && stopOnTrue) {
        return;
        }
    }
    },
    get: function(id) {
    var keys = this.primaryKeyFields.split(/\s*,\s*/);
    var query = {};
    if (keys.length == 0)
        return null;
    for (var i = 0; i < keys.length; i++) {
        if (id instanceof wm.Variable) {
        query[keys[i]] = id.getValue(keys[i]);
        } else if (id !== null && typeof id == "object") {
        query[keys[i]] = id[keys[i]];
        } else {
        query[keys[i]] = id;
        }
    }
    return this.query(query, {limit: 1}).matches[0];
    },

    query: function(query, options){
    var results = [];

    var compareFields = function(val1, val2, options) {
        if (options.ignoreCase) {
        val1 = val1.toLowerCase();
        val2 = val2.toLowerCase();
        }
        if (val1 == val2)
        return true;
        else if (!options.exactMatch && typeof val1 == "string" && val1.indexOf(val2) == 0)
        return true;
        return false;
    };

    this.forEachItem(
        function(item) {
        for (key in query) {
            var value = query[key];
            if (value instanceof wm.Variable) {
            value = value.getValue(query[key]);
            } else if (value != null && typeof value == "object") {
            value = value[query[key]];
            }
            if (!compareFields(value, item.getValue(query[key]), options))
            return false;
        }
        result.push(item);
        return options.count ? result.length < options.count : false;
        },
        {stopOnTrue: true, start: options.start || 0}
    );
    return {total: result.length,
        matches: result,
        forEach: function(callback, thisobj) {
            return dojo.forEach(results, callback, thisobj);
        },
        filter: function(callback, thisobj) {
            return dojo.filter(results, callback, thisobj);
        },
        map: function(callback, thisobj) {
            return dojo.map(results, callback, thisobj);
        }
           };
    },
    put: function(data, options) {
    this.addItem(data);
    },
    remove: function(id) {
    var item = this.get(id);
    if (item) {
        var index = this.getItemIndex(item);
        if (index != -1)
        this.removeItem(index);
    }
    },
    getIdentity: function(item) {
    var keys = this.primaryKeyFields.split(/\s*,\s*/);
    var result = "";
    for (var i = 0; i < keys.length; i++) {
        if (result) result += "|";
        result += item.getValue(keys[i]);
    }
    return result;
    },
    getChildren: function(item) {
    var result = [];
    var schema = this._dataSchema;
    for (var i in schema) {
        var s = schema[i];
        if (s.isList || wm.typeManager.isStructuredType(s.type)) {
        result.push(item.getValue(i));
        }
    }
    return {total: result.length,
        matches: result,
        forEach: function(callback, thisobj) {
            return dojo.forEach(results, callback, thisobj);
        },
        filter: function(callback, thisobj) {
            return dojo.filter(results, callback, thisobj);
        },
        map: function(callback, thisobj) {
            return dojo.map(results, callback, thisobj);
        }
           };
    }

});
}

}

if(!dojo._hasResource["wm.base.components.Service"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.components.Service"] = true;
 /*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide("wm.base.components.Service");


/**
	Component that can be configured to perform a task.
	<br/><br/>
	@name wm.Service
	@class
	@extends wm.Component
*/
dojo.declare("wm.Service", wm.Component, {
	/** @lends wm.Service.prototype */
	_operations: {},
	/**
		Result data (if any) returned from the last invocation.
	*/
	result: null,
	/**
		Error data (if any) returned from the last invocation.
	*/
	error: null,
	getOperationsList: function() {
		var l = [];
		for (var i in this._operations)
			l.push(i);
		l.sort();
		return l;
	},
	makePropEdit: function(inName, inValue, inEditorProps) {
	    var prop = this.schema ? this.schema[inName] : null;
	    var name =  (prop && prop.shortname) ? prop.shortname : inName;
		switch (inName) {
		case "operation":
		    return new wm.SelectMenu(dojo.mixin(inEditorProps, {options: this.getOperationsList()}));
		}
	},
	getOperation: function(inOperation) {
		return this._operations[inOperation];
	},
	initService: function() {
	},
	/**
		Invoke a method on this service object with arguments.
		<br/><br/>
		Invocations may be asynchronous. Responses are available 
		via the returned Deferred object or from the 
		<a href="#onResult">onResult</a> and 
		<a href="#onError">onError</a> events.
		@param {String} inMethod The method to invoke on this object.
		@param {Array} inArgs An array of parameters for the method.
		@returns {dojo.Deferred} Response handler object.
	*/
        invoke: function(inMethod, inArgs, inOwner) {
		var
			d = new dojo.Deferred(),
			m = this[inMethod];
		if (m) {
			var result = m.apply(this, inArgs);
			this.onResult();
			wm.onidle(function() {
				d.callback(result);
			});
		} else {
			this.onError();
			wm.onidle(function() {
			    /* TODO: Localize */
			    d.errback("operation: " + inMethod + " does not exist.");
			});
		}
		return d;
	},
	/**
		Event that fires after a succesful service invocation.
		@param {Any} inResult Any result data returned from the service.
	*/
	onResult: function(inResult) {
		this.error = null;
		return this.result = inResult;
	},
	/**
		Event that fires after a service invocation has resulted in an error.
		@param {Any} inError Any error data returned from the service.
	*/
	onError: function(inError) {
		this.result = null;
		return this.error = inError;
	}
});

// FIXME: needs its own module
// ==========================================================
// Services registry (provides info about available services)
// ==========================================================

wm.services = {

    // Hash naming/describing all services; use _services for the actual Service instance. This hash provides the name and type for each service
	byName: {},

    // When a ServiceCall needs a service instance, _createService creates one and stores it in this hash
    _services: {},
	add: function(inService){
		return wm.services.byName[inService.name] = inService;
	},
	remove: function(inService){
		var n = inService.name;
		this._destroyService(n);
        delete wm.services._services[n];
		delete wm.services.byName[n];
	},
	getNamesList: function() {
		var l = [], services = wm.services.byName, s;
		for (var i in services) {
			s = services[i];
			if (!s.clientHide) 
				l.push(i);
		}
		l.sort();
		return l;
	},
	forEach: function(inFunction) {
		wm.forEach(this.byName, function(s) {
			inFunction(s);
		});
	},
	clear: function() {
		var n = wm.services.byName, s;
		for (var i in n) {
			s = n[i];
			if (!s.isClientService)
				this.remove(s);
			else
				this._destroyService(s);
		}
	},
        getService: function(inName, hideFromClient) {
		var s;
		if (inName) {
		    if (this._services[inName]) {
			s = this._services[inName]; 
		    } else {
			s = this._services[inName] = this._createService(inName, hideFromClient);
		    }
		    if (!s._service) {
			s.initService();
		    }
		}
		return s;
	},
       _createService: function(inName, hideFromClient) {
		var
			defaultCtor = "wm.JsonRpcService",
			s = this.byName[inName];
		if (!s)
		    s = this.add({name: inName, ctor: defaultCtor, clientHide: hideFromClient});
		var ctor = dojo.getObject(s.ctor || defaultCtor);
		// FIXME: we don't want to be streamed so don't include owner
		// otoh without owner, we don't know how to resolve paths at designTime
	   var owner = window["studio"] ? studio.application || studio._application : app;
	   var service = new ctor({name: inName, service: inName, owner: owner});
	   //service.owner = dojo.getObject("studio.wip.app") || app;
		return service;
	},
	_destroyService: function(inService) {
		wm.fire(this._services[inService.name], "destroy");
	}
};
wm.Object.extendSchema(wm.Service, {
    operation: {type: "string"}
});

}

if(!dojo._hasResource["wm.base.components.ServiceQueue"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.components.ServiceQueue"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide("wm.base.components.ServiceQueue");

dojo.declare("wm.ServiceQueue", wm.Component, {
	services: "",
	init: function() {
		this._services = [];
		this._serviceConnections = [];
		this.inherited(arguments);
	},
	getServicesCount: function() {
		return this._services && this._services.length;
	},
	getServicesList: function() {
		for (var i=0, l=[], ss=this.services.split(","), s, v; (s=ss[i]); i++) {
			v = this.getValueById(dojo.string.trim(s));
			if (v)
				l.push(v);
		}
		return l;
	},
	update: function() {
		this.beginUpdate();
	},
	beginUpdate: function() {
		this._services = this.getServicesList();
		this.connectServices();
		this._currentService = 0;
		this.updateNextService();
	},
	getCurrentService: function() {
		return this._services[this._currentService];
	},
	updateNextService: function() {
		if (this._currentService < this.getServicesCount()) {
			var s = this.getCurrentService();
			this._currentService++;
			s.update();
		} else
			this.completeUpdate();
	},
	completeUpdate: function() {
		this.disconnectServices();
	},
	abortUpdate: function() {
		this.disconnectServices();
	},
	connectServices: function() {
		this.disconnectServices();
		dojo.forEach(this._services, dojo.hitch(this, function(s) {
			this._serviceConnections.push(dojo.connect(s, "onResult", this, "updateNextService"));
			this._serviceConnections.push(dojo.connect(s, "onError", this, "abortUpdate"));
		}));
	},
	disconnectServices: function() {
		dojo.forEach(this._serviceConnections, function(s) {
			dojo.disconnect(s);
		});
	}
});

wm.ServiceQueue.extend({
	getAvailableServicesList: function() {
		var d = wm.listComponentIds([studio.application, studio.page], wm.ServiceVariable);
		d = d.concat(wm.listComponentIds([studio.application, studio.page], wm.NavigationCall));
		// don't show this!
		var i = dojo.indexOf(d, this.owner.getId());
		if (i != -1)
			d.splice(i, 1);
		return d;
	},
	write: function(inIndent) {
		return this.services ? this.inherited(arguments): null;
	}
});

}

if(!dojo._hasResource["wm.base.components.ServiceCall"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.components.ServiceCall"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide("wm.base.components.ServiceCall");



//===========================================================================
// Provides basic service calling infrastructure
//===========================================================================
// Note: wm.ServiceCall is not a component. This primarily so that it can be combined
// with components that have other capabilities.
/**
    Infrastructure for encapsulating a {@link wm.Service} configuration with a trigger
    to invoke the configured service.
    @name wm.ServiceCall
    @class
    @noindex
*/
dojo.declare("wm.ServiceCall", null, {
    /** @lends wm.ServiceCall.prototype */
    /**
        Set true to automatically <a href="#update">update</a> this service when
        the service configuration or input is modified.
        @type String
    */
    autoUpdate: false,
    /**
        Set true to automatically <a href="#update">update</a> this service when it's created.
        @type String
    */
    startUpdate: false,

    /* Change to true once startUpdate has called update() */
    _startUpdateComplete: false,
    /**
        Name of the service called by this object.
        @type String
    */
    service: "",
    /**
        Name of the operation to invoke on the service.
        @type String
    */
    operation: "",
    _operationInfo: {},
    disabled: false,
    inFlightBehavior: "none",

    destroy: function() {
        delete this._inFlightBacklog;
        wm.fire(this._requester, "cancel");
        delete this._requester;
        this.inherited(arguments);
    },
    init: function() {
        this.inherited(arguments);
        this._inFlightBacklog = [];
        if (this._isDesignLoaded) {
            this.subscribe("wmservices-changed", dojo.hitch(this, "servicesChanged"));
        }
    },
    postInit: function() {
        this.inherited(arguments);
        this.connectStartUpdate();
        if (!this.$.queue) new wm.ServiceQueue({name: "queue", owner: this});

        this.initInput();
        this.setService(this.service);
        this._setOperation(this.operation);
    },
    initInput: function() {
        this.input = this.$.input;
        if (!this.input) this.input = this.createInput();
        this.subscribe(this.input.getRuntimeId() + "-changed", this, "inputChanged");
    },
    /* Shortcut for setting the input */
    setInput: function(inDataSet) {
        if (this.$.input) {
            this.$.input.setDataSet(inDataSet);
        }
    },
    /* Sets the service for the ServiceCall, and updates its operation and operationInfo and inputs */
    setService: function(inService) {
        if (this._inSetService) return; /* Avoid infinite recursion */
        try {
            this._inSetService = true;
            this.service = inService;
            var owner = this.getOwnerApp();

            this._service = wm.services.getService(this.service, owner && owner.declaredClass == "StudioApplication") || new wm.Service({});
            wm.fire(this._service, "setServiceCall", [this]);
            this._setOperation(this.operation, 1); // update the operation's type; forceUpdate needed so that if the type name is the same but fields have changed it will still get updated
        } catch (e) {
        } finally {
            delete this._inSetService;
        }
    },
    set_service: function(inService) {
        this.setService(inService);

        var s = this._service;
        var valueOk = s && s.getOperation(this.operation);
        if (!valueOk) {
            var methods = s && s.getOperationsList();
            var newValue = methods ? methods[0] : "";
            if (newValue && newValue != this.operation) {
                this.set_operation(newValue);
            }
        }
        studio.inspector.refocusEditor();
    },
    /* If the types have changed, reobtain our type and input type and operations info.  Design time only */
    wmTypesChanged: function() {
        var owner = this.getOwnerApp();
        this._service = wm.services.getService(this.service, owner && owner.declaredClass == "StudioApplication") || new wm.Service({});
        wm.fire(this._service, "setServiceCall", [this]);
        this._setOperation(this.operation, 1); // update the operation's type; forceUpdate needed so that if the type name is the same but fields have changed it will still get updated
        if (this.setType) this.setType(this.type);
        if (studio.isSelected(this)) {
            studio.inspect(this);
        }
    },

    /* Set the operation and update the inputs */
    _setOperation: function(inOperation, forceUpdate) {
        this.operation = inOperation;
        this._operationInfo = this.getOperationInfo(this.operation);
        this.operationChanged(forceUpdate);
    },

    /* Sets the operation and updates the data if autoUpdate is set */
    setOperation: function(inOperation) {
        this._setOperation(inOperation);
        this.doAutoUpdate();
    },

    /* Get the parameters for the operation */
    getOperationInfo: function(inOperation) {
        return (this._service && this._service.getOperation(inOperation)) || {};
    },

    /* Force the input to update its fields */
    operationChanged: function(forceUpdate) {
        this.input.operationChanged(this.operation, this._operationInfo.parameters);
    },

    /* Create the ServiceInput component */
    createInput: function() {
        var i = new wm.ServiceInput({name: "input", owner: this });
        i.operationChanged(this.operation, this._operationInfo.parameters);
        return i;
    },

    /* Any time the input is changed, fire doAutoUpdate() */
    inputChanged: function() {
        this.doAutoUpdate();
    },

    /* Fire doStartUpdate when the page finishes loading.
     * NOTE: If owner is a Composite or Application, this may not work
     */
    connectStartUpdate: function() {
        if (this.owner && this.owner instanceof wm.Application) {
            this.doStartUpdate();
        } else if (this.owner && this.owner.start) {
            this.connectOnce(this.owner, "onStart", this, "doStartUpdate");
        }
    },

    /* Changes autoUpdate, and optionally calls update() */
    setAutoUpdate: function(inAutoUpdate) {
        this.autoUpdate = inAutoUpdate;
        this.doAutoUpdate();
    },

    /* Chagnes startUpdate, and optionally cals update */
    setStartUpdate: function(inStartUpdate) {
        this.startUpdate = inStartUpdate;
        if (this.startUpdate && !this._loading && this.isDesignLoaded()) {
            this.updateInternal();
        }
    },

    /* Don't fire startUpdate if the component already has data saved from a previous session using the phonegap saveInPhoneGap property,
     * unless autoUpdate is also selected.
     * Not done for saveInCookie because saveInCookie is intended for saving much smaller chunks of data, and not entire server queries.
     * saveInCookie is probably disabled for ServiceVariables.
     */
    canStartUpdate: function() {
        return this.startUpdate && !this._loading && (!window["PhoneGap"] || !this.saveInPhoneGap || this.isEmpty() || this.autoUpdate);
    },

    /* Call udpate if startUpdate is true */
    doStartUpdate: function() {
        if (this.canStartUpdate()) {
            this.updateInternal();
            this._startUpdateComplete = true;
        }
    },

    /* Don't fire autoUpdate if startUpdate is true and hasn't yet set _startUpdateComplete to true */
    canAutoUpdate: function() {
        return (this.autoUpdate && !this._loading && (!this.startUpdate || this._startUpdateComplete || this.isDesignLoaded()));
    },

    /* Call update if autoUpdate is true */
    doAutoUpdate: function() {
        if (this.canAutoUpdate()) {
            /* wait 20ms so that UI events can finish firing and so other inputs have time to be set */
            wm.job(this.getRuntimeId() + ".doAutoUpdate", wm.isMobile ? 20 : 1, dojo.hitch(this, "updateInternal"));
        }
    },

    /* Public method for firing the service call */
    update: function() {
        // moved to RBacPlugin; if (djConfig.isDebug) try { this.log("update", arguments.callee.caller.nom || arguments.callee.caller.name || "anonymous");} catch(e) {}
        return this._isDesignLoaded ? this.doDesigntimeUpdate() : this._update();
    },

    /* Users call "update" event handlers and autoUpdate/startUpdate call updateInternal; used for tracking/debugging purposes */
    updateInternal: function() {
        return this._isDesignLoaded ? this.doDesigntimeUpdate() : this._update();
    },

    /* If the ServiceCall is already firing, it can't fire the current request; add it to our request queue
    * if inFlightBehavior specifies to do so.
    */
    addToBacklog: function() {
        var d = new dojo.Deferred();
        if (this.inFlightBehavior == "executeLast") this._inFlightBacklog.pop();
        if (this.inFlightBehavior == "executeLast" || this.inFlightBehavior == "executeAll") {
            this._inFlightBacklog.push({
                args: this.getArgs(),
                operation: this.operation,
                deferred: d,
                eventChain: app.debugDialog ? app.debugDialog.cacheEventChain() : undefined
            });
        } else {
            d.errback("Unable to fire " + this.toString() + " because it is already firing, and the inFlightBehavior property is unset");
        }
        return d;
    },

    /* Internal version of update method; please only call update() or updateInternal() */
    _update: function() {
        if (this.canUpdate()) {
            if (this._requester && !this._isDesignLoaded) {
                var d = this.addToBacklog();
                return d;
            }
            this.onBeforeUpdate(this.input);
            wm.cancelJob(this.getRuntimeId() + ".doAutoUpdate"); // just in case there's a job already scheduled
            return this.request();
        } else {
            var error =  this.disabled ?  this.getRuntimeId() + " tried to fire but its disabled property prevented it" : this.getRuntimeId() + ".canUpdate() returns false";

            this.blocked(error);

            /* Return a deferred because the caller is expecting it.  This does not play any real role in how ServiceVariables work */
            var d = new dojo.Deferred();
            d.errback(error);
            return d;
        }
    },

    /* Sets info.canUpdate to false if the ServiceCall is unable to fire */
    canUpdate: function() {
        var info = {canUpdate: this._getCanUpdate() };
        this.onCanUpdate(info);
        return info.canUpdate;
    },

    /* ServiceCall can not fire if there isn't a service or operation */
    _getCanUpdate: function() {
        return this._service && this.operation && !this.disabled;
    },

    /* Get the args from the input component. */
    getArgs: function() {
        return this.input.getArgs();
    },

    /* Lookup the operationType from the service definitions.   Values include "hqlQuery", "" */
   getOperationType: function() {
        var service = this._service;
        var operation;
        if (service) {
            operation = service._operations[this.operation];
        }
        if (operation) {
            return operation.operationType;
        } else {
            return "";
        }
   },

    /* inArgs optional too... typically provided by calls from the request backlog/inflight queue*/
    request: function(inArgs, optionalOp, optionalDeferred) {
        var args;
        try {
            args = inArgs || this.getArgs();
        } catch(e) {
            this.error(e);
            return;
        }

        /* Tell the Service component to fire */
        var d = this._requester = this._service.invoke(optionalOp || this.operation, args, this.owner, this);

        /* If a custom deferred is passed in, tie its onResult/onError handling to the Service that is being fired */
        if (optionalDeferred) {
            d.then(
            function(inValue) {
                optionalDeferred.callback(inValue);
            },
            function(inError) {
                optionalDeferred.errback(inError);
            }
            );
        }
        return this.processRequest(d);
    },


    /* Called when an update call is blocked by disabled or onCanUpdate */
    blocked: function(inMessage) {},

    /* The service is fired, take care of misc post-firing tasks like tieing the deferred to our result and error methods */
    processRequest: function(inDeferred) {
        var d = inDeferred;
        if (d) {
            d.addCallbacks(dojo.hitch(this, "result"), dojo.hitch(this, "error"));
            return d;
        }
    },

    /* This is called when the Service completes its call successfully.  This does cleanup, and calls processResult */
    result: function(inResult) {
        this._requester = false;
        this.processResult(inResult);

        /* Handle the backlog/request queue */
        this._updateNextInQueue();

        return inResult;
    },

    /* Fire the next call in the backlog.  We use wm.onidle mostly so that all of the side effects and cleanup have time to complete before firing the next call. */
    _updateNextInQueue: function() {
        if (!this._isDesignLoaded && this._inFlightBacklog) {
             if (this._inFlightBacklog.length) {
                wm.onidle(this, function() {
                    var backlog = this._inFlightBacklog.shift();
                    if (backlog) {
                        this.request(backlog.args, backlog.operation, backlog.deferred);
                    }
                });
            } else {
                this.onInflightBacklogComplete();
            }
        }
    },

    /* A user who fires 50 calls needs to know when all 50 are complete; no data needed, just a callback so
    * the next step of their process can begin
    */
    onInflightBacklogComplete: function() {},

    /* Called by result(); calls onResult and onSuccess when the ServiceCall completes */
    processResult: function(inResult) {
        this.onResult(inResult);
        this.onSuccess(inResult);
        if (!this.isDestroyed && this.$.queue) this.$.queue.update();
    },

    /* Called when the service fails; calls processError and does cleanup */
    error: function(inError) {
        this._requester = false;
        this.processError(inError);

        /* Handle the backlog/request queue */
        this._updateNextInQueue();

        return inError;
    },

    /* Called by error(); calls onResult and onError */
    processError: function(inError) {
        this.onResult(inError);
        this.onError(inError);
    },

    //=======================================================
    // Events
    //=======================================================
    /**
        onCanUpdate event fires before a service is invoked.
        @param {Any} ioUpdate An object containing a canUpdate flag.
        Setting this flag to false will prevent the service from updating.
        @event
    */
    _onCanUpdateBeforeStart: 1,
    onCanUpdate: function(ioUpdate) {
    },
    /**
        onBeforeUpdate event fires before a service is invoked.
        @param {wm.ServiceInput} ioInput The input object used to determine what data
        will be passed to the service.
        @event
    */
    onBeforeUpdate: function(ioInput) {
    },
    /**
        onResult event fires whenever a service returns, whether the
        service returned successfully or reported an error.
        @param {Any} inData Result data. The format of this data on the service.
        @event
    */
    // fires on success or error
    onResult: function(inDeprecated) {
    },
    /**
        onSuccess event fires whenever a service returns successfully.
        @param {Any} inData Result data. The format of this data on the service.
        @event
    */
    // fires only on success
    onSuccess: function(inDeprecated) {
    },
    /**
        onError event fires whenever a service reports an error.
        @param {Any} inData Result data. The format of this data on the service.
        @event
    */
    // fires only on error
    onError: function(inError) {
    }
});


//===========================================================================
// Variable used as a service input
//===========================================================================
/**
    Variable used as a service input
    @name wm.ServiceInput
    @class
    @noindex
    @extends wm.Variable
*/
dojo.declare("wm.ServiceInput", wm.Variable, {
    /** @lends wm.ServiceInput.prototype */
    _allowLazyLoad: false,
        _getSchemaForType: function(inType) {
        return this.owner && this.owner._operationInfo ? this.owner._operationInfo.parameters : null;
    },
    isDataProp: function(inProp) {
        // Note: it's important we assume all properties are data properties unless _dataSchema is set
        // Since the dataSchema is set externally,
        // bindings may set data properties before data schema is set, creating errors.
        return wm.isEmpty(this._dataSchema) || (inProp in this._dataSchema) ;
    },

    /* When the operation changes, update the input schema.  ServiceVariable will override and add autoUpdate calls */
    operationChanged: function(inType, inSchema) {
        this.setType(inType + "Inputs");
        this.setDataSchema(inSchema);
        // input bindings may need to reinitialize after gleaning
        // operation type information (in light of constants)
        if (this.$.binding && inSchema)
        {
            this.$.binding.refresh();
        }

    },

    getArgsHash: function() {
    var data= this.getData(), args={}, d;

    for (var p in this._dataSchema) {
        args[p] = (data[p] === undefined || data[p] === null) ? "" : data[p];
        }
    return args;
    },
    getArgs: function() {
        wm.Variable.convertToHashMaps = true;
        try {
            var data= this.getData(true), args=[], d;
        } catch(e){}
        wm.Variable.convertToHashMaps = false;

        // convert to array
        for (var p in this._dataSchema) {
            if (data) {
            if (data[p] instanceof Date) {
                d = data[p].getTime();
            } else {
                d = data[p];
            }
            } else {
            d = undefined;
            }
            args.push(d !== undefined ? d : null);
/* Seung's temporary fix
            if (d) {
                args.push(d);
            }
            */
        }
        return args;
    }
});



/* Design only code included here because dojo.extend doesn't work well with multiple-inheritance; this needs to be defined before the subclasses are created */
wm.ServiceCall.extend({
    clearInput: "(clear input)",
    updateNow: "(update now)",
    queue: "(serviceCalls)",
    servicesChanged: function() {
        if (this.service) {
            var owner = this.getOwnerApp();
            this._service = wm.services.getService(this.service, // name of service
                                                   owner && owner.declaredClass == "StudioApplication"); // hide from client
            if (!this._service) this._service = new wm.Service({});

            // update the operation's type; forceUpdate needed so that if the type name is the same but fields have changed it will still get updated
            this._setOperation(this.operation, 1);
        }
    },
    getUniqueName: function(inName) {
        if (inName === "input") return "input";
        return this.inherited(arguments);
    },
    /** @lends wm.ServiceCall.prototype */
    doDesigntimeUpdate: function() {
        this._designTime = true; //The line is not being used now.  It may be used in the future to differenciate requests from
        //Studio from requests deployed application.
        return studio.makeLiveDataCall(dojo.hitch(this, "_update"));
    },
    doClearInput: function() {
        this.input.destroy();
        this.input = this.createInput();
    },
    set_operation: function(inOperation) {
        this.setOperation(inOperation);
        if (this.isDesignLoaded() && dojo.indexOf(studio.selected, this) != -1) {
            /* Security Services other than logout almost always require this setting, and users get in trouble
             * by assuming the setting is the default we provide.
             */
            if (this.service == "securityService") {
                this.startUpdate = inOperation != "logout";
            }

            studio.inspector.refocusEditor();
        }
    },
    getServicesList: function() {
        return [""].concat(wm.services.getNamesList()||[]);
    },
    showQueueDialog: function() {
        var d = wm.ServiceQueue.dialog, q = this.$.queue;
        if (d) {
            d.page.binding = q;
            d.page.update();
        }else{
            /* TODO: Convert to new dialogs */
            wm.ServiceQueue.dialog = d = new wm.PageDialog({
                name: "queueDialog",
                owner: studio,
                contentWidth: 600,
                contentHeight: 400,
                hideControls: true,
                pageName: "QueueDialog",
                pageProperties: {binding: q}
            });
        }
        d.show();
    },
    makePropEdit: function(inName, inValue, inEditorProps) {
       var prop = this.schema ? this.schema[inName] : null;
       var name =  (prop && prop.shortname) ? prop.shortname : inName;
       switch (inName) {
           case "service":
           return new wm.SelectMenu(dojo.mixin(inEditorProps, {options: this.getServicesList()}));
       case "operation":
               var
                   s = this._service,
                   valueOk = s && s.getOperation(inValue),
                   methods = s && s.getOperationsList();
               if (!valueOk){
                   inValue = methods ? methods[0] : "";
                   if (inValue && inValue != this.operation)
                       this.set_operation(inValue);
               }
               if (methods)
                   return new wm.SelectMenu(dojo.mixin(inEditorProps, {options: methods}));
               break;
       }
       return this.inherited(arguments);
   }
});

wm.ServiceInputVariable = wm.ServiceInput;

}

if(!dojo._hasResource["wm.base.components.ServiceVariable"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.components.ServiceVariable"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide("wm.base.components.ServiceVariable");




//===========================================================================
// Main service calling class: calls services with input data and returns data
//===========================================================================
/**
    Main service calling class: calls services with input data and returns data
    @name wm.ServiceVariable
    @class
    @extends wm.Variable
    @extends wm.ServiceCall
*/
dojo.declare("wm.ServiceVariable", [wm.Variable, wm.ServiceCall], {
    // Points to a widget to cover with a loading dialog while firing this call
    loadingDialog: null,

    // Instead of returning JSON response, return a downloadable file; NOTE: No onResult/onSuccess/onError callbacks
    downloadFile: false,

    /* Current page of data */
    _page: 0,

    /* Maximum number of results to return per page */
    maxResults: 0,
    designMaxResults: 50,
    transposeHashMap: function(inData) {
        var data = [];
        wm.forEachProperty(inData, function(inValue, inName) {
            data.push({name: inName, dataValue: inValue});
        });
        return data;
    },
    /* Handle a successful response to a service call */
    processResult: function(inResult) {
        if (wm.isHashMapType(this.type)) {
            inResult = this.transposeHashMap(inResult);
        }
        this.setData(inResult);
        if (this.service == "securityService" && this.operation == "logout") wm.logoutSuccess();
        this.inherited(arguments);
    },

    /* Handle an error returned by a service call */
    processError: function(inError) {
        /* WARNING: This is a bit sloppy; there is no gaurentee that the inputs have not changed between the last call and the response firing
         * this error handler.
         */
        if (inError && inError.message && inError.message.indexOf("Invalid Long Polling Request:") === 0) {
            this.request(); // connectionTimeout updated by JsonRpcService; we just have to refire the failed call
            return;
        }

        this.handleSecurityErrors(inError);
        this.inherited(arguments);
    },

    /* If the errors are security related, publish the fact so the app knows its no longer logged in */
    handleSecurityErrors: function(inError) {
        var errCodes = (dojo.isObject(inError) ? inError.message : inError).match(/(\d+)$/);
        var errCode = (errCodes) ? errCodes[0] : "";

        // If the failure is a security access error, AND if its NOT a security error that comes from live view
        // (happens when a project accesses the server while running within studio), then tell the user to log back in.
        // Also don't repeat this alert more than once every 3 minutes (it takes 4 server accesses to open a page, so thats 4 alerts in a row!)
        if (errCode == 403) {
            dojo.publish("session-expiration-servicecall", [this]);
            if (app ) app._onSessionExpiration();
        } else {
            dojo.publish("service-variable-error", [this, inError]);
        }
    },

    /* ServiceCall doesn't have a type; when the type is set, we need to update our service info
    * (i.e. our input fields) and reinspect */
    setType: function() {
        this.inherited(arguments);
        if (this._isDesignLoaded && this.input) {
            this.setService(this.service);
            if (this == studio.selected) studio.inspector.inspect(this);
        }

    },

    /* ServiceCall's operationChanged updates the input component type, but as ServiceCall itself lacks a type,
     * subclasses must update their own types
     */
    operationChanged: function(forceUpdate) {
        this.inherited(arguments);
        // output has named type matching operation returnType
        var op = this._operationInfo;
        if (op || forceUpdate) {
          this.setType(op.returnType);
          this.clearData();
        }
        if ((this.autoUpdate || this.startUpdate) && !this._loading && this.isDesignLoaded()) {
          this.update();
        }
    },

    /* If its an HQL Query, then getArgs has some extra stuff to add to the parameter list */
    getArgs: function() {
        var args = this.inherited(arguments);
        var operationType = this.getOperationType();
        if (operationType == "hqlquery") {
            var max = this.isDesignLoaded() ? this.designMaxResults : this.maxResults;
            var pagingOptions = max ? { maxResults: max, firstResult: this.firstRow || 0} : {};
            args.push(pagingOptions);
        }
        return args;
    },

    /* Extra info that the debugger wants about this call */
    getDebugArgs: function() {
        return this.input.getData();
    },

    /* Paging Methods */
    getTotal: function() {
        return this.getCount();
    },
    getPageCount: function() {
        return Math.ceil(this.getTotal() / (this.getCount() || 1));
    },
    setPage: function(inPage) {
        this._page = Math.max(0, Math.min(this.getPageCount() - 1, inPage));
        this.firstRow = this._page * this.maxResults;
        this.update();
    },
    getPage: function() {
        return this._page;
    },
    setFirstPage: function() {
        this.setPage(0);
    },
    setPreviousPage: function() {
        this.setPage(this._page-1);
    },
    setNextPage: function() {
        this.setPage(this._page+1);
    },
    setLastPage: function() {
        this.setPage(this.getPageCount());
    },

    /* Adds handling of the loadingDialog to ServiceCall._update() */
    _update: function() {
        if (this.loadingDialog && !this._isDesignLoaded) {
            if (this.loadingDialog instanceof wm.LoadingDialog == false) {
                this.loadingDialog = new wm.LoadingDialog({
                    owner: this,
                    name: "loadingDialog",
                    widgetToCover: this.loadingDialog
                });
                this.loadingDialog.setServiceVariableToTrack(this);
            }
        }
        return this.inherited(arguments);
    },


    /* DEBUGGING METHODS AND OVERRIDES */

    toString: function(inText) {
       var t = inText || "";
       t += "; " + wm.getDictionaryItem("wm.ServiceVariable.toString_FIRING", {
           isFiring: Boolean(this._requester)
       });
       return this.inherited(arguments, [t]);
   },

    log: function(eventType, /* autoUpdate, autoStart, eventHandler */
       callingMethod, /* optional; indicates who really called this */
       backlogObj, /* optional; used to provide an old eventChain */
       errorMsg /* optional; for processError only */ ) {
        if (!app.debugDialog) return;
        if (!this.debugId) this.debugId = [];

        /* STEP 1: Setup the _debug object used by the wm.debugger.ServicePanel */
        if ((eventType != "serviceCall" && eventType != "serviceCallResponse")) {
            this._debug = {
                trigger: callingMethod || eventType,
                eventName: eventType,
                request: "",
                lastUpdate: new Date()
            };
        }


        /* If the eventType is autoUpdate, then this is triggered by a change to the input/filter/sourceData value; in other words,
         * a change to a wm.Variable.  This means that the notification for the change came from a call to dataValueChanged;
         * See if we can find what called dataValueChanged and log that.
         * WARNING: Sometimes the callstack goes into a loop, so don't go deeper than 15 into the stack.
         */
        if (eventType == "autoUpdate") { /* This block logs it in wm.debugger.ServicePanel */
            try {
                var i = 0;
                var caller = arguments.callee.caller;
                while (caller && caller.nom != "dataValueChanged" && i < 15) {
                    caller = caller.caller;
                    i++;
                }
                if (caller && caller.nom == "dataValueChanged") {
                    var newValue = caller.arguments[1];
                    this._debug.eventName = "inputChanged: " + caller.arguments[0] + " set to " + (newValue instanceof wm.Component ? newValue.toString() : newValue);
                }
            } catch (e) {}

            /* This block logs it in wm.debugger.EventsPanel */
            this.debugId.push({
                eventType: eventType,
                id: app.debugDialog.newLogEvent({
                    eventType: "autoUpdate",
                    sourceDescription: "An input has changed",
                    resultDescription: "Because autoUpdate is set, " + this.getRuntimeId() + ".update() was called",
                    method: "update",
                    affectedId: this.getRuntimeId(),
                    firingId: this.getRuntimeId()
                })
            });

        } else if (eventType == "start") {
            this.debugId.push({
                eventType: eventType,
                id: app.debugDialog.newLogEvent({
                    eventType: "start",
                    sourceDescription: "Owner has loaded",
                    resultDescription: "Because startUpdate is set, " + this.getRuntimeId() + ".update() was called",
                    method: "update",
                    affectedId: this.getRuntimeId(),
                    firingId: this.owner.getRuntimeId()
                })
            });
        } else if (eventType == "autoUpdateOnStart") {
            var page = this.getParentPage() || app;
            this._debug.trigger = "autoUpdate" + (page && page._loadingPage ? ": onStart" : "unknown source");

            this.debugId.push({
                eventType: eventType,
                id: app.debugDialog.newLogEvent({
                    eventType: "autoUpdate",
                    sourceDescription: "An input has initialized",
                    resultDescription: "Because autoUpdate is set, " + this.getRuntimeId() + ".update() was called",
                    method: "update",
                    affectedId: this.getRuntimeId(),
                    firingId: this.owner.getRuntimeId()
                })
            });
        }

        /* Calls to "update" are typically made from user written methods (I've changed most internal calls to "updateInternal" */
        else if (eventType == "update") {
            this.debugId.push({
                eventType: eventType,
                id: app.debugDialog.newLogEvent({
                    eventType: "update",
                    sourceDescription: (callingMethod ? callingMethod + "() called " : "") + this.getRuntimeId() + ".update()",
                    resultDescription: "Processing request to fire service variable",
                    method: "update",
                    affectedId: this.getRuntimeId(),
                    firingId: ""
                })
            });
        } else if (eventType == "serviceCall") {
            if (backlogObj && backlogObj.eventChain) {
                var currentEventChain = app.debugDialog.cacheEventChain();
                app.debugDialog.restoreEventChain(backlogObj.eventChain);
            }
            this.debugId.push({
                eventType: eventType,
                id: app.debugDialog.newLogEvent({
                    eventType: "serviceCall",
                    sourceDescription: this.getRuntimeId() + ".update()",
                    resultDescription: "Sending request to server",
                    method: "request",
                    affectedId: this.getRuntimeId(),
                    firingId: this.getRuntimeId()
                })
            });
            this.debugEventChain = app.debugDialog.cacheEventChain(); // use this when the request is completed to stitch together the event sequence
            if (currentEventChain) {
                app.debugDialog.restoreEventChain(currentEventChain);
            }
        } else if (eventType == "serviceCallResponse") {
            app.debugDialog.restoreEventChain(this.debugEventChain);
            delete this.debugEventChain;
            this.debugId.push({
                eventType: eventType,
                id: app.debugDialog.newLogEvent({
                    eventType: "serviceCallResponse",
                    sourceDescription: "Response received from server",
                    resultDescription: errorMsg ? "Calling " + this.getRuntimeId() + ".onError()" : "Calling " + this.getRuntimeId() + ".onSuccess()",
                    method: errorMsg ? "processError" : "processResult",
                    affectedId: this.getRuntimeId(),
                    firingId: this.getRuntimeId()
                })
            });
            if (this._debug && this._debug.lastUpdate) {
                this._debug.duration = new Date().getTime() - this._debug.lastUpdate.getTime();
            }
        } else if (eventType == "disabled" || "onCanUpdate") {
            this.debugId.push({
                eventType: eventType,
                id: app.debugDialog.newLogEvent({
                    eventType: eventType,
                    sourceDescription: "Update was prevented by " + (eventType == "disabled" ? "disabled property" : "onCanUpdate() call"),
                    resultDescription: "Service did not fire",
                    method: "update",
                    affectedId: this.getRuntimeId(),
                    firingId: ""
                })
            });

        }

        if (eventType != "serviceCall" && eventType != "serviceCallResponse" && this._debug || this._debug && !this._debug.eventId) {
            this._debug.eventId = this.debugId[this.debugId.length - 1].id;
        }

    },
    endLog: function(eventType) {
        if (!app.debugDialog) return;
        if (this.debugId && this.debugId.length) {
            var debugId = this.debugId.pop();
            if (debugId.eventType == eventType) {
                app.debugDialog.endLogEvent(debugId.id);
            }
        }
        if (eventType == "serviceCallResponse") {
            app.debugDialog.clearEventChain();
        }
    },
    inputChanged: function() {
        if (this.autoUpdate) {
            if (app.debugDialog) this.log("autoUpdate");
            this.inherited(arguments);
            if (app.debugDialog) this.endLog("autoUpdate");
        }
    },
    /* Add logging to doStartUpdate */
    doStartUpdate: function() {
        if (this.canStartUpdate()) {
            if (app.debugDialog) this.log("start");
            this.inherited(arguments);
            if (app.debugDialog) this.endLog("start");
        }
    },
    doAutoUpdate: function() {
        if (this.canAutoUpdate()) {
            if (app.debugDialog && !this._debug && this._inPostInit) this.log("autoUpdateOnStart");

            this.inherited(arguments);

            if (app.debugDialog) this.endLog("autoUpdateOnStart");
        }
    },
    request: function(inArgs, optionalOp, optionalDeferred) {

        if (app.debugDialog && this._debug) this._debug.request = this.getDebugArgs();
        if (app.debugDialog) {
            this.log("serviceCall", null, optionalOp);
            this.endLog("serviceCall", null, optionalOp);
        }

         if (!this.downloadFile) {
            return this.inherited(arguments);
        } else {
            var args = inArgs || this.input.getArgsHash();
            var baseurl;
            if (wm.xhrPath) {
                baseurl = wm.xhrPath;
            } else {
                baseurl = window.location.href;
                baseurl = baseurl.replace(/\?.*$/,"");
                baseurl = baseurl.replace(/\/[^\/]*$/,"/");
            }
            var urlStr = baseurl + this._service._service.serviceUrl.replace(/\.json$/,".download");

            /* Delete the last iframe */
            var iframe = dojo.byId("downloadFrame");
            if (iframe) iframe.parentNode.removeChild(iframe);

            /* Create a new iframe */
            iframe = document.createElement("iframe");
            dojo.attr(iframe, {     id: "downloadFrame",
                                    name: "downloadFrame"});
            dojo.style(iframe, {    top: "1px",
                                    left: "1px",
                                    width: "1px",
                                    height: "1px",
                                    visibility: "hidden"
                                });
            dojo.body().appendChild(iframe);

            /* Get the document of the iframe */
            var iframedoc= iframe.contentDocument || iframe.contentWindow.document;
            iframedoc.open("text/html"); // required by ie8 and earlier so that iframedoc.body exists
            iframedoc.close();

            /* Create a form.  Add a "method" parameter to it using an input element */
            var form =  iframedoc.createElement("form");
            dojo.attr(form, {   id: "downloadForm",
                                method: "POST",
                                action: urlStr
                            });
            var method = iframedoc.createElement("input");
            dojo.attr(method, { name: "method",
                                value: optionalOp || this.operation});
            form.appendChild(method);

            /* Add one input per parameter */
            wm.forEachProperty(args, function(value, name) {
                var input = iframedoc.createElement("textarea");
                dojo.attr(input, {  name: name,
                                    value: value});
                form.appendChild(input);
            });

            iframedoc.body.appendChild(form);
            form.submit();

        }
    },

    /* Called when an update call is blocked by disabled or onCanUpdate */
    blocked: function(inMessage) {
        this.log(this.disabled ? "disabled" : "onCanUpdate");
        this.onBlocked();
        this.endLog(this.disabled ? "disabled" : "onCanUpdate");
    },
    onBlocked: function(inMessage) {},

    setDisabled: function(inDisabled) {
        var valueWas = this.disabled;
        this.disabled = Boolean(inDisabled);

        // parent class (wm.Variable) does calls this, but this fires
        // the service variable immediately,
        // and the new filter/sourceData/input values
        // may not have arrived yet; this notify
        // should only be called when there is a change in data
        //if (valueWas != this.disabled) this.notify();
    },



    /* Adds logging to result method */
    result: function(inResult) {
        delete this._lastError;
        if (app.debugDialog) {
            this.log("serviceCallResponse");
            if (this._jsonRpcServiceDeferred && this._jsonRpcServiceDeferred.xhr) {
                var text = this._jsonRpcServiceDeferred.xhr.responseText;
                this._lastResponse = (text || "").length > 1000 ? text.substring(0,1000) + "..." : text;
            }
        }
        var result = this.inherited(arguments);
        if (app.debugDialog) this.endLog("serviceCallResponse");
        return inResult;
    },



    /* Adds logging to the error method */
    error: function(inError) {
        if (djConfig.isDebug) this.log("serviceCallResponse");
        this._lastError = inError;
        this.inherited(arguments);
        if (djConfig.isDebug) this.endLog("serviceCallResponse");
        return inError;
    }

});


}

if(!dojo._hasResource["wm.base.widget.Container"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.widget.Container"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide("wm.base.widget.Container");

/**
    Base class for widget containers.
    @name wm.Container
    @class
    @extends wm.Control
*/
wm.define("wm.Container", wm.Control, {
    /** @lends wm.Container.prototype */
/*
    published: {
        invalid: { ignore: 1, bindSource: 1, readonly: 1, type: "Boolean" },
        lock: { order: 0, type: "Boolean" },
        freeze: { order: 5, type: "Boolean" },
        box: { ignore: 1 },
        boxPosition: { ignore: 1},
            autoScroll: {group: "scrolling", order: 100, ignore: 0, type: "Boolean"}
    },
    */
    //touchScrolling: false,
    imageList: "",
    border: "0",
    container: true,
    lock: false,
    freeze: false,
    classNames: "wmcontainer",
    autoScroll: false,
    //themeStyleType: "",        // A funky parameter that won't ever show up in widgets.js; instead it adds/removes classes (more of a style's inspector kind of property, but one that identifies the type of content and leaves it to the theme to decide how to render it)
        fitToContentWidth: false,  // Container automatically resizes itself to match the width of its content, or minWidth if % sized content
        fitToContentHeight: false, // Container automatically resizes itself to match the height of its content, or minHeight if % sized content
        fitToContent: false,       // shortcut for (fitToContentWidth || fitToContentHeight)
        _needsFitToContent: false, // Init time flag that signals that this fitToContent container has not yet been fit to its content


    constructor: function() {
        this.c$ = [];
    },
    init: function() {

        if (this.dockRight) {
            app.dockRight = this;
        }
        if (this.dockLeft) {
            app.dockLeft = this;
        }
        if (this.dockTop) {
            app.dockTop = this;
        }
        if (this.dockBottom) {
            app.dockBottom = this;
        }

        if (this.autoScroll && app._touchEnabled && !wm.disableTouchScroll) {
            var node = this.domNode;
            this.connect(node, wm.isFakeMobile ? "mousedown" : "touchstart", this, "_ontouchstart");
            if (!wm.isFakeMobile) {
                this.connect(node, "touchmove", this, "_ontouchmove");
                this.connect(node, "touchend", this, "_ontouchend");
            }
        }

        this.inherited(arguments);
        this.setLayoutKind(this.layoutKind);
        this.domNode.box = this.box = "";
        this._needsFitToContent = this.fitToContent = this.fitToContentWidth || this.fitToContentHeight;
    },

    _ontouchstart: function(e) {
        if (app._touchY && app._touchY.animationId) {
            window.clearInterval(app._touchY.animationId);
            delete app._touchY.animationId;
        }
        if (!this._xscrollY) return; // if there is no scrolling, exit and let the event bubble up to the parent
        var node = this.domNode;
        var targetNode = e.touches ? e.touches[0].target : e.target;

        if (targetNode.tagName == "INPUT" || targetNode.tagName == "TEXTAREA") {
            targetNode.focus();
            return;
        }
        //if (node.scrollTop + node.clientHeight >= node.scrollHeight) return ; // if there's no more room to move down, let the event bubble up to the parent
        dojo.stopEvent(e);
        var y = e.touches && e.touches.length ? e.touches[0].screenY : e.screenY;

        app._touchY = {
            y: y,
            initialY: y,
            targetNode: targetNode,
            targetWidget: this,
            time: new Date().getTime(),
            moved: false
        };
        this.connect(node, wm.isFakeMobile ? "mousemove" : "touchmove", this, "_ontouchmove");
        this.connect(node, wm.isFakeMobile ? "mouseup" : "touchend", this, "_ontouchend");
    },
    _ontouchmove: function(e) {
        if (!app._touchY) return;
        dojo.publish("wmTouchMove", [this]); // call this any time we stop the event from propagating up
        var y = e.touches && e.touches.length ? e.touches[0].screenY : e.screenY;
        var touchTarget = e.touches && e.touches.length ? e.touches[0].target : e.target;

        if (touchTarget != app._touchY.targetNode && !wm.isFakeMobile) return;
        var node = this.domNode;

        /* Let the event bubble up if no room to scroll */
        if (node.scrollHeight <= node.clientHeight) return;

        var initialScrollTop = node.scrollTop;

        var lastY = app._touchY.y;
        if (y == lastY) {
            dojo.stopEvent(e);
            //console.log("Y == Y");
            return;
        }

        // If Y is decreasing, then the user is trying to increase scrollTop, but we're already scrolled to the bottom, let the parent container handle it
        if (y < lastY && node.clientHeight + node.scrollTop >= node.scrollHeight ||
        // If Y is Increasing, then the user is trying to decrease scrollTop, but we're already scrolled to the top, let the parent container handle it
        y > lastY && node.scrollTop <= 0) {
            /*
        app._touchY.y = y;
        app._touchY.velocity = 0;
        app._touchY.time = new Date().getTime();
        */
            return;
        }

        var delta = lastY - y;


        var time = new Date().getTime();
        var deltaTime = time - app._touchY.time;
        var scrollTop = node.scrollTop;
        var newScrollTop = scrollTop + delta;
        if (newScrollTop < 0) {
            newScrollTop = 0;
        } else if (newScrollTop > node.scrollHeight) {
            newScrollTop = node.scrollHeight;
        }
        node.scrollTop = newScrollTop;
        //console.log("Y: " + y + ", lastY: " + lastY + "; DELTA: " + delta + ", scrollTop: " + newScrollTop + ", NAME: " + this.name);
        var deltaScrollTop = initialScrollTop - node.scrollTop;
        app._touchY.y = y;
        app._touchY.velocity = delta / deltaTime;
        app._touchY.time = new Date().getTime();
        if (Math.abs(y-app._touchY.initialY) > 5) app._touchY.moved = true;
        /*
    app._touchY = {y: y, // last y position changes as a result of scrolling
            targetNode: touch.target,
            velocity: delta / deltaTime,
            time: new Date().getTime()};
            */
        dojo.stopEvent(e);

    },
    _ontouchend: function(e) {
        var node = this.domNode;

        if (node.scrollHeight <= node.clientHeight) return; // if there is no scrolling, exit and let the event bubble up to the parent
        if (app._touchY.velocity != Infinity && Math.abs(app._touchY.velocity) > 0.15) {
            if (app._touchY.animationId) {
                window.clearInterval(app._touchY.animationId);
            }
            app._touchY.animationId = window.setInterval(dojo.hitch(this, "_onAnimateScroll"), 50);
        }
        //dojo.stopEvent(e);
        this.disconnectEvent("mousemove");
        this.disconnectEvent("mouseup");
    },
    _onAnimateScroll: function() {
        var node = this.domNode;
        app._touchY.velocity *= 0.9;
        var top = node.scrollTop;
        var newTop = node.scrollTop + Math.min(app._touchY.velocity * 50, node.clientHeight); // velocity is px per ms; 50ms is our animation interval
        node.scrollTop = newTop;
        if (app._touchY.velocity == Infinity || Math.abs(top - newTop) <= 1) {
            window.clearInterval(app._touchY.animationId);
            //console.log("Delete touchY in Animate: " + this.name);
            //delete app._touchY;
            return;
        }
        node.scrollTop += Math.min(app._touchY.velocity * 50, node.clientHeight); // velocity is px per ms; 50ms is our animation interval
    },

    postInit: function() {
        if (this.isDesignLoaded()) this.setLock(this.lock);
        this.inherited(arguments);
        if (this.disabled) {
            wm.forEachProperty(this.widgets, dojo.hitch(this, function(w, name) {
                w.setParentDisabled(this._disabled);
            }));
        }
    },

    /* Called from Component.makeEvents or by end user*/
    connectOnEnterKey: function() {
        this.connect(this.domNode, "onkeypress", this, "keypress");
    },
    keypress: function(evt) {
        var self = this;
        if (evt.keyCode == dojo.keys.ENTER && evt.target.tagName != "TEXTAREA") {
            wm.job(this.getRuntimeId() + ".enterkeypress", 50, dojo.hitch(this, function() {
                if (!this.isDestroyed) this.onEnterKeyPress(evt);
            }));
        }
    },
    setThemeStyleType: function(inType) {
        var oldType = this.getThemeStyleType();
        if (oldType) this.removeUserClass(oldType);
        if (inType) this.addUserClass(inType);
    },
    getThemeStyleType: function() {
        var types = ["MainContent", "EmphasizedContent", "HeaderContent"];
        if (this._classes && this._classes.domNode) for (var i = 0; i < types.length; i++) {
            if (dojo.indexOf(this._classes.domNode, types[i]) != -1) return types[i];
        }
    },
    destroy: function() {
        if (this.dockRight) {
            delete app.dockRight;
        } else if (this.dockLeft) {
            delete app.dockLeft;
        } else if (this.dockTop) {
            delete app.dockTop;
        } else if (this.dockBottom) {
            delete app.dockBottom;
        }
        if (this.domNode && this.domNode.box) delete this.domNode.box;
        this.inherited(arguments);
    },
    bc: function() {
        this.inherited(arguments);
        /*
        if (this.verticalAlign == "justified") {
            this.verticalAlign = "top";
        }
        if (this.horizontalAlign == "justified") {
            this.horizontalAlign = "left";
        }
        */
        delete this.layoutJustify;
        if (this.layoutAlign) {
            this.contentAlign = this.layoutAlign;
            delete this.layoutAlign;
        }

            /* this.layoutFit I believe is an obsolete wm 4.x property */
        if (this.layoutFit) {
            this.fitToContentWidth = this.fitToContentHeight = this.layoutFit;
            delete this.layoutFit;
        }
        if (this.box == "h") {
            this.layoutKind = "left-to-right";
            //this.layout = wm.Container.vBox;
        }
        if (this.boxPosition) {
            var
                boxPositions = ['topLeft', 'center', 'bottomRight'],
                vAligns = ["top", "middle", "bottom"],
                hAligns = ["left", "center", "right"],
                h = this.layoutKind == "left-to-right",
                i = dojo.indexOf(boxPositions, this.boxPosition);
            if (i != -1) {
                if (h)
                    this.horizontalAlign = hAligns[i];
                else
                    this.verticalAlign = vAligns[i];
            }
        }
    },
    //
    // Child Controls
    //
    addWidget: function(inWidget){
        this.inherited(arguments);

            if (this.box == 'h' && !inWidget.width)
                inWidget.setProp("width", "64px");
            else if (this.box == 'v' && !inWidget.height)
                inWidget.setProp("height", "64px");
            //inWidget.setSize(inWidget.size);
    },
    getOrderedWidgets: function() {
        return this.c$;
    },
    addControl: function(inControl) {
        this.c$.push(inControl);
        //this.dom.append(inControl.dom);
    },
    removeControl: function(inControl) {
        //this.dom.remove(inControl.dom);
        if (this.c$) {
            for (var i=0, c; c=this.c$[i]; i++){
                if (c == inControl) {
                    this.c$.splice(i, 1);
                    return i;
                }
            }
        }
    },
        // Added by michael k 5/15/09 to support the PopupHelp dialog
    removeAllControls: function() {
            while (this.c$.length) {
              var c = this.c$[0];
              this.removeControl(c);
              c.destroy();
            }
              /*
          while (this.c$.length) this.removeControl(this.c$[0]);
          for (var n in this.widgets)
            this.removeWidget(this.widgets[n]);
          while (this.domNode.firstChild) this.domNode.removeChild(this.domNode.firstChild);
              */
          this.reflow();
    },
    insertControl: function(inControl, inIndex) {
        this.c$.splice(inIndex, 0, inControl);
        //this.dom.append(inControl.dom);
    },
    moveControl: function(inControl, inIndex) {
        var i0 = this.removeControl(inControl);
       /* if (i0 < inIndex)
            inIndex--;*/
        if (inIndex == -1) {
            this.c$.push(inControl);
        } else {
            this.c$.splice(inIndex, 0, inControl);
        }
    },
    indexOfControl: function(inControl) {
        for (var i=0, c; c=this.c$[i]; i++){
            if (c == inControl) {
                return i;
            }
        }
        return -1;
    },
    nextSibling: function(inControl, showingOnly) {
        for (var i=0, c; c=this.c$[i]; i++){
            if (c == inControl) {
                if (!showingOnly) {
                return this.c$[i+1];
                } else {
                for (var j = i+1; j < this.c$.length; j++) {
                    if (this.c$[j].showing) return this.c$[j];
                }
                }
            }
        }
    },
    prevSibling: function(inControl, showingOnly) {
        for (var i=0, c; c=this.c$[i]; i++){
            if (c == inControl) {
                if (!showingOnly) {
                return this.c$[i-1];
                } else {
                for (var j = i-1; j >= 0; j--) {
                    if (this.c$[j].showing) return this.c$[j];
                }
                }

            }
        }
    },
    setAutoScroll: function(inAutoScroll) {
        this._xscrollX = false;
        this._xscrollY = false;
        this.inherited(arguments);
        this.reflow();
    },


    adjustSetSizeProp: function(n,v) {
        if (n == "height" && this.fitToContentHeight && this.getPreferredFitToContentHeight)
        return this.getPreferredFitToContentHeight() + "px";
        if (n == "width" && this.fitToContentWidth && this.getPreferredFitToContentWidth)
        return this.getPreferredFitToContentWidth() + "px";
        return v;
    },
    //
    // Flow
    //
    reflow: function() {
        this._boundsDirty = true;
        if (!this.isReflowEnabled())
        return;
        /* If this widget is fitToContent, then we'll need to update this container's width/height to fit its contents; and that means the parent will need to reflow.
         * If the parent is fitToContent, (TODO: Is this still needed?) then any we'll need to call this.parent.reflow() which will cause the parent to flow its children,
         * (of which this container is one), and the children to flow their children of which this is one.
         *  After this is done, this too will call calcFitToContent.
         */
        if (this.parent && (this.fitToContent || this.parent.fitToContent)) {
            if (this._needsFitToContent) delete this._needsFitToContent;
            this.parent.reflow();
                    /*
            if (this.fitToContent) {
                this.calcFitToContent();
            }
                        */
        } else {
            this.flow();
        }
    },
    adjustFlowForMobile: function() {
    if (this.autoScroll || this.fitToContentHeight  || studio.currentDeviceType == "desktop" || this._percEx.h) return;
    var max = 0;
    if (this.layoutKind == "left-to-right") {
        max = this.bounds.h;
        for (var i = 0; i < this.c$.length; i++) {
        var c = this.c$[i];
        if (c.enableTouchHeight && !c._percEx.h && c.mobileHeight) {
            if (c.bounds.h > max) max = c.bounds.h;
        }
        }
    } else {
        var hasMobileHeight = false;
        for (var i = 0; i < this.c$.length; i++) {
        var c = this.c$[i];
        if (c.enableTouchHeight && !c._percEx.h && c.mobileHeight) {
            hasMobileHeight = true;
            break;
        }
        }
        if (hasMobileHeight)
        max = this.getPreferredFitToContentHeight();
    }
    if (max > this.bounds.h) {
        this.enableTouchHeight = true;
        var h =  max + "px";
        this.mobileHeight = h;
        this.setHeight(h);
    }

    },
    flow: function() {
        if (this._boundsDirty && this.isReflowEnabled()) {
        if (this._isDesignLoaded) {
            this.adjustFlowForMobile();
        }
        this.layout.flow(this,false);
        }
    },
    renderControls: function() {
        // code to insure that a container's scrollbars are updated when a child is resized...
        // this means that autoscroll has a slower rendering execution than non-autoscroll
        //if (this.autoScroll && this._xneedReflow || this.fitToContent) this.renderBounds();
        for (var i=0, c; c=this.c$[i]; i++) {
        if (c.showing)
            c.renderBounds();
        }
    },
    removeDelayedReflow: function() {
        delete wm.Container.delayedReflowWidgets[this.getRuntimeId()];
    },
    delayedReflow: function() {
    /* Already queued for reflow */
    if (wm.Container.delayedReflowWidgets[this.getRuntimeId()])
        return;
    wm.Container.delayedReflowWidgets[this.getRuntimeId()] = this;

    var newParents = [];

    /* Iterate over every existing delayed widget and find if they have a common parent that could be reflowed instead */
    try {
        wm.forEachProperty(wm.Container.delayedReflowWidgets, dojo.hitch(this, function(widget, widgetid) {
        if (widget === this) {
        ;
        } else if (widget.parent === this.parent) {
        delete wm.Container.delayedReflowWidgets[widgetid];
        delete  wm.Container.delayedReflowWidgets[this.getRuntimeId()];
        newParents.push(this.parent);
        } else if (this.isAncestor(widget)) {
            delete  wm.Container.delayedReflowWidgets[this.getRuntimeId()];
        } else if (widget.isAncestor(this)) {
            delete wm.Container.delayedReflowWidgets[widgetid];
        }
        }));
    } catch(e) {}
    for (var i = 0; i < newParents.length; i++) {
        newParents[i].delayedReflow();
    }

    if (!wm.Container._delayedReflowWidgetsId) {
        wm.Container._delayedReflowWidgetsId = window.setTimeout(wm.Container.runDelayedReflow, 1);
    }
    },
        forEachControl: function(inFunc, paramArray) {
      dojo.forEach(this.c$, function(inControl) {
        inFunc.apply(inControl, (paramArray) ? paramArray : []);
        });
    },
    // bc
    nodeBoundsChange: function() {
        // should be caused by box layout flow
        /*
        this.setBounds(dojo.marginBox(this.domNode));
        this.flow();
        */
    },
    //
    // Image list
    //
    imageListChanged: function() {
        for (var i=0, c; c=this.c$[i]; i++) {
            wm.fire(c, "imageListChanged");
        }
    },
    setImageList: function(inImageList) {
        this.imageList = inImageList;
        this.imageListChanged();
    },


    updateIsDirty: function() {
    this.setValue("isDirty", this.getIsDirty());
    wm.fire(this.parent, "updateIsDirty");
    },
    getIsDirty: function() {
    for (var i in this.widgets) {
        var w = this.widgets[i];
        if (w.isDirty)
        return true;
            else if (w.isDirty === undefined && w.getIsDirty && w.getIsDirty())
                return true;
    }
    },

    //
    // validation
    //
    validate: function() {
        this.setValue("invalid", this.getInvalid());
        wm.fire(this.parent, "validate");
    },
    getInvalid: function() {
        var p = this.getParentPage();
        for (var i in this.widgets) {
        var w = this.widgets[i];
        if (p && p.validateVisibleOnly && (!w.showing || wm.Layer && w instanceof wm.Layer && !w.isActive()))
            continue;
        if (w.invalid)
            return true;
                else if (w.invalid === undefined && w.getInvalid && w.getInvalid())
                    return true;
        }

        if (dojo.isFunction(this.customGetValidate))
        return !this.customGetValidate();
        return false;
    },
        customGetValidate: function() {
        return true;
        },
    getInvalidWidget: function() {
        var p = this.getParentPage();
        for (var i in this.widgets) {
        var w = this.widgets[i];
        if (p && p.validateVisibleOnly && (!w.showing || wm.Layer && w instanceof wm.Layer && !w.isActive()))
            continue;
        if (wm.isInstanceType(w,[wm.AbstractEditor, wm.Editor])) {
            if (w.getInvalid()) return w;
        } else if (wm.isInstanceType(w,wm.Container)) {
            var tmp = w.getInvalidWidget();
            if (tmp) return tmp;
        }
        }
        return null;
    },

    //
    // Lock/freeze
    //
    getLock: function() {
        return this.lock || (this.parent && wm.fire(this.parent, "getLock")) || false;
    },
    setLock: function(inLock) {
            var original = this.lock;
        this.lock = inLock;
        if (window['studio'] && (this.lock != original || this.lock)) {
            studio.refreshComponentOnTree(this);
        }
    },
    getFreeze: function() {
        return this.freeze || this.getLock();
    },
    // FIXME: design only? vestigal?
    /*
    findContainer: function(inType) {
        if (!this.lock) {
            if (this.freeze || !this.isWidgetTypeAllowed(inType)) {
                for (var i in this.widgets) {
                    var w = this.widgets[i];
                    if (w.container) {
                        var r = w.findContainer(inType);
                        if (r)
                            return r;
                    }
                }
            } else {
                return this;
            }
        }
    },
    */
    // used by paste
    isWidgetTypeAllowed: function(inType) {
        // subclasses should override this to enforce only certain widget types
        // are allowed to be added to the container.
        return true;
    },
    /*
    setBox: function(inBox) {
        if (this.box != inBox) {
            this.box = (this.containerNode || this.domNode).box = inBox;
            // FIXME: wtf?
            //if (this.isSizeable() || !this.isMoveable())
                this._reorientChildren(this.box);
            this.reflow();
        }
    },
    */
    /*
    _reorientChildren: function(inBox) {
        var b = inBox, bp = wm.Box.prototype, bw = bp.width, bh = bp.height;
        var parentNode = this.containerNode || this.domNode;
        wm.forEachProperty(this.widgets, function(w) {
            if (w.domNode.parentNode != parentNode)
                return;
            var s = w.domNode.style, f = (b == 'flow' || b == '');
            if (f) {
                s.position = 'static';
                w.left = w.top = '';
                w.updateBounds();
            } else
                s.position = 'absolute';
            w.moveable = !f;
            if (b == 'h' || b == 'v') {
                w.width = bw;
                w.height = bh;
                w.updateBounds();
            }
        });
    },*/
    _reorientChildren: function(inBox) {
        var parentNode = this.containerNode || this.domNode;
        wm.forEachProperty(this.widgets, function(w) {
            if (w.domNode.parentNode != parentNode)
                return;
            var ww = w.width;
            w.width = w.height;
            w.height = ww;
            w.updateBounds();
        });
    },
    clearData: function() {
        var clear = function(w) {
        if (wm.isInstanceType(w, [wm.AbstractEditor, wm.Editor])) {
            w.clear();
        }
        };
        wm.forEachWidget(this,clear);
    },
    resetData: function() {
        var reset = function(w) {
        if (w instanceof wm.AbstractEditor)
            w.reset();
        };
        wm.forEachWidget(this,reset);
    },
        clearDirty: function() {
            this.setValue("isDirty", false);
        var dirty = function(w) {
            if (w instanceof wm.AbstractEditor)
                w.clearDirty();
        }


        wm.forEachWidget(this,dirty);
    },
    /* What is the maximum width that this container can achieve given its parents and assuming we aren't planning on using scrollbars?
     * The answer is a function of the parent's getCurrentMaxWidth and the sizes of this container's siblings.
     */
    getCurrentMaxWidth: function() {
        // If no parent, or if the parent doesn't have the getCurrentMaxWidth method, then there is nothing to look up, just
        // return the available width within this container
        if (!this.parent || !this.parent.getCurrentMaxWidth)
            return this.bounds.w - this.padBorderMargin.l - this.padBorderMargin.r;

        // Else if we are fitToContent, then we need to get the parent's current max width, as that is how far our fitToContent container can extend
        else if (this.fitToContent)
            return this.parent.getCurrentMaxWidth();

        // If we are NOT fitToContent, but we are % sized in a top-to-bottom layout, then our max width is the width of the parent
        else if (this._percEx.w && this.layoutKind == "top-to-bottom")
            return this.parent.getCurrentMaxWidth();

        // If we are NOT fitToContent but we are % sized in a left-to-right layout, then calc how much free space there is in the parent
        // return free space minus the width of this object to get the full space available for this container to grow
        else if (this._percEx.w && this.layoutKind == "top-to-bottom") {
            var maxWidth = this.parent.layout.getMaxFreeSpace(this.parent.c$, "w",this.parent.bounds.w - this.parent.padBorderMargin.l - this.parent.padBorderMargin.r);
            return maxWidth + this.bounds.w;
        }
        // Else we must be px sized, so just return our width
        else
            return this.bounds.w - this.padBorderMargin.l - this.padBorderMargin.r;
    },

    /* What is the maximum height that this container can achieve given its parents and assuming we aren't planning on using scrollbars?
     * The answer is a function of the parent's getCurrentMaxHeight and the sizes of this container's siblings.
     */
    getCurrentMaxHeight: function() {
        if (!this.parent || !this.parent.getCurrentMaxHeight)
            return this.bounds.h - this.padBorderMargin.t - this.padBorderMargin.b;

        else if (this.fitToContent)
            return this.parent.getCurrentMaxHeight();

        else if (this._percEx.h && this.layoutKind == "left-to-right")
            return this.parent.getCurrentMaxHeight();
        else if (this._percEx.h && this.layoutKind == "top-to-bottom") {
            var maxHeight = this.parent.layout.getMaxFreeSpace(this.parent.c$, "h",this.parent.bounds.h - this.parent.padBorderMargin.t - this.parent.padBorderMargin.b);
            return maxHeight + this.bounds.h;
        }
        else
            return this.bounds.h - this.padBorderMargin.t - this.padBorderMargin.b;
    }
});

wm.Container.extend({

    /* Get the preferred width of this container, for use if this is a fitToContentWidth container.
     * left-to-right container: width is the sum of the widths of all px sized children and the sum of all minWidths for % sized children.
     * top-to-bottom container: width is the max of the widths of all px sized children and the minWidths for % sized children
     */
    getPreferredFitToContentWidth: function() {
        // get the maximum width in this column;
        // and get the sum of widths in this row... we'll worry later about whether its a row or column
                var extra = this.padBorderMargin.r + this.padBorderMargin.l;
            var max = 0;
            var sum = 0;
        var percentUsed = 0;
        var v;
        var count = 0;
        for (var i=0, c; c=this.c$[i]; i++) {
            if (this.layout.inFlow(c)) {
                count++;
                if (
                /* if its a fitToContentWidth widget, then its height is determined by calling getPreferredFitToContentHeight */
                c.fitToContentWidth ||
                    /* If there is a fitToContentWidth panel that contains a Container that is percent sized, then
                     * assume the parent will resize to fit whatever height this % sized container needs.
                     * If c is autoScrolling, then its size isn't affected by its contents.
                     */
                c instanceof wm.Container && c._percEx.w == 100 && !c.autoScroll && c.parent && (c.parent.fitToContentWidth||c.parent.autoScroll)
                   ) {
                    v =  c.getPreferredFitToContentWidth();
                } else if (!c._percEx.w) {
                    v =  c.bounds.w;
                } else {
                    v = parseInt(c.minWidth) || c.getMinWidthProp();
                    if (c.bounds.w > v || this.c$.length == 1) {
                    if (percentUsed < 100)
                        percentUsed += c._percEx.w;
                    } else {
                    percentUsed = 100;
                    }
                }
                max = Math.max(max, v);
                sum += v;

            }
        }

        var dontNormalizeMinPercent = count == 1;
        if (!dontNormalizeMinPercent && percentUsed && percentUsed < 100) {
        sum = Math.round(sum * 100/percentUsed);
        max = Math.round(max * 100/percentUsed);
        }
                // Never return less than 30px wide; mostly this is for design mode where users still need to be able to find and drop widgets into the container.
        if (this.layoutKind == "fluid") return Math.min(this.bounds.w, max);

            var result = ((this.layoutKind == "top-to-bottom") ? max : sum) + extra;
        return Math.max(this.minWidth,Math.max(result, wm.Control.prototype.getMinWidthProp.call(this)));
    },

    /* Get the preferred height of this container, for use if this is a fitToContentHeight container.
     * top-to-bottom container: height is the sum of the heights of all px sized children and the sum of all minHeights for % sized children.
     * left-to-right container: height is the max of the heights of all px sized children and the minHeights for % sized children
     */
    getFluidHeight: function() {
    return this.layout.flow(this,true);
    },
    getPreferredFitToContentHeight: function() {
        if (this.layoutKind == "fluid") return this.getFluidHeight();
        // get the maximum width in this column;
        // and get the sum of height in this row... we'll worry later about whether its a row or column
            var extra = this.padBorderMargin.t + this.padBorderMargin.b;
        var max = 0;
        var sum = 0;
        var percentUsed = 0;
        var v;
        var count = 0;
        for (var i=0, c; c=this.c$[i]; i++) {
            if (this.layout.inFlow(c)) {
                count++;

                if (
                c.fitToContentHeight ||
                    /* If there is a fitToContentHeight panel that contains a Container that is percent sized, then
                     * assume the parent will resize to fit whatever height this % sized container needs.
                     * If c is autoscrolling, then its size is not affected by its children.
                     */
                c instanceof wm.Container && c._percEx.h == 100 && !c.autoScroll && c.parent && (c.parent.fitToContentHeight||c.parent.autoScroll)
                   ) {
                    v = c.getPreferredFitToContentHeight();
                } else if (!c._percEx.h) {
                    v = c.bounds.h;
                } else {
                    v =  c.getMinHeightProp();
                    if (c.bounds.h > v || this.c$.length == 1) {
                    if (percentUsed < 100)
                        percentUsed += c._percEx.h;
                    } else {
                    percentUsed = 100;
                    }
                }
                max = Math.max(max, v);
                sum += v;
            }
        }
        var dontNormalizeMinPercent = count == 1;
        if (!dontNormalizeMinPercent && percentUsed && percentUsed < 100) {
        sum = Math.round(sum * 100/percentUsed);
        max = Math.round(max * 100/percentUsed);
        }

            // never return less than 15px height
            var result =  ((this.layoutKind == "left-to-right") ? max : sum) + extra;
        return Math.max(result, wm.Control.prototype.getMinHeightProp.call(this));
    },
    setBestWidth: function() {
        this._inDesignResize = true;
        this.setWidth(this.getPreferredFitToContentWidth() + "px");
        delete this._inDesignResize;
    },
    setBestHeight: function() {
        this._inDesignResize = true;
        this[this._isDesignLoaded ? "set_height" : "setHeight"](this.getPreferredFitToContentHeight() + "px");
        delete this._inDesignResize;
    },
    getMinWidthProp: function() {
            if (this.fitToContentWidth)
                return this.getPreferredFitToContentWidth();
        else
        return this.inherited(arguments);
    },
    getMinHeightProp: function() {
            if (this.fitToContentHeight)
                return this.getPreferredFitToContentHeight();
        else
        return this.inherited(arguments);
    },
        focusFirstEditor: function() {
        for (var i = 0; i < this.c$.length; i++) {
        var w = this.c$[i];
        if (wm.isInstanceType(w,[wm.AbstractEditor,wm.Editor])) {
            w.focus();
            return w;
        } else if (wm.isInstanceType(w,wm.Container)) {
            var tmp = w.focusFirstEditor();
            if (tmp) return tmp;
        }
        }
        return null;
    },

    // bc
    clearEditors: function(){
        return this.clearData();
    },


    // events
    onEnterKeyPress: function(inEvent){}
});

// this stuff is layout specific

wm.Container.extend({
    layoutKind: "top-to-bottom",
    //layoutFit: false,
    //contentAlign: "leftTop",
    horizontalAlign: "justified",
    verticalAlign: "justified",
    //horizontalAlign: "left",
    //verticalAlign: "top",
    setLayoutKind: function(inLayoutKind) {
        if (this.layoutKind != inLayoutKind || !this.layout) {
          /*
            var ctor = wm.layout.registry[inLayoutKind];
            if (!ctor) {
                return;
            }
            this.layoutKind = inLayoutKind;
            this.layout = new ctor();
          */
          this.layoutKind = inLayoutKind;
          this.layout = wm.layout.cache[inLayoutKind];
        }

            // KANA: for the JobDesigner
        if (this.isDesignLoaded())
            dojo.publish("LayoutKindChanged", [this]);
        this.reflow();
    },
    setHorizontalAlign: function(inHorizAlign) {
        this.horizontalAlign = inHorizAlign;
        this.reflow();
    },
    setVerticalAlign: function(inVertAlign) {
        this.verticalAlign = inVertAlign;
        this.reflow();
    },
    setFitToContentWidth: function(inFitToContent) {
        this.fitToContentWidth = inFitToContent;
        this.fitToContent = this.fitToContentWidth || this.fitToContentHeight;
        this.updateBounds();
        this.reflowParent();
        this.calcFitToContent();
        this.reflowParent();
    },
    setFitToContentHeight: function(inFitToContent) {
        this.fitToContentHeight = inFitToContent;
        this.fitToContent = this.fitToContentWidth || this.fitToContentHeight;
        this.updateBounds();
        this.reflowParent();
        this.calcFitToContent();
        this.reflowParent();
    },
    calcFitToContent: function() {
            if (this.fitToContentHeight) {
            this.height = this.bounds.h + "px";
                        this._percEx.h = 0;
                }
            if (this.fitToContentWidth) {
            this.width = this.bounds.w + "px";
                        this._percEx.w = 0;
                }
    },


    toHtml: function(inWidth) {
        if (this.customToHtml != this.constructor.prototype.customToHtml) return this.customToHtml();
        var html = [];
        var count = 0;
        var hasContents = [];
        for (var i = 0; i < this.c$.length; i++) {
            var c = this.c$[i];
            if (this.layout.inFlow(c)) {
                hasContents[i] = c.toHtml != wm.Control.prototype.toHtml;
                if (hasContents[i] && c.customToHtml != c.constructor.prototype.customToHtml) {
                    var testContent = c.toHtml(inWidth);
                    if (testContent === "" || testContent === undefined || testContent === null) hasContents[i] = false;
                }
                if (hasContents[i]) {
                    count++;
                }
            }
        }


        if (this.layoutKind == "top-to-bottom" || count <= 1) {
            html.push("<div id='" + this.domNode.id + "' class='wmPanelTopToBottom'>");
            for (var i = 0; i < this.c$.length; i++) {
                if (hasContents[i]) {
                    var h = this.c$[i].toHtml(inWidth);
                    if (h) {
                        var style = this.toHtmlStyles();
                        var classes = (this.c$[i]._classes && this.c$[i]._classes.domNode ? this.c$[i]._classes.domNode : []);
                        classes = dojo.filter(classes, function(inClass) {
                            return inClass.indexOf("wm_Font") == 0 || inClass.indexOf("wm_Text") == 0;
                        });
                        classes = classes.join(" ");
                        html.push("<div id='" + this.c$[i].domNode.id + "_Outer' " + style + " class='" + classes + "'>" + h + "</div>");
                    }
                }
            }
        } else {
            var remainingWidth = inWidth - 4; // things start wrapping if we don't have at least 4 extra px space
            var totalPercent = 0;
            var widths = [];
            for (var i = 0; i < this.c$.length; i++) {
                if (hasContents[i]) {
                    var c = this.c$[i];
                    if (!c._percEx.w) {
                        widths[i] = c.bounds.w;
                        remainingWidth -= c.bounds.w;
                    } else {
                        totalPercent += c._percEx.w;
                    }
                }
            }
            for (var i = 0; i < this.c$.length; i++) {
                if (hasContents[i]) {
                    var c = this.c$[i];
                    if (c._percEx.w) {
                        var width = c._percEx.w / totalPercent * remainingWidth;
                        widths[i] = width;
                    }
                }
            }
            html.push("<div id='" + this.domNode.id + "' class='wmPanelLeftToRight'>");
            for (var i = 0; i < this.c$.length; i++) {
                var h = this.c$[i].toHtml(widths[i])
                if (h) {
                    var style = ""; //"style='margin-top: " + this.marginExtents.t + "px;margin-bottom: " + this.marginExtents.b + "px;padding-top: " + this.paddingExtents.t + "px;padding-bottom: " + this.paddingExtents.b + "px;'";
                    var classes = (this.c$[i]._classes && this.c$[i]._classes.domNode ? this.c$[i]._classes.domNode : []);
                    classes = dojo.filter(classes, function(inClass) {
                        return inClass.indexOf("wm_Font") == 0 || inClass.indexOf("wm_Text") == 0;
                    });
                    classes = classes.join(" ");
                    html.push("<div id='" + this.c$[i].domNode.id + "_Outer' style='width:" + widths[i] + "px;' " + style + " class='" + classes + "'>" + h + "</div>");
                }
            }
        }
        html.push("</div>");
        return html.join("");
    }
});

wm.Container.delayedReflowWidgets = {};
wm.Container._delayedReflowWidgetsId = 0;
wm.Container.runDelayedReflow = function() {
    var widgets = wm.Container.delayedReflowWidgets;
    wm.Container.delayedReflowWidgets = {};
    wm.Container._delayedReflowWidgetsId = 0;
    wm.forEachProperty(widgets, function(widget,widgetId) {
    if (!widget.isDestroyed)
        widget.reflow();
    });
};

}

if(!dojo._hasResource["wm.base.widget.Layers.Decorator"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.widget.Layers.Decorator"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide("wm.base.widget.Layers.Decorator");

dojo.declare("wm.LayersDecorator", null, {
	decorationClass: "",
	constructor: function(inDecoree) {
		this.decoree = inDecoree;
	},
	destroy: function() {
		this.decoree = null;
	},
	decorate: function() {
		this.decorateContainer();
		this.decorateLayers();
	},
	decorateContainer: function() {
		var d = this.decoree;
		dojo.addClass(d.domNode, this.decorationClass);
	},
	decorateLayers: function() {
		dojo.forEach(this.decoree.layers, function(l, i) {
			this.decorateLayer(l, i);
		}, this);
	},
	decorateLayer: function(inLayer, inIndex) {
		inLayer.decorator = this;
	},
	undecorate: function() {
		this.undecorateContainer();
	    var layers = this.decoree.layers;
	    for (var i = layers.length-1; i >= 0; i--) {
			this.undecorateLayer(layers[i], i);
	    }
	},
	undecorateContainer: function() {
		dojo.removeClass(this.decoree.domNode, this.decorationClass);
	},
	undecorateLayer: function() {
	},
	setLayerShowing: function(inLayer, inShowing) {
	    if (this.active) {
		wm.Control.prototype.setShowing.call(inLayer, inShowing);
	    } else {
		inLayer.showing = inShowing;
	    }
	},
	setLayerActive: function(inLayer, inActive) {
	    if (inLayer.active == inActive && inLayer.domNode.style.display != "none")
		return;

	    inLayer.inFlow = inActive;
	    inLayer.active = inActive;

	    var page = inLayer.getParentPage();
	    if (dojo.isIE <= 9 || wm.isAndroid <= 3 || /* Browsers not supported for animation */
		this.decoree._cupdating || !page  || page._loadingPage || window["studio"] || /* No animation during widget creation/pageloading */
		!this.decoree.transition || this.decoree.transition === "none") /* Or developer says no animation */
	    { 
		inLayer.domNode.style.display = inActive ? '' : 'none';
		if (inActive) {
		    inLayer.reflowParent();
		}
	    } else {
		this.anim(inLayer, inActive);
	    }
/*
	    if (inActive) {
		inLayer.reflowParent();
	    }
	    */
		// design only code: need to show / hide designwrapper
		wm.fire(inLayer, 'domNodeShowingChanged', [inActive]);
	},
        anim: function(inLayer, inShowing) {
/*
	    if (inShowing) {
		// Need to render it so it will slide correctly; needs to be non-hidden (but set opacity as low as it will go so its not visible either)
		inLayer.domNode.style.opacity = "0.1"; 
		inLayer.domNode.style.display = "";

		// ok, now move it to its starting positino and reset opacity
		var left = inLayer.bounds.w + "px";
		inLayer.domNode.style.left = (inLayer._transitionNext) ? left : "-" + left;
		inLayer.domNode.style.opacity = 1;

	    }
	    var newleft = (inShowing) ? 0 : inLayer._transitionNext ? - parseInt(inLayer.domNode.style.width) : parseInt(inLayer.domNode.style.width);
	    var anim = dojo.animateProperty({
		node: inLayer.domNode,
		properties:{
		    left: newleft
		},
		duration: 350
	    });
	    dojo.connect(anim,"onEnd", function(){
		if (!inShowing) {
		    inLayer.domNode.style.display = "none";
		    inLayer.domNode.style.left = 0;
		}
	    });
	    anim.play();
	    */

	    if (!inLayer._transitionEndSub) {
		if (!dojo.isIE || dojo.isIE >= 10) {
		    var transitionEnd;
		    if (dojo.isWebKit) {
			transitionEnd = 'webkitAnimationEnd';
		    } else if (dojo.isOpera) {
			transitionEnd = 'oanimationend';
		    } else if (dojo.isIE) {
			transitionEnd = 'MSAnimationEnd';
		    } else {
			transitionEnd = "animationend";
		    }
		    inLayer.domNode.addEventListener( 
			transitionEnd,
			function( event ) { 
			    if (!inLayer.isActive()) {
				inLayer.domNode.style.display = "none";
				inLayer.domNode.style.opacity = 1;
			    }
			}, false );
		    inLayer._transitionEndSub = true;
		}
	    }
	    var transition =this.decoree.transition;
	    dojo.removeClass(inLayer.domNode, [transition + "OutLeftAnim",transition + "OutRightAnim",transition + "InLeftAnim",transition + "InRightAnim"]);
	    if (!inShowing) {
		var direction = inLayer._transitionNext ? "Left" : "Right"
		dojo.addClass(inLayer.domNode, transition + "Out" + (direction) + "Anim");
	    } else {
		var direction = inLayer._transitionNext ? "Left" : "Right";
		//inLayer.domNode.style.left = (direction == "Left") ? "100%" : "-100%"; // not needed for native android 4x browser, nor chrome on tablet

		inLayer.domNode.style.display = "";
		dojo.addClass(inLayer.domNode, transition + "In" + (direction) + "Anim");
		inLayer.reflowParent();
	    }
    },
    animFade: function(inLayer, inShowing) {
	    if (inShowing) {
		inLayer.domNode.style.opacity = 0.01; // can't fade in if its opacity starts at 1!
		inLayer.domNode.style.display = "";
	    }
	    var newopacity = (inShowing) ? 1 : 0.01;
	    var anim = dojo.animateProperty({
		node: inLayer.domNode,
		properties:{
		    opacity: newopacity
		},
		duration: 350
	    });
	    dojo.connect(anim,"onEnd", function(){
		if (!inShowing) {
		    inLayer.domNode.style.display = "none";
		    inLayer.domNode.style.opacity = 1;
		} else {
		    inLayer.reflow();
		}
	    });
	    anim.play();

    },

	activateLayer: function(inLayer) {
		var d = this.decoree;
		var old = d.getLayer(d.lastLayerIndex);
	        if (old && old != inLayer) {
		        old._transitionNext = inLayer._transitionNext = inLayer.getIndex() > old.getIndex();
			this.setLayerActive(old, false);		    
		}
		this.setLayerActive(inLayer, true);
	    //d.reflowParent();
	},
	// default decorator has no caption
	applyLayerCaption: function() {
	},
	moveLayerIndex: function(inFromIndex, inToIndex) {
		var d = this.decoree, l = d.getLayer(inFromIndex);
		// move in client
		d.client.removeControl(l);
		d.client.insertControl(l, inToIndex);
	}
});

}

if(!dojo._hasResource["dojo.dnd.common"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.common"] = true;
dojo.provide("dojo.dnd.common");


dojo.getObject("dnd", true, dojo);

dojo.dnd.getCopyKeyState = dojo.isCopyKey;

dojo.dnd._uniqueId = 0;
dojo.dnd.getUniqueId = function(){
	// summary:
	//		returns a unique string for use with any DOM element
	var id;
	do{
		id = dojo._scopeName + "Unique" + (++dojo.dnd._uniqueId);
	}while(dojo.byId(id));
	return id;
};

dojo.dnd._empty = {};

dojo.dnd.isFormElement = function(/*Event*/ e){
	// summary:
	//		returns true if user clicked on a form element
	var t = e.target;
	if(t.nodeType == 3 /*TEXT_NODE*/){
		t = t.parentNode;
	}
	return " button textarea input select option ".indexOf(" " + t.tagName.toLowerCase() + " ") >= 0;	// Boolean
};

}

if(!dojo._hasResource["dojo.date.stamp"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.date.stamp"] = true;
dojo.provide("dojo.date.stamp");


dojo.getObject("date.stamp", true, dojo);

// Methods to convert dates to or from a wire (string) format using well-known conventions

dojo.date.stamp.fromISOString = function(/*String*/formattedString, /*Number?*/defaultTime){
	//	summary:
	//		Returns a Date object given a string formatted according to a subset of the ISO-8601 standard.
	//
	//	description:
	//		Accepts a string formatted according to a profile of ISO8601 as defined by
	//		[RFC3339](http://www.ietf.org/rfc/rfc3339.txt), except that partial input is allowed.
	//		Can also process dates as specified [by the W3C](http://www.w3.org/TR/NOTE-datetime)
	//		The following combinations are valid:
	//
	//			* dates only
	//			|	* yyyy
	//			|	* yyyy-MM
	//			|	* yyyy-MM-dd
	// 			* times only, with an optional time zone appended
	//			|	* THH:mm
	//			|	* THH:mm:ss
	//			|	* THH:mm:ss.SSS
	// 			* and "datetimes" which could be any combination of the above
	//
	//		timezones may be specified as Z (for UTC) or +/- followed by a time expression HH:mm
	//		Assumes the local time zone if not specified.  Does not validate.  Improperly formatted
	//		input may return null.  Arguments which are out of bounds will be handled
	// 		by the Date constructor (e.g. January 32nd typically gets resolved to February 1st)
	//		Only years between 100 and 9999 are supported.
	//
  	//	formattedString:
	//		A string such as 2005-06-30T08:05:00-07:00 or 2005-06-30 or T08:05:00
	//
	//	defaultTime:
	//		Used for defaults for fields omitted in the formattedString.
	//		Uses 1970-01-01T00:00:00.0Z by default.

	if(!dojo.date.stamp._isoRegExp){
		dojo.date.stamp._isoRegExp =
//TODO: could be more restrictive and check for 00-59, etc.
			/^(?:(\d{4})(?:-(\d{2})(?:-(\d{2}))?)?)?(?:T(\d{2}):(\d{2})(?::(\d{2})(.\d+)?)?((?:[+-](\d{2}):(\d{2}))|Z)?)?$/;
	}

	var match = dojo.date.stamp._isoRegExp.exec(formattedString),
		result = null;

	if(match){
		match.shift();
		if(match[1]){match[1]--;} // Javascript Date months are 0-based
		if(match[6]){match[6] *= 1000;} // Javascript Date expects fractional seconds as milliseconds

		if(defaultTime){
			// mix in defaultTime.  Relatively expensive, so use || operators for the fast path of defaultTime === 0
			defaultTime = new Date(defaultTime);
			dojo.forEach(dojo.map(["FullYear", "Month", "Date", "Hours", "Minutes", "Seconds", "Milliseconds"], function(prop){
				return defaultTime["get" + prop]();
			}), function(value, index){
				match[index] = match[index] || value;
			});
		}
		result = new Date(match[0]||1970, match[1]||0, match[2]||1, match[3]||0, match[4]||0, match[5]||0, match[6]||0); //TODO: UTC defaults
		if(match[0] < 100){
			result.setFullYear(match[0] || 1970);
		}

		var offset = 0,
			zoneSign = match[7] && match[7].charAt(0);
		if(zoneSign != 'Z'){
			offset = ((match[8] || 0) * 60) + (Number(match[9]) || 0);
			if(zoneSign != '-'){ offset *= -1; }
		}
		if(zoneSign){
			offset -= result.getTimezoneOffset();
		}
		if(offset){
			result.setTime(result.getTime() + offset * 60000);
		}
	}

	return result; // Date or null
};

/*=====
	dojo.date.stamp.__Options = function(){
		//	selector: String
		//		"date" or "time" for partial formatting of the Date object.
		//		Both date and time will be formatted by default.
		//	zulu: Boolean
		//		if true, UTC/GMT is used for a timezone
		//	milliseconds: Boolean
		//		if true, output milliseconds
		this.selector = selector;
		this.zulu = zulu;
		this.milliseconds = milliseconds;
	}
=====*/

dojo.date.stamp.toISOString = function(/*Date*/dateObject, /*dojo.date.stamp.__Options?*/options){
	//	summary:
	//		Format a Date object as a string according a subset of the ISO-8601 standard
	//
	//	description:
	//		When options.selector is omitted, output follows [RFC3339](http://www.ietf.org/rfc/rfc3339.txt)
	//		The local time zone is included as an offset from GMT, except when selector=='time' (time without a date)
	//		Does not check bounds.  Only years between 100 and 9999 are supported.
	//
	//	dateObject:
	//		A Date object

	var _ = function(n){ return (n < 10) ? "0" + n : n; };
	options = options || {};
	var formattedDate = [],
		getter = options.zulu ? "getUTC" : "get",
		date = "";
	if(options.selector != "time"){
		var year = dateObject[getter+"FullYear"]();
		date = ["0000".substr((year+"").length)+year, _(dateObject[getter+"Month"]()+1), _(dateObject[getter+"Date"]())].join('-');
	}
	formattedDate.push(date);
	if(options.selector != "date"){
		var time = [_(dateObject[getter+"Hours"]()), _(dateObject[getter+"Minutes"]()), _(dateObject[getter+"Seconds"]())].join(':');
		var millis = dateObject[getter+"Milliseconds"]();
		if(options.milliseconds){
			time += "."+ (millis < 100 ? "0" : "") + _(millis);
		}
		if(options.zulu){
			time += "Z";
		}else if(options.selector != "time"){
			var timezoneOffset = dateObject.getTimezoneOffset();
			var absOffset = Math.abs(timezoneOffset);
			time += (timezoneOffset > 0 ? "-" : "+") +
				_(Math.floor(absOffset/60)) + ":" + _(absOffset%60);
		}
		formattedDate.push(time);
	}
	return formattedDate.join('T'); // String
};

}

if(!dojo._hasResource["dojo.parser"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.parser"] = true;
dojo.provide("dojo.parser");




new Date("X"); // workaround for #11279, new Date("") == NaN

dojo.parser = new function(){
	// summary:
	//		The Dom/Widget parsing package

	var d = dojo;

	function val2type(/*Object*/ value){
		// summary:
		//		Returns name of type of given value.

		if(d.isString(value)){ return "string"; }
		if(typeof value == "number"){ return "number"; }
		if(typeof value == "boolean"){ return "boolean"; }
		if(d.isFunction(value)){ return "function"; }
		if(d.isArray(value)){ return "array"; } // typeof [] == "object"
		if(value instanceof Date) { return "date"; } // assume timestamp
		if(value instanceof d._Url){ return "url"; }
		return "object";
	}

	function str2obj(/*String*/ value, /*String*/ type){
		// summary:
		//		Convert given string value to given type
		switch(type){
			case "string":
				return value;
			case "number":
				return value.length ? Number(value) : NaN;
			case "boolean":
				// for checked/disabled value might be "" or "checked".	 interpret as true.
				return typeof value == "boolean" ? value : !(value.toLowerCase()=="false");
			case "function":
				if(d.isFunction(value)){
					// IE gives us a function, even when we say something like onClick="foo"
					// (in which case it gives us an invalid function "function(){ foo }").
					//	Therefore, convert to string
					value=value.toString();
					value=d.trim(value.substring(value.indexOf('{')+1, value.length-1));
				}
				try{
					if(value === "" || value.search(/[^\w\.]+/i) != -1){
						// The user has specified some text for a function like "return x+5"
						return new Function(value);
					}else{
						// The user has specified the name of a function like "myOnClick"
						// or a single word function "return"
						return d.getObject(value, false) || new Function(value);
					}
				}catch(e){ return new Function(); }
			case "array":
				return value ? value.split(/\s*,\s*/) : [];
			case "date":
				switch(value){
					case "": return new Date("");	// the NaN of dates
					case "now": return new Date();	// current date
					default: return d.date.stamp.fromISOString(value);
				}
			case "url":
				return d.baseUrl + value;
			default:
				return d.fromJson(value);
		}
	}

	var dummyClass = {}, instanceClasses = {
		// map from fully qualified name (like "dijit.Button") to structure like
		// { cls: dijit.Button, params: {label: "string", disabled: "boolean"} }
	};

	// Widgets like BorderContainer add properties to _Widget via dojo.extend().
	// If BorderContainer is loaded after _Widget's parameter list has been cached,
	// we need to refresh that parameter list (for _Widget and all widgets that extend _Widget).
	// TODO: remove this in 2.0, when we stop caching parameters.
	d.connect(d, "extend", function(){
		instanceClasses = {};
	});

	function getProtoInfo(cls, params){
		// cls: A prototype
		//		The prototype of the class to check props on
		// params: Object
		//		The parameters object to mix found parameters onto.
		for(var name in cls){
			if(name.charAt(0)=="_"){ continue; }	// skip internal properties
			if(name in dummyClass){ continue; }		// skip "constructor" and "toString"
			params[name] = val2type(cls[name]);
		}
		return params;
	}

	function getClassInfo(/*String*/ className, /*Boolean*/ skipParamsLookup){
		// summary:
		//		Maps a widget name string like "dijit.form.Button" to the widget constructor itself,
		//		and a list of that widget's parameters and their types
		// className:
		//		fully qualified name (like "dijit.form.Button")
		// returns:
		//		structure like
		//			{
		//				cls: dijit.Button,
		//				params: { label: "string", disabled: "boolean"}
		//			}

		var c = instanceClasses[className];
		if(!c){
			// get pointer to widget class
			var cls = d.getObject(className), params = null;
			if(!cls){ return null; }		// class not defined [yet]
			if(!skipParamsLookup){ // from fastpath, we don't need to lookup the attrs on the proto because they are explicit
				params = getProtoInfo(cls.prototype, {})
			}
			c = { cls: cls, params: params };
			
		}else if(!skipParamsLookup && !c.params){
			// if we're calling getClassInfo and have a cls proto, but no params info, scan that cls for params now
			// and update the pointer in instanceClasses[className]. This happens when a widget appears in another
			// widget's template which still uses dojoType, but an instance of the widget appears prior with a data-dojo-type,
			// skipping this lookup the first time.
			c.params = getProtoInfo(c.cls.prototype, {});
		}
		
		return c;
	}

	this._functionFromScript = function(script, attrData){
		// summary:
		//		Convert a <script type="dojo/method" args="a, b, c"> ... </script>
		//		into a function
		// script: DOMNode
		//		The <script> DOMNode
		// attrData: String
		//		For HTML5 compliance, searches for attrData + "args" (typically
		//		"data-dojo-args") instead of "args"
		var preamble = "";
		var suffix = "";
		var argsStr = (script.getAttribute(attrData + "args") || script.getAttribute("args"));
		if(argsStr){
			d.forEach(argsStr.split(/\s*,\s*/), function(part, idx){
				preamble += "var "+part+" = arguments["+idx+"]; ";
			});
		}
		var withStr = script.getAttribute("with");
		if(withStr && withStr.length){
			d.forEach(withStr.split(/\s*,\s*/), function(part){
				preamble += "with("+part+"){";
				suffix += "}";
			});
		}
		return new Function(preamble+script.innerHTML+suffix);
	};

	this.instantiate = function(/* Array */nodes, /* Object? */mixin, /* Object? */args){
		// summary:
		//		Takes array of nodes, and turns them into class instances and
		//		potentially calls a startup method to allow them to connect with
		//		any children.
		// nodes: Array
		//		Array of nodes or objects like
		//	|		{
		//	|			type: "dijit.form.Button",
		//	|			node: DOMNode,
		//	|			scripts: [ ... ],	// array of <script type="dojo/..."> children of node
		//	|			inherited: { ... }	// settings inherited from ancestors like dir, theme, etc.
		//	|		}
		// mixin: Object?
		//		An object that will be mixed in with each node in the array.
		//		Values in the mixin will override values in the node, if they
		//		exist.
		// args: Object?
		//		An object used to hold kwArgs for instantiation.
		//		See parse.args argument for details.

		var thelist = [],
		mixin = mixin||{};
		args = args||{};

		// TODO: for 2.0 default to data-dojo- regardless of scopeName (or maybe scopeName won't exist in 2.0)
		var attrName = (args.scope || d._scopeName) + "Type",	// typically "dojoType"
			attrData = "data-" + (args.scope || d._scopeName) + "-";	// typically "data-dojo-"

		d.forEach(nodes, function(obj){
			if(!obj){ return; }

			// Get pointers to DOMNode, dojoType string, and clsInfo (metadata about the dojoType), etc.
			var node, type, clsInfo, clazz, scripts, fastpath;
			if(obj.node){
				// new format of nodes[] array, object w/lots of properties pre-computed for me
				node = obj.node;
				type = obj.type;
				fastpath = obj.fastpath;
				clsInfo = obj.clsInfo || (type && getClassInfo(type, fastpath));
				clazz = clsInfo && clsInfo.cls;
				scripts = obj.scripts;
			}else{
				// old (backwards compatible) format of nodes[] array, simple array of DOMNodes. no fastpath/data-dojo-type support here.
				node = obj;
				type = attrName in mixin ? mixin[attrName] : node.getAttribute(attrName);
				clsInfo = type && getClassInfo(type);
				clazz = clsInfo && clsInfo.cls;
				scripts = (clazz && (clazz._noScript || clazz.prototype._noScript) ? [] :
							d.query("> script[type^='dojo/']", node));
			}
			if(!clsInfo){
				throw new Error("Could not load class '" + type);
			}

			// Setup hash to hold parameter settings for this widget.	Start with the parameter
			// settings inherited from ancestors ("dir" and "lang").
			// Inherited setting may later be overridden by explicit settings on node itself.
			var params = {};
				
			if(args.defaults){
				// settings for the document itself (or whatever subtree is being parsed)
				d._mixin(params, args.defaults);
			}
			if(obj.inherited){
				// settings from dir=rtl or lang=... on a node above this node
				d._mixin(params, obj.inherited);
			}
			
			// mix things found in data-dojo-props into the params
			if(fastpath){
				var extra = node.getAttribute(attrData + "props");
				if(extra && extra.length){
					try{
						extra = d.fromJson.call(args.propsThis, "{" + extra + "}");
						d._mixin(params, extra);
					}catch(e){
						// give the user a pointer to their invalid parameters. FIXME: can we kill this in production?
						throw new Error(e.toString() + " in data-dojo-props='" + extra + "'");
					}
				}

				// For the benefit of _Templated, check if node has data-dojo-attach-point/data-dojo-attach-event
				// and mix those in as though they were parameters
				var attachPoint = node.getAttribute(attrData + "attach-point");
				if(attachPoint){
					params.dojoAttachPoint = attachPoint;
				}
				var attachEvent = node.getAttribute(attrData + "attach-event");
				if(attachEvent){
					params.dojoAttachEvent = attachEvent;
				}
				dojo.mixin(params, mixin);
			}else{
				// FIXME: we need something like "deprecateOnce()" to throw dojo.deprecation for something.
				// remove this logic in 2.0
				// read parameters (ie, attributes) specified on DOMNode

				var attributes = node.attributes;

				// clsInfo.params lists expected params like {"checked": "boolean", "n": "number"}
				for(var name in clsInfo.params){
					var item = name in mixin ? { value:mixin[name], specified:true } : attributes.getNamedItem(name);
					if(!item || (!item.specified && (!dojo.isIE || name.toLowerCase()!="value"))){ continue; }
					var value = item.value;
					// Deal with IE quirks for 'class' and 'style'
					switch(name){
					case "class":
						value = "className" in mixin ? mixin.className : node.className;
						break;
					case "style":
						value = "style" in mixin ? mixin.style : (node.style && node.style.cssText); // FIXME: Opera?
					}
					var _type = clsInfo.params[name];
					if(typeof value == "string"){
						params[name] = str2obj(value, _type);
					}else{
						params[name] = value;
					}
				}
			}

			// Process <script type="dojo/*"> script tags
			// <script type="dojo/method" event="foo"> tags are added to params, and passed to
			// the widget on instantiation.
			// <script type="dojo/method"> tags (with no event) are executed after instantiation
			// <script type="dojo/connect" event="foo"> tags are dojo.connected after instantiation
			// note: dojo/* script tags cannot exist in self closing widgets, like <input />
			var connects = [],	// functions to connect after instantiation
				calls = [];		// functions to call after instantiation

			d.forEach(scripts, function(script){
				node.removeChild(script);
				// FIXME: drop event="" support in 2.0. use data-dojo-event="" instead
				var event = (script.getAttribute(attrData + "event") || script.getAttribute("event")),
					type = script.getAttribute("type"),
					nf = d.parser._functionFromScript(script, attrData);
				if(event){
					if(type == "dojo/connect"){
						connects.push({event: event, func: nf});
					}else{
						params[event] = nf;
					}
				}else{
					calls.push(nf);
				}
			});

			var markupFactory = clazz.markupFactory || clazz.prototype && clazz.prototype.markupFactory;
			// create the instance
			var instance = markupFactory ? markupFactory(params, node, clazz) : new clazz(params, node);
			thelist.push(instance);

			// map it to the JS namespace if that makes sense
			// FIXME: in 2.0, drop jsId support. use data-dojo-id instead
			var jsname = (node.getAttribute(attrData + "id") || node.getAttribute("jsId"));
			if(jsname){
				d.setObject(jsname, instance);
			}

			// process connections and startup functions
			d.forEach(connects, function(connect){
				d.connect(instance, connect.event, null, connect.func);
			});
			d.forEach(calls, function(func){
				func.call(instance);
			});
		});

		// Call startup on each top level instance if it makes sense (as for
		// widgets).  Parent widgets will recursively call startup on their
		// (non-top level) children
		if(!mixin._started){
			// TODO: for 2.0, when old instantiate() API is desupported, store parent-child
			// relationships in the nodes[] array so that no getParent() call is needed.
			// Note that will  require a parse() call from ContentPane setting a param that the
			// ContentPane is the parent widget (so that the parse doesn't call startup() on the
			// ContentPane's children)
			d.forEach(thelist, function(instance){
				if( !args.noStart && instance  &&
					dojo.isFunction(instance.startup) &&
					!instance._started &&
					(!instance.getParent || !instance.getParent())
				){
					instance.startup();
				}
			});
		}
		return thelist;
	};

	this.parse = function(rootNode, args){
		// summary:
		//		Scan the DOM for class instances, and instantiate them.
		//
		// description:
		//		Search specified node (or root node) recursively for class instances,
		//		and instantiate them. Searches for either data-dojo-type="Class" or
		//		dojoType="Class" where "Class" is a a fully qualified class name,
		//		like `dijit.form.Button`
		//
		//		Using `data-dojo-type`:
		//		Attributes using can be mixed into the parameters used to instantitate the
		//		Class by using a `data-dojo-props` attribute on the node being converted.
		//		`data-dojo-props` should be a string attribute to be converted from JSON.
		//
		//		Using `dojoType`:
		//		Attributes are read from the original domNode and converted to appropriate
		//		types by looking up the Class prototype values. This is the default behavior
		//		from Dojo 1.0 to Dojo 1.5. `dojoType` support is deprecated, and will
		//		go away in Dojo 2.0.
		//
		// rootNode: DomNode?
		//		A default starting root node from which to start the parsing. Can be
		//		omitted, defaulting to the entire document. If omitted, the `args`
		//		object can be passed in this place. If the `args` object has a
		//		`rootNode` member, that is used.
		//
		// args: Object
		//		a kwArgs object passed along to instantiate()
		//
		//			* noStart: Boolean?
		//				when set will prevent the parser from calling .startup()
		//				when locating the nodes.
		//			* rootNode: DomNode?
		//				identical to the function's `rootNode` argument, though
		//				allowed to be passed in via this `args object.
		//			* template: Boolean
		//				If true, ignores ContentPane's stopParser flag and parses contents inside of
		//				a ContentPane inside of a template.   This allows dojoAttachPoint on widgets/nodes
		//				nested inside the ContentPane to work.
		//			* inherited: Object
		//				Hash possibly containing dir and lang settings to be applied to
		//				parsed widgets, unless there's another setting on a sub-node that overrides
		//			* scope: String
		//				Root for attribute names to search for.   If scopeName is dojo,
		//				will search for data-dojo-type (or dojoType).   For backwards compatibility
		//				reasons defaults to dojo._scopeName (which is "dojo" except when
		//				multi-version support is used, when it will be something like dojo16, dojo20, etc.)
		//			* propsThis: Object
		//				If specified, "this" referenced from data-dojo-props will refer to propsThis.
		//				Intended for use from the widgets-in-template feature of `dijit._Templated`
		//
		// example:
		//		Parse all widgets on a page:
		//	|		dojo.parser.parse();
		//
		// example:
		//		Parse all classes within the node with id="foo"
		//	|		dojo.parser.parse(dojo.byId('foo'));
		//
		// example:
		//		Parse all classes in a page, but do not call .startup() on any
		//		child
		//	|		dojo.parser.parse({ noStart: true })
		//
		// example:
		//		Parse all classes in a node, but do not call .startup()
		//	|		dojo.parser.parse(someNode, { noStart:true });
		//	|		// or
		//	|		dojo.parser.parse({ noStart:true, rootNode: someNode });

		// determine the root node based on the passed arguments.
		var root;
		if(!args && rootNode && rootNode.rootNode){
			args = rootNode;
			root = args.rootNode;
		}else{
			root = rootNode;
		}
		root = root ? dojo.byId(root) : dojo.body();
		args = args || {};

		var attrName = (args.scope || d._scopeName) + "Type",		// typically "dojoType"
			attrData = "data-" + (args.scope || d._scopeName) + "-";	// typically "data-dojo-"

		function scan(parent, list){
			// summary:
			//		Parent is an Object representing a DOMNode, with or without a dojoType specified.
			//		Scan parent's children looking for nodes with dojoType specified, storing in list[].
			//		If parent has a dojoType, also collects <script type=dojo/*> children and stores in parent.scripts[].
			// parent: Object
			//		Object representing the parent node, like
			//	|	{
			//	|		node: DomNode,			// scan children of this node
			//	|		inherited: {dir: "rtl"},	// dir/lang setting inherited from above node
			//	|
			//	|		// attributes only set if node has dojoType specified
			//	|		scripts: [],			// empty array, put <script type=dojo/*> in here
			//	|		clsInfo: { cls: dijit.form.Button, ...}
			//	|	}
			// list: DomNode[]
			//		Output array of objects (same format as parent) representing nodes to be turned into widgets

			// Effective dir and lang settings on parent node, either set directly or inherited from grandparent
			var inherited = dojo.clone(parent.inherited);
			dojo.forEach(["dir", "lang"], function(name){
				// TODO: what if this is a widget and dir/lang are declared in data-dojo-props?
				var val = parent.node.getAttribute(name);
				if(val){
					inherited[name] = val;
				}
			});

			// if parent is a widget, then search for <script type=dojo/*> tags and put them in scripts[].
			var scripts = parent.clsInfo && !parent.clsInfo.cls.prototype._noScript ? parent.scripts : null;

			// unless parent is a widget with the stopParser flag set, continue search for dojoType, recursively
			var recurse = (!parent.clsInfo || !parent.clsInfo.cls.prototype.stopParser) || (args && args.template);

			// scan parent's children looking for dojoType and <script type=dojo/*>
			for(var child = parent.node.firstChild; child; child = child.nextSibling){
				if(child.nodeType == 1){
					// FIXME: desupport dojoType in 2.0. use data-dojo-type instead
					var type, html5 = recurse && child.getAttribute(attrData + "type");
					if(html5){
						type = html5;
					}else{
						// fallback to backward compatible mode, using dojoType. remove in 2.0
						type = recurse && child.getAttribute(attrName);
					}
					
					var fastpath = html5 == type;

					if(type){
						// if dojoType/data-dojo-type specified, add to output array of nodes to instantiate
						var params = {
							"type": type,
							fastpath: fastpath,
							clsInfo: getClassInfo(type, fastpath), // note: won't find classes declared via dojo.Declaration
							node: child,
							scripts: [], // <script> nodes that are parent's children
							inherited: inherited // dir & lang attributes inherited from parent
						};
						list.push(params);

						// Recurse, collecting <script type="dojo/..."> children, and also looking for
						// descendant nodes with dojoType specified (unless the widget has the stopParser flag),
						scan(params, list);
					}else if(scripts && child.nodeName.toLowerCase() == "script"){
						// if <script type="dojo/...">, save in scripts[]
						type = child.getAttribute("type");
						if (type && /^dojo\/\w/i.test(type)) {
							scripts.push(child);
						}
					}else if(recurse){
						// Recurse, looking for grandchild nodes with dojoType specified
						scan({
							node: child,
							inherited: inherited
						}, list);
					}
				}
			}
		}

		// Ignore bogus entries in inherited hash like {dir: ""}
		var inherited = {};
		if(args && args.inherited){
			for(var key in args.inherited){
				if(args.inherited[key]){ inherited[key] = args.inherited[key]; }
			}
		}

		// Make list of all nodes on page w/dojoType specified
		var list = [];
		scan({
			node: root,
			inherited: inherited
		}, list);

		// go build the object instances
		var mixin = args && args.template ? {template: true} : null;
		return this.instantiate(list, mixin, args); // Array
	};
}();

//Register the parser callback. It should be the first callback
//after the a11y test.

(function(){
	var parseRunner = function(){
		if(dojo.config.parseOnLoad){
			dojo.parser.parse();
		}
	};

	// FIXME: need to clobber cross-dependency!!
	if(dojo.getObject("dijit.wai.onload") === dojo._loaders[0]){
		dojo._loaders.splice(1, 0, parseRunner);
	}else{
		dojo._loaders.unshift(parseRunner);
	}
})();

}

if(!dojo._hasResource["dojo.dnd.Container"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.Container"] = true;
dojo.provide("dojo.dnd.Container");





/*
	Container states:
		""		- normal state
		"Over"	- mouse over a container
	Container item states:
		""		- normal state
		"Over"	- mouse over a container item
*/

/*=====
dojo.declare("dojo.dnd.__ContainerArgs", [], {
	creator: function(){
		// summary:
		//		a creator function, which takes a data item, and returns an object like that:
		//		{node: newNode, data: usedData, type: arrayOfStrings}
	},

	// skipForm: Boolean
	//		don't start the drag operation, if clicked on form elements
	skipForm: false,

	// dropParent: Node||String
	//		node or node's id to use as the parent node for dropped items
	//		(must be underneath the 'node' parameter in the DOM)
	dropParent: null,

	// _skipStartup: Boolean
	//		skip startup(), which collects children, for deferred initialization
	//		(this is used in the markup mode)
	_skipStartup: false
});

dojo.dnd.Item = function(){
	// summary:
	//		Represents (one of) the source node(s) being dragged.
	//		Contains (at least) the "type" and "data" attributes.
	// type: String[]
	//		Type(s) of this item, by default this is ["text"]
	// data: Object
	//		Logical representation of the object being dragged.
	//		If the drag object's type is "text" then data is a String,
	//		if it's another type then data could be a different Object,
	//		perhaps a name/value hash.
	
	this.type = type;
	this.data = data;
}
=====*/

dojo.declare("dojo.dnd.Container", null, {
	// summary:
	//		a Container object, which knows when mouse hovers over it,
	//		and over which element it hovers
	
	// object attributes (for markup)
	skipForm: false,
	
	/*=====
	// current: DomNode
	//		The DOM node the mouse is currently hovered over
	current: null,
	
	// map: Hash<String, dojo.dnd.Item>
	//		Map from an item's id (which is also the DOMNode's id) to
	//		the dojo.dnd.Item itself.
	map: {},
	=====*/
	
	constructor: function(node, params){
		// summary:
		//		a constructor of the Container
		// node: Node
		//		node or node's id to build the container on
		// params: dojo.dnd.__ContainerArgs
		//		a dictionary of parameters
		this.node = dojo.byId(node);
		if(!params){ params = {}; }
		this.creator = params.creator || null;
		this.skipForm = params.skipForm;
		this.parent = params.dropParent && dojo.byId(params.dropParent);
		
		// class-specific variables
		this.map = {};
		this.current = null;

		// states
		this.containerState = "";
		dojo.addClass(this.node, "dojoDndContainer");
		
		// mark up children
		if(!(params && params._skipStartup)){
			this.startup();
		}

		// set up events
		this.events = [
			dojo.connect(this.node, "onmouseover", this, "onMouseOver"),
			dojo.connect(this.node, "onmouseout",  this, "onMouseOut"),
			// cancel text selection and text dragging
			dojo.connect(this.node, "ondragstart",   this, "onSelectStart"),
			dojo.connect(this.node, "onselectstart", this, "onSelectStart")
		];
	},
	
	// object attributes (for markup)
	creator: function(){
		// summary:
		//		creator function, dummy at the moment
	},
	
	// abstract access to the map
	getItem: function(/*String*/ key){
		// summary:
		//		returns a data item by its key (id)
		return this.map[key];	// dojo.dnd.Item
	},
	setItem: function(/*String*/ key, /*dojo.dnd.Item*/ data){
		// summary:
		//		associates a data item with its key (id)
		this.map[key] = data;
	},
	delItem: function(/*String*/ key){
		// summary:
		//		removes a data item from the map by its key (id)
		delete this.map[key];
	},
	forInItems: function(/*Function*/ f, /*Object?*/ o){
		// summary:
		//		iterates over a data map skipping members that
		//		are present in the empty object (IE and/or 3rd-party libraries).
		o = o || dojo.global;
		var m = this.map, e = dojo.dnd._empty;
		for(var i in m){
			if(i in e){ continue; }
			f.call(o, m[i], i, this);
		}
		return o;	// Object
	},
	clearItems: function(){
		// summary:
		//		removes all data items from the map
		this.map = {};
	},
	
	// methods
	getAllNodes: function(){
		// summary:
		//		returns a list (an array) of all valid child nodes
		return dojo.query("> .dojoDndItem", this.parent);	// NodeList
	},
	sync: function(){
		// summary:
		//		sync up the node list with the data map
		var map = {};
		this.getAllNodes().forEach(function(node){
			if(node.id){
				var item = this.getItem(node.id);
				if(item){
					map[node.id] = item;
					return;
				}
			}else{
				node.id = dojo.dnd.getUniqueId();
			}
			var type = node.getAttribute("dndType"),
				data = node.getAttribute("dndData");
			map[node.id] = {
				data: data || node.innerHTML,
				type: type ? type.split(/\s*,\s*/) : ["text"]
			};
		}, this);
		this.map = map;
		return this;	// self
	},
	insertNodes: function(data, before, anchor){
		// summary:
		//		inserts an array of new nodes before/after an anchor node
		// data: Array
		//		a list of data items, which should be processed by the creator function
		// before: Boolean
		//		insert before the anchor, if true, and after the anchor otherwise
		// anchor: Node
		//		the anchor node to be used as a point of insertion
		if(!this.parent.firstChild){
			anchor = null;
		}else if(before){
			if(!anchor){
				anchor = this.parent.firstChild;
			}
		}else{
			if(anchor){
				anchor = anchor.nextSibling;
			}
		}
		if(anchor){
			for(var i = 0; i < data.length; ++i){
				var t = this._normalizedCreator(data[i]);
				this.setItem(t.node.id, {data: t.data, type: t.type});
				this.parent.insertBefore(t.node, anchor);
			}
		}else{
			for(var i = 0; i < data.length; ++i){
				var t = this._normalizedCreator(data[i]);
				this.setItem(t.node.id, {data: t.data, type: t.type});
				this.parent.appendChild(t.node);
			}
		}
		return this;	// self
	},
	destroy: function(){
		// summary:
		//		prepares this object to be garbage-collected
		dojo.forEach(this.events, dojo.disconnect);
		this.clearItems();
		this.node = this.parent = this.current = null;
	},

	// markup methods
	markupFactory: function(params, node){
		params._skipStartup = true;
		return new dojo.dnd.Container(node, params);
	},
	startup: function(){
		// summary:
		//		collects valid child items and populate the map
		
		// set up the real parent node
		if(!this.parent){
			// use the standard algorithm, if not assigned
			this.parent = this.node;
			if(this.parent.tagName.toLowerCase() == "table"){
				var c = this.parent.getElementsByTagName("tbody");
				if(c && c.length){ this.parent = c[0]; }
			}
		}
		this.defaultCreator = dojo.dnd._defaultCreator(this.parent);

		// process specially marked children
		this.sync();
	},

	// mouse events
	onMouseOver: function(e){
		// summary:
		//		event processor for onmouseover
		// e: Event
		//		mouse event
		var n = e.relatedTarget;
		while(n){
			if(n == this.node){ break; }
			try{
				n = n.parentNode;
			}catch(x){
				n = null;
			}
		}
		if(!n){
			this._changeState("Container", "Over");
			this.onOverEvent();
		}
		n = this._getChildByEvent(e);
		if(this.current == n){ return; }
		if(this.current){ this._removeItemClass(this.current, "Over"); }
		if(n){ this._addItemClass(n, "Over"); }
		this.current = n;
	},
	onMouseOut: function(e){
		// summary:
		//		event processor for onmouseout
		// e: Event
		//		mouse event
		for(var n = e.relatedTarget; n;){
			if(n == this.node){ return; }
			try{
				n = n.parentNode;
			}catch(x){
				n = null;
			}
		}
		if(this.current){
			this._removeItemClass(this.current, "Over");
			this.current = null;
		}
		this._changeState("Container", "");
		this.onOutEvent();
	},
	onSelectStart: function(e){
		// summary:
		//		event processor for onselectevent and ondragevent
		// e: Event
		//		mouse event
		if(!this.skipForm || !dojo.dnd.isFormElement(e)){
			dojo.stopEvent(e);
		}
	},
	
	// utilities
	onOverEvent: function(){
		// summary:
		//		this function is called once, when mouse is over our container
	},
	onOutEvent: function(){
		// summary:
		//		this function is called once, when mouse is out of our container
	},
	_changeState: function(type, newState){
		// summary:
		//		changes a named state to new state value
		// type: String
		//		a name of the state to change
		// newState: String
		//		new state
		var prefix = "dojoDnd" + type;
		var state  = type.toLowerCase() + "State";
		//dojo.replaceClass(this.node, prefix + newState, prefix + this[state]);
		dojo.replaceClass(this.node, prefix + newState, prefix + this[state]);
		this[state] = newState;
	},
	_addItemClass: function(node, type){
		// summary:
		//		adds a class with prefix "dojoDndItem"
		// node: Node
		//		a node
		// type: String
		//		a variable suffix for a class name
		dojo.addClass(node, "dojoDndItem" + type);
	},
	_removeItemClass: function(node, type){
		// summary:
		//		removes a class with prefix "dojoDndItem"
		// node: Node
		//		a node
		// type: String
		//		a variable suffix for a class name
		dojo.removeClass(node, "dojoDndItem" + type);
	},
	_getChildByEvent: function(e){
		// summary:
		//		gets a child, which is under the mouse at the moment, or null
		// e: Event
		//		a mouse event
		var node = e.target;
		if(node){
			for(var parent = node.parentNode; parent; node = parent, parent = node.parentNode){
				if(parent == this.parent && dojo.hasClass(node, "dojoDndItem")){ return node; }
			}
		}
		return null;
	},
	_normalizedCreator: function(/*dojo.dnd.Item*/ item, /*String*/ hint){
		// summary:
		//		adds all necessary data to the output of the user-supplied creator function
		var t = (this.creator || this.defaultCreator).call(this, item, hint);
		if(!dojo.isArray(t.type)){ t.type = ["text"]; }
		if(!t.node.id){ t.node.id = dojo.dnd.getUniqueId(); }
		dojo.addClass(t.node, "dojoDndItem");
		return t;
	}
});

dojo.dnd._createNode = function(tag){
	// summary:
	//		returns a function, which creates an element of given tag
	//		(SPAN by default) and sets its innerHTML to given text
	// tag: String
	//		a tag name or empty for SPAN
	if(!tag){ return dojo.dnd._createSpan; }
	return function(text){	// Function
		return dojo.create(tag, {innerHTML: text});	// Node
	};
};

dojo.dnd._createTrTd = function(text){
	// summary:
	//		creates a TR/TD structure with given text as an innerHTML of TD
	// text: String
	//		a text for TD
	var tr = dojo.create("tr");
	dojo.create("td", {innerHTML: text}, tr);
	return tr;	// Node
};

dojo.dnd._createSpan = function(text){
	// summary:
	//		creates a SPAN element with given text as its innerHTML
	// text: String
	//		a text for SPAN
	return dojo.create("span", {innerHTML: text});	// Node
};

// dojo.dnd._defaultCreatorNodes: Object
//		a dictionary that maps container tag names to child tag names
dojo.dnd._defaultCreatorNodes = {ul: "li", ol: "li", div: "div", p: "div"};

dojo.dnd._defaultCreator = function(node){
	// summary:
	//		takes a parent node, and returns an appropriate creator function
	// node: Node
	//		a container node
	var tag = node.tagName.toLowerCase();
	var c = tag == "tbody" || tag == "thead" ? dojo.dnd._createTrTd :
			dojo.dnd._createNode(dojo.dnd._defaultCreatorNodes[tag]);
	return function(item, hint){	// Function
		var isObj = item && dojo.isObject(item), data, type, n;
		if(isObj && item.tagName && item.nodeType && item.getAttribute){
			// process a DOM node
			data = item.getAttribute("dndData") || item.innerHTML;
			type = item.getAttribute("dndType");
			type = type ? type.split(/\s*,\s*/) : ["text"];
			n = item;	// this node is going to be moved rather than copied
		}else{
			// process a DnD item object or a string
			data = (isObj && item.data) ? item.data : item;
			type = (isObj && item.type) ? item.type : ["text"];
			n = (hint == "avatar" ? dojo.dnd._createSpan : c)(String(data));
		}
		if(!n.id){
			n.id = dojo.dnd.getUniqueId();
		}
		return {node: n, data: data, type: type};
	};
};

}

if(!dojo._hasResource["dojo.dnd.Selector"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.Selector"] = true;
dojo.provide("dojo.dnd.Selector");





/*
	Container item states:
		""			- an item is not selected
		"Selected"	- an item is selected
		"Anchor"	- an item is selected, and is an anchor for a "shift" selection
*/

/*=====
dojo.declare("dojo.dnd.__SelectorArgs", [dojo.dnd.__ContainerArgs], {
	//	singular: Boolean
	//		allows selection of only one element, if true
	singular: false,

	//	autoSync: Boolean
	//		autosynchronizes the source with its list of DnD nodes,
	autoSync: false
});
=====*/

dojo.declare("dojo.dnd.Selector", dojo.dnd.Container, {
	// summary:
	//		a Selector object, which knows how to select its children
	
	/*=====
	// selection: Set<String>
	//		The set of id's that are currently selected, such that this.selection[id] == 1
	//		if the node w/that id is selected.  Can iterate over selected node's id's like:
	//	|		for(var id in this.selection)
	selection: {},
	=====*/

	constructor: function(node, params){
		// summary:
		//		constructor of the Selector
		// node: Node||String
		//		node or node's id to build the selector on
		// params: dojo.dnd.__SelectorArgs?
		//		a dictionary of parameters
		if(!params){ params = {}; }
		this.singular = params.singular;
		this.autoSync = params.autoSync;
		// class-specific variables
		this.selection = {};
		this.anchor = null;
		this.simpleSelection = false;
		// set up events
		this.events.push(
			dojo.connect(this.node, "onmousedown", this, "onMouseDown"),
			dojo.connect(this.node, "onmouseup",   this, "onMouseUp"));
	},
	
	// object attributes (for markup)
	singular: false,	// is singular property
	
	// methods
	getSelectedNodes: function(){
		// summary:
		//		returns a list (an array) of selected nodes
		var t = new dojo.NodeList();
		var e = dojo.dnd._empty;
		for(var i in this.selection){
			if(i in e){ continue; }
			t.push(dojo.byId(i));
		}
		return t;	// NodeList
	},
	selectNone: function(){
		// summary:
		//		unselects all items
		return this._removeSelection()._removeAnchor();	// self
	},
	selectAll: function(){
		// summary:
		//		selects all items
		this.forInItems(function(data, id){
			this._addItemClass(dojo.byId(id), "Selected");
			this.selection[id] = 1;
		}, this);
		return this._removeAnchor();	// self
	},
	deleteSelectedNodes: function(){
		// summary:
		//		deletes all selected items
		var e = dojo.dnd._empty;
		for(var i in this.selection){
			if(i in e){ continue; }
			var n = dojo.byId(i);
			this.delItem(i);
			dojo.destroy(n);
		}
		this.anchor = null;
		this.selection = {};
		return this;	// self
	},
	forInSelectedItems: function(/*Function*/ f, /*Object?*/ o){
		// summary:
		//		iterates over selected items;
		//		see `dojo.dnd.Container.forInItems()` for details
		o = o || dojo.global;
		var s = this.selection, e = dojo.dnd._empty;
		for(var i in s){
			if(i in e){ continue; }
			f.call(o, this.getItem(i), i, this);
		}
	},
	sync: function(){
		// summary:
		//		sync up the node list with the data map
		
		dojo.dnd.Selector.superclass.sync.call(this);
		
		// fix the anchor
		if(this.anchor){
			if(!this.getItem(this.anchor.id)){
				this.anchor = null;
			}
		}
		
		// fix the selection
		var t = [], e = dojo.dnd._empty;
		for(var i in this.selection){
			if(i in e){ continue; }
			if(!this.getItem(i)){
				t.push(i);
			}
		}
		dojo.forEach(t, function(i){
			delete this.selection[i];
		}, this);
		
		return this;	// self
	},
	insertNodes: function(addSelected, data, before, anchor){
		// summary:
		//		inserts new data items (see `dojo.dnd.Container.insertNodes()` method for details)
		// addSelected: Boolean
		//		all new nodes will be added to selected items, if true, no selection change otherwise
		// data: Array
		//		a list of data items, which should be processed by the creator function
		// before: Boolean
		//		insert before the anchor, if true, and after the anchor otherwise
		// anchor: Node
		//		the anchor node to be used as a point of insertion
		var oldCreator = this._normalizedCreator;
		this._normalizedCreator = function(item, hint){
			var t = oldCreator.call(this, item, hint);
			if(addSelected){
				if(!this.anchor){
					this.anchor = t.node;
					this._removeItemClass(t.node, "Selected");
					this._addItemClass(this.anchor, "Anchor");
				}else if(this.anchor != t.node){
					this._removeItemClass(t.node, "Anchor");
					this._addItemClass(t.node, "Selected");
				}
				this.selection[t.node.id] = 1;
			}else{
				this._removeItemClass(t.node, "Selected");
				this._removeItemClass(t.node, "Anchor");
			}
			return t;
		};
		dojo.dnd.Selector.superclass.insertNodes.call(this, data, before, anchor);
		this._normalizedCreator = oldCreator;
		return this;	// self
	},
	destroy: function(){
		// summary:
		//		prepares the object to be garbage-collected
		dojo.dnd.Selector.superclass.destroy.call(this);
		this.selection = this.anchor = null;
	},

	// markup methods
	markupFactory: function(params, node){
		params._skipStartup = true;
		return new dojo.dnd.Selector(node, params);
	},

	// mouse events
	onMouseDown: function(e){
		// summary:
		//		event processor for onmousedown
		// e: Event
		//		mouse event
		if(this.autoSync){ this.sync(); }
		if(!this.current){ return; }
		if(!this.singular && !dojo.isCopyKey(e) && !e.shiftKey && (this.current.id in this.selection)){
			this.simpleSelection = true;
			if(e.button === dojo.mouseButtons.LEFT){
				// accept the left button and stop the event
				// for IE we don't stop event when multiple buttons are pressed
				dojo.stopEvent(e);
			}
			return;
		}
		if(!this.singular && e.shiftKey){
			if(!dojo.isCopyKey(e)){
				this._removeSelection();
			}
			var c = this.getAllNodes();
			if(c.length){
				if(!this.anchor){
					this.anchor = c[0];
					this._addItemClass(this.anchor, "Anchor");
				}
				this.selection[this.anchor.id] = 1;
				if(this.anchor != this.current){
					var i = 0;
					for(; i < c.length; ++i){
						var node = c[i];
						if(node == this.anchor || node == this.current){ break; }
					}
					for(++i; i < c.length; ++i){
						var node = c[i];
						if(node == this.anchor || node == this.current){ break; }
						this._addItemClass(node, "Selected");
						this.selection[node.id] = 1;
					}
					this._addItemClass(this.current, "Selected");
					this.selection[this.current.id] = 1;
				}
			}
		}else{
			if(this.singular){
				if(this.anchor == this.current){
					if(dojo.isCopyKey(e)){
						this.selectNone();
					}
				}else{
					this.selectNone();
					this.anchor = this.current;
					this._addItemClass(this.anchor, "Anchor");
					this.selection[this.current.id] = 1;
				}
			}else{
				if(dojo.isCopyKey(e)){
					if(this.anchor == this.current){
						delete this.selection[this.anchor.id];
						this._removeAnchor();
					}else{
						if(this.current.id in this.selection){
							this._removeItemClass(this.current, "Selected");
							delete this.selection[this.current.id];
						}else{
							if(this.anchor){
								this._removeItemClass(this.anchor, "Anchor");
								this._addItemClass(this.anchor, "Selected");
							}
							this.anchor = this.current;
							this._addItemClass(this.current, "Anchor");
							this.selection[this.current.id] = 1;
						}
					}
				}else{
					if(!(this.current.id in this.selection)){
						this.selectNone();
						this.anchor = this.current;
						this._addItemClass(this.current, "Anchor");
						this.selection[this.current.id] = 1;
					}
				}
			}
		}
		dojo.stopEvent(e);
	},
	onMouseUp: function(e){
		// summary:
		//		event processor for onmouseup
		// e: Event
		//		mouse event
		if(!this.simpleSelection){ return; }
		this.simpleSelection = false;
		this.selectNone();
		if(this.current){
			this.anchor = this.current;
			this._addItemClass(this.anchor, "Anchor");
			this.selection[this.current.id] = 1;
		}
	},
	onMouseMove: function(e){
		// summary
		//		event processor for onmousemove
		// e: Event
		//		mouse event
		this.simpleSelection = false;
	},
	
	// utilities
	onOverEvent: function(){
		// summary:
		//		this function is called once, when mouse is over our container
		this.onmousemoveEvent = dojo.connect(this.node, "onmousemove", this, "onMouseMove");
	},
	onOutEvent: function(){
		// summary:
		//		this function is called once, when mouse is out of our container
		dojo.disconnect(this.onmousemoveEvent);
		delete this.onmousemoveEvent;
	},
	_removeSelection: function(){
		// summary:
		//		unselects all items
		var e = dojo.dnd._empty;
		for(var i in this.selection){
			if(i in e){ continue; }
			var node = dojo.byId(i);
			if(node){ this._removeItemClass(node, "Selected"); }
		}
		this.selection = {};
		return this;	// self
	},
	_removeAnchor: function(){
		if(this.anchor){
			this._removeItemClass(this.anchor, "Anchor");
			this.anchor = null;
		}
		return this;	// self
	}
});

}

if(!dojo._hasResource["dojo.window"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.window"] = true;
dojo.provide("dojo.window");


dojo.getObject("window", true, dojo);

dojo.window.getBox = function(){
	// summary:
	//		Returns the dimensions and scroll position of the viewable area of a browser window

	var scrollRoot = (dojo.doc.compatMode == 'BackCompat') ? dojo.body() : dojo.doc.documentElement;

	// get scroll position
	var scroll = dojo._docScroll(); // scrollRoot.scrollTop/Left should work
	return { w: scrollRoot.clientWidth, h: scrollRoot.clientHeight, l: scroll.x, t: scroll.y };
};

dojo.window.get = function(doc){
	// summary:
	// 		Get window object associated with document doc

	// In some IE versions (at least 6.0), document.parentWindow does not return a
	// reference to the real window object (maybe a copy), so we must fix it as well
	// We use IE specific execScript to attach the real window reference to
	// document._parentWindow for later use
	if(dojo.isIE && window !== document.parentWindow){
		/*
		In IE 6, only the variable "window" can be used to connect events (others
		may be only copies).
		*/
		doc.parentWindow.execScript("document._parentWindow = window;", "Javascript");
		//to prevent memory leak, unset it after use
		//another possibility is to add an onUnload handler which seems overkill to me (liucougar)
		var win = doc._parentWindow;
		doc._parentWindow = null;
		return win;	//	Window
	}

	return doc.parentWindow || doc.defaultView;	//	Window
};

dojo.window.scrollIntoView = function(/*DomNode*/ node, /*Object?*/ pos){
	// summary:
	//		Scroll the passed node into view, if it is not already.
	
	// don't rely on node.scrollIntoView working just because the function is there

	try{ // catch unexpected/unrecreatable errors (#7808) since we can recover using a semi-acceptable native method
		node = dojo.byId(node);
		var doc = node.ownerDocument || dojo.doc,
			body = doc.body || dojo.body(),
			html = doc.documentElement || body.parentNode,
			isIE = dojo.isIE, isWK = dojo.isWebKit;
		// if an untested browser, then use the native method
		if((!(dojo.isMoz || isIE || isWK || dojo.isOpera) || node == body || node == html) && (typeof node.scrollIntoView != "undefined")){
			node.scrollIntoView(false); // short-circuit to native if possible
			return;
		}
		var backCompat = doc.compatMode == 'BackCompat',
			clientAreaRoot = (isIE >= 9 && node.ownerDocument.parentWindow.frameElement)
				? ((html.clientHeight > 0 && html.clientWidth > 0 && (body.clientHeight == 0 || body.clientWidth == 0 || body.clientHeight > html.clientHeight || body.clientWidth > html.clientWidth)) ? html : body)
				: (backCompat ? body : html),
			scrollRoot = isWK ? body : clientAreaRoot,
			rootWidth = clientAreaRoot.clientWidth,
			rootHeight = clientAreaRoot.clientHeight,
			rtl = !dojo._isBodyLtr(),
			nodePos = pos || dojo.position(node),
			el = node.parentNode,
			isFixed = function(el){
				return ((isIE <= 6 || (isIE && backCompat))? false : (dojo.style(el, 'position').toLowerCase() == "fixed"));
			};
		if(isFixed(node)){ return; } // nothing to do

		while(el){
			if(el == body){ el = scrollRoot; }
			var elPos = dojo.position(el),
				fixedPos = isFixed(el);
	
			if(el == scrollRoot){
				elPos.w = rootWidth; elPos.h = rootHeight;
				if(scrollRoot == html && isIE && rtl){ elPos.x += scrollRoot.offsetWidth-elPos.w; } // IE workaround where scrollbar causes negative x
				if(elPos.x < 0 || !isIE){ elPos.x = 0; } // IE can have values > 0
				if(elPos.y < 0 || !isIE){ elPos.y = 0; }
			}else{
				var pb = dojo._getPadBorderExtents(el);
				elPos.w -= pb.w; elPos.h -= pb.h; elPos.x += pb.l; elPos.y += pb.t;
				var clientSize = el.clientWidth,
					scrollBarSize = elPos.w - clientSize;
				if(clientSize > 0 && scrollBarSize > 0){
					elPos.w = clientSize;
					elPos.x += (rtl && (isIE || el.clientLeft > pb.l/*Chrome*/)) ? scrollBarSize : 0;
				}
				clientSize = el.clientHeight;
				scrollBarSize = elPos.h - clientSize;
				if(clientSize > 0 && scrollBarSize > 0){
					elPos.h = clientSize;
				}
			}
			if(fixedPos){ // bounded by viewport, not parents
				if(elPos.y < 0){
					elPos.h += elPos.y; elPos.y = 0;
				}
				if(elPos.x < 0){
					elPos.w += elPos.x; elPos.x = 0;
				}
				if(elPos.y + elPos.h > rootHeight){
					elPos.h = rootHeight - elPos.y;
				}
				if(elPos.x + elPos.w > rootWidth){
					elPos.w = rootWidth - elPos.x;
				}
			}
			// calculate overflow in all 4 directions
			var l = nodePos.x - elPos.x, // beyond left: < 0
				t = nodePos.y - Math.max(elPos.y, 0), // beyond top: < 0
				r = l + nodePos.w - elPos.w, // beyond right: > 0
				bot = t + nodePos.h - elPos.h; // beyond bottom: > 0
			if(r * l > 0){
				var s = Math[l < 0? "max" : "min"](l, r);
				if(rtl && ((isIE == 8 && !backCompat) || isIE >= 9)){ s = -s; }
				nodePos.x += el.scrollLeft;
				el.scrollLeft += s;
				nodePos.x -= el.scrollLeft;
			}
			if(bot * t > 0){
				nodePos.y += el.scrollTop;
				el.scrollTop += Math[t < 0? "max" : "min"](t, bot);
				nodePos.y -= el.scrollTop;
			}
			el = (el != scrollRoot) && !fixedPos && el.parentNode;
		}
	}catch(error){
		console.error('scrollIntoView: ' + error);
		node.scrollIntoView(false);
	}
};

}

if(!dojo._hasResource["dojo.dnd.autoscroll"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.autoscroll"] = true;
dojo.provide("dojo.dnd.autoscroll");



dojo.getObject("dnd", true, dojo);

dojo.dnd.getViewport = dojo.window.getBox;

dojo.dnd.V_TRIGGER_AUTOSCROLL = 32;
dojo.dnd.H_TRIGGER_AUTOSCROLL = 32;

dojo.dnd.V_AUTOSCROLL_VALUE = 16;
dojo.dnd.H_AUTOSCROLL_VALUE = 16;

dojo.dnd.autoScroll = function(e){
	// summary:
	//		a handler for onmousemove event, which scrolls the window, if
	//		necesary
	// e: Event
	//		onmousemove event

	// FIXME: needs more docs!
	var v = dojo.window.getBox(), dx = 0, dy = 0;
	if(e.clientX < dojo.dnd.H_TRIGGER_AUTOSCROLL){
		dx = -dojo.dnd.H_AUTOSCROLL_VALUE;
	}else if(e.clientX > v.w - dojo.dnd.H_TRIGGER_AUTOSCROLL){
		dx = dojo.dnd.H_AUTOSCROLL_VALUE;
	}
	if(e.clientY < dojo.dnd.V_TRIGGER_AUTOSCROLL){
		dy = -dojo.dnd.V_AUTOSCROLL_VALUE;
	}else if(e.clientY > v.h - dojo.dnd.V_TRIGGER_AUTOSCROLL){
		dy = dojo.dnd.V_AUTOSCROLL_VALUE;
	}
	window.scrollBy(dx, dy);
};

dojo.dnd._validNodes = {"div": 1, "p": 1, "td": 1};
dojo.dnd._validOverflow = {"auto": 1, "scroll": 1};

dojo.dnd.autoScrollNodes = function(e){
	// summary:
	//		a handler for onmousemove event, which scrolls the first avaialble
	//		Dom element, it falls back to dojo.dnd.autoScroll()
	// e: Event
	//		onmousemove event

	// FIXME: needs more docs!
	for(var n = e.target; n;){
		if(n.nodeType == 1 && (n.tagName.toLowerCase() in dojo.dnd._validNodes)){
			var s = dojo.getComputedStyle(n);
			if(s.overflow.toLowerCase() in dojo.dnd._validOverflow){
				var b = dojo._getContentBox(n, s), t = dojo.position(n, true);
				//console.log(b.l, b.t, t.x, t.y, n.scrollLeft, n.scrollTop);
				var w = Math.min(dojo.dnd.H_TRIGGER_AUTOSCROLL, b.w / 2),
					h = Math.min(dojo.dnd.V_TRIGGER_AUTOSCROLL, b.h / 2),
					rx = e.pageX - t.x, ry = e.pageY - t.y, dx = 0, dy = 0;
				if(dojo.isWebKit || dojo.isOpera){
					// FIXME: this code should not be here, it should be taken into account
					// either by the event fixing code, or the dojo.position()
					// FIXME: this code doesn't work on Opera 9.5 Beta
					rx += dojo.body().scrollLeft;
					ry += dojo.body().scrollTop;
				}
				if(rx > 0 && rx < b.w){
					if(rx < w){
						dx = -w;
					}else if(rx > b.w - w){
						dx = w;
					}
				}
				//console.log("ry =", ry, "b.h =", b.h, "h =", h);
				if(ry > 0 && ry < b.h){
					if(ry < h){
						dy = -h;
					}else if(ry > b.h - h){
						dy = h;
					}
				}
				var oldLeft = n.scrollLeft, oldTop = n.scrollTop;
				n.scrollLeft = n.scrollLeft + dx;
				n.scrollTop  = n.scrollTop  + dy;
				if(oldLeft != n.scrollLeft || oldTop != n.scrollTop){ return; }
			}
		}
		try{
			n = n.parentNode;
		}catch(x){
			n = null;
		}
	}
	dojo.dnd.autoScroll(e);
};

}

if(!dojo._hasResource["dojo.dnd.Avatar"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.Avatar"] = true;
dojo.provide("dojo.dnd.Avatar");




dojo.declare("dojo.dnd.Avatar", null, {
	// summary:
	//		Object that represents transferred DnD items visually
	// manager: Object
	//		a DnD manager object

	constructor: function(manager){
		this.manager = manager;
		this.construct();
	},

	// methods
	construct: function(){
		// summary:
		//		constructor function;
		//		it is separate so it can be (dynamically) overwritten in case of need
		this.isA11y = dojo.hasClass(dojo.body(),"dijit_a11y");
		var a = dojo.create("table", {
				"class": "dojoDndAvatar",
				style: {
					position: "absolute",
					zIndex:   "1999",
					margin:   "0px"
				}
			}),
			source = this.manager.source, node,
			b = dojo.create("tbody", null, a),
			tr = dojo.create("tr", null, b),
			td = dojo.create("td", null, tr),
			icon = this.isA11y ? dojo.create("span", {
						id : "a11yIcon",
						innerHTML : this.manager.copy ? '+' : "<"
					}, td) : null,
			span = dojo.create("span", {
				innerHTML: source.generateText ? this._generateText() : ""
			}, td),
			k = Math.min(5, this.manager.nodes.length), i = 0;
		// we have to set the opacity on IE only after the node is live
		dojo.attr(tr, {
			"class": "dojoDndAvatarHeader",
			style: {opacity: 0.9}
		});
		for(; i < k; ++i){
			if(source.creator){
				// create an avatar representation of the node
				node = source._normalizedCreator(source.getItem(this.manager.nodes[i].id).data, "avatar").node;
			}else{
				// or just clone the node and hope it works
				node = this.manager.nodes[i].cloneNode(true);
				if(node.tagName.toLowerCase() == "tr"){
					// insert extra table nodes
					var table = dojo.create("table"),
						tbody = dojo.create("tbody", null, table);
					tbody.appendChild(node);
					node = table;
				}
			}
			node.id = "";
			tr = dojo.create("tr", null, b);
			td = dojo.create("td", null, tr);
			td.appendChild(node);
			dojo.attr(tr, {
				"class": "dojoDndAvatarItem",
				style: {opacity: (9 - i) / 10}
			});
		}
		this.node = a;
	},
	destroy: function(){
		// summary:
		//		destructor for the avatar; called to remove all references so it can be garbage-collected
		dojo.destroy(this.node);
		this.node = false;
	},
	update: function(){
		// summary:
		//		updates the avatar to reflect the current DnD state
		dojo[(this.manager.canDropFlag ? "add" : "remove") + "Class"](this.node, "dojoDndAvatarCanDrop");
		if (this.isA11y){
			var icon = dojo.byId("a11yIcon");
			var text = '+';   // assume canDrop && copy
			if (this.manager.canDropFlag && !this.manager.copy) {
				text = '< '; // canDrop && move
			}else if (!this.manager.canDropFlag && !this.manager.copy) {
				text = "o"; //!canDrop && move
			}else if(!this.manager.canDropFlag){
				text = 'x';  // !canDrop && copy
			}
			icon.innerHTML=text;
		}
		// replace text
		dojo.query(("tr.dojoDndAvatarHeader td span" +(this.isA11y ? " span" : "")), this.node).forEach(
			function(node){
				node.innerHTML = this._generateText();
			}, this);
	},
	_generateText: function(){
		// summary: generates a proper text to reflect copying or moving of items
		return this.manager.nodes.length.toString();
	}
});

}

if(!dojo._hasResource["dojo.dnd.Manager"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.Manager"] = true;
dojo.provide("dojo.dnd.Manager");






dojo.declare("dojo.dnd.Manager", null, {
	// summary:
	//		the manager of DnD operations (usually a singleton)
	constructor: function(){
		this.avatar  = null;
		this.source = null;
		this.nodes = [];
		this.copy  = true;
		this.target = null;
		this.canDropFlag = false;
		this.events = [];
	},

	// avatar's offset from the mouse
	OFFSET_X: 16,
	OFFSET_Y: 16,
	
	// methods
	overSource: function(source){
		// summary:
		//		called when a source detected a mouse-over condition
		// source: Object
		//		the reporter
		if(this.avatar){
			this.target = (source && source.targetState != "Disabled") ? source : null;
			this.canDropFlag = Boolean(this.target);
			this.avatar.update();
		}
		dojo.publish("/dnd/source/over", [source]);
	},
	outSource: function(source){
		// summary:
		//		called when a source detected a mouse-out condition
		// source: Object
		//		the reporter
		if(this.avatar){
			if(this.target == source){
				this.target = null;
				this.canDropFlag = false;
				this.avatar.update();
				dojo.publish("/dnd/source/over", [null]);
			}
		}else{
			dojo.publish("/dnd/source/over", [null]);
		}
	},
	startDrag: function(source, nodes, copy){
		// summary:
		//		called to initiate the DnD operation
		// source: Object
		//		the source which provides items
		// nodes: Array
		//		the list of transferred items
		// copy: Boolean
		//		copy items, if true, move items otherwise
		this.source = source;
		this.nodes  = nodes;
		this.copy   = Boolean(copy); // normalizing to true boolean
		this.avatar = this.makeAvatar();
		dojo.body().appendChild(this.avatar.node);
		dojo.publish("/dnd/start", [source, nodes, this.copy]);
		this.events = [
			dojo.connect(dojo.doc, "onmousemove", this, "onMouseMove"),
			dojo.connect(dojo.doc, "onmouseup",   this, "onMouseUp"),
			dojo.connect(dojo.doc, "onkeydown",   this, "onKeyDown"),
			dojo.connect(dojo.doc, "onkeyup",     this, "onKeyUp"),
			// cancel text selection and text dragging
			dojo.connect(dojo.doc, "ondragstart",   dojo.stopEvent),
			dojo.connect(dojo.body(), "onselectstart", dojo.stopEvent)
		];
		var c = "dojoDnd" + (copy ? "Copy" : "Move");
		dojo.addClass(dojo.body(), c);
	},
	canDrop: function(flag){
		// summary:
		//		called to notify if the current target can accept items
		var canDropFlag = Boolean(this.target && flag);
		if(this.canDropFlag != canDropFlag){
			this.canDropFlag = canDropFlag;
			this.avatar.update();
		}
	},
	stopDrag: function(){
		// summary:
		//		stop the DnD in progress
		dojo.removeClass(dojo.body(), ["dojoDndCopy", "dojoDndMove"]);
		dojo.forEach(this.events, dojo.disconnect);
		this.events = [];
		this.avatar.destroy();
		this.avatar = null;
		this.source = this.target = null;
		this.nodes = [];
	},
	makeAvatar: function(){
		// summary:
		//		makes the avatar; it is separate to be overwritten dynamically, if needed
		return new dojo.dnd.Avatar(this);
	},
	updateAvatar: function(){
		// summary:
		//		updates the avatar; it is separate to be overwritten dynamically, if needed
		this.avatar.update();
	},
	
	// mouse event processors
	onMouseMove: function(e){
	    /* Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved. Licensed under the Apache License 2.0 - http://www.apache.org/licenses/LICENSE-2.0 
	     * WaveMaker: Added this block to test to see if there is no mouse button down, in which case, the user managed to release the mouse without
	     * it being detected.  Seems to happen a lot.  */
	    if (e.which === 0) {
		this.onMouseUp();
		return;
	    }

		// summary:
		//		event processor for onmousemove
		// e: Event
		//		mouse event
		var a = this.avatar;
		if(a){
			dojo.dnd.autoScrollNodes(e);
			//dojo.dnd.autoScroll(e);
			var s = a.node.style;
			s.left = (e.pageX + this.OFFSET_X) + "px";
			s.top  = (e.pageY + this.OFFSET_Y) + "px";
			var copy = Boolean(this.source.copyState(dojo.isCopyKey(e)));
			if(this.copy != copy){
				this._setCopyStatus(copy);
			}
		}
	},
	onMouseUp: function(e){
		// summary:
		//		event processor for onmouseup
		// e: Event
		//		mouse event
		if(this.avatar){
			if(this.target && this.canDropFlag){
				var copy = Boolean(this.source.copyState(dojo.isCopyKey(e))),
				params = [this.source, this.nodes, copy, this.target, e];
				dojo.publish("/dnd/drop/before", params);
				dojo.publish("/dnd/drop", params);
			}else{
				dojo.publish("/dnd/cancel");
			}
			this.stopDrag();
		}
	},
	
	// keyboard event processors
	onKeyDown: function(e){
		// summary:
		//		event processor for onkeydown:
		//		watching for CTRL for copy/move status, watching for ESCAPE to cancel the drag
		// e: Event
		//		keyboard event
		if(this.avatar){
			switch(e.keyCode){
				case dojo.keys.CTRL:
					var copy = Boolean(this.source.copyState(true));
					if(this.copy != copy){
						this._setCopyStatus(copy);
					}
					break;
				case dojo.keys.ESCAPE:
					dojo.publish("/dnd/cancel");
					this.stopDrag();
					break;
			}
		}
	},
	onKeyUp: function(e){
		// summary:
		//		event processor for onkeyup, watching for CTRL for copy/move status
		// e: Event
		//		keyboard event
		if(this.avatar && e.keyCode == dojo.keys.CTRL){
			var copy = Boolean(this.source.copyState(false));
			if(this.copy != copy){
				this._setCopyStatus(copy);
			}
		}
	},
	
	// utilities
	_setCopyStatus: function(copy){
		// summary:
		//		changes the copy status
		// copy: Boolean
		//		the copy status
		this.copy = copy;
		this.source._markDndStatus(this.copy);
		this.updateAvatar();
		dojo.replaceClass(dojo.body(),
			"dojoDnd" + (this.copy ? "Copy" : "Move"),
			"dojoDnd" + (this.copy ? "Move" : "Copy"));
	}
});

// dojo.dnd._manager:
//		The manager singleton variable. Can be overwritten if needed.
dojo.dnd._manager = null;

dojo.dnd.manager = function(){
	// summary:
	//		Returns the current DnD manager.  Creates one if it is not created yet.
	if(!dojo.dnd._manager){
		dojo.dnd._manager = new dojo.dnd.Manager();
	}
	return dojo.dnd._manager;	// Object
};

}

if(!dojo._hasResource["dojo.dnd.Source"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.Source"] = true;
dojo.provide("dojo.dnd.Source");





/*
	Container property:
		"Horizontal"- if this is the horizontal container
	Source states:
		""			- normal state
		"Moved"		- this source is being moved
		"Copied"	- this source is being copied
	Target states:
		""			- normal state
		"Disabled"	- the target cannot accept an avatar
	Target anchor state:
		""			- item is not selected
		"Before"	- insert point is before the anchor
		"After"		- insert point is after the anchor
*/

/*=====
dojo.dnd.__SourceArgs = function(){
	//	summary:
	//		a dict of parameters for DnD Source configuration. Note that any
	//		property on Source elements may be configured, but this is the
	//		short-list
	//	isSource: Boolean?
	//		can be used as a DnD source. Defaults to true.
	//	accept: Array?
	//		list of accepted types (text strings) for a target; defaults to
	//		["text"]
	//	autoSync: Boolean
	//		if true refreshes the node list on every operation; false by default
	//	copyOnly: Boolean?
	//		copy items, if true, use a state of Ctrl key otherwise,
	//		see selfCopy and selfAccept for more details
	//	delay: Number
	//		the move delay in pixels before detecting a drag; 0 by default
	//	horizontal: Boolean?
	//		a horizontal container, if true, vertical otherwise or when omitted
	//	selfCopy: Boolean?
	//		copy items by default when dropping on itself,
	//		false by default, works only if copyOnly is true
	//	selfAccept: Boolean?
	//		accept its own items when copyOnly is true,
	//		true by default, works only if copyOnly is true
	//	withHandles: Boolean?
	//		allows dragging only by handles, false by default
	//  generateText: Boolean?
	//		generate text node for drag and drop, true by default
	this.isSource = isSource;
	this.accept = accept;
	this.autoSync = autoSync;
	this.copyOnly = copyOnly;
	this.delay = delay;
	this.horizontal = horizontal;
	this.selfCopy = selfCopy;
	this.selfAccept = selfAccept;
	this.withHandles = withHandles;
	this.generateText = true;
}
=====*/

dojo.declare("dojo.dnd.Source", dojo.dnd.Selector, {
	// summary:
	//		a Source object, which can be used as a DnD source, or a DnD target
	
	// object attributes (for markup)
	isSource: true,
	horizontal: false,
	copyOnly: false,
	selfCopy: false,
	selfAccept: true,
	skipForm: false,
	withHandles: false,
	autoSync: false,
	delay: 0, // pixels
	accept: ["text"],
	generateText: true,
	
	constructor: function(/*DOMNode|String*/node, /*dojo.dnd.__SourceArgs?*/params){
		// summary:
		//		a constructor of the Source
		// node:
		//		node or node's id to build the source on
		// params:
		//		any property of this class may be configured via the params
		//		object which is mixed-in to the `dojo.dnd.Source` instance
		dojo.mixin(this, dojo.mixin({}, params));
		var type = this.accept;
		if(type.length){
			this.accept = {};
			for(var i = 0; i < type.length; ++i){
				this.accept[type[i]] = 1;
			}
		}
		// class-specific variables
		this.isDragging = false;
		this.mouseDown = false;
		this.targetAnchor = null;
		this.targetBox = null;
		this.before = true;
		this._lastX = 0;
		this._lastY = 0;
		// states
		this.sourceState  = "";
		if(this.isSource){
			dojo.addClass(this.node, "dojoDndSource");
		}
		this.targetState  = "";
		if(this.accept){
			dojo.addClass(this.node, "dojoDndTarget");
		}
		if(this.horizontal){
			dojo.addClass(this.node, "dojoDndHorizontal");
		}
		// set up events
		this.topics = [
			dojo.subscribe("/dnd/source/over", this, "onDndSourceOver"),
			dojo.subscribe("/dnd/start",  this, "onDndStart"),
			dojo.subscribe("/dnd/drop",   this, "onDndDrop"),
			dojo.subscribe("/dnd/cancel", this, "onDndCancel")
		];
	},
	
	// methods
	checkAcceptance: function(source, nodes){
		// summary:
		//		checks if the target can accept nodes from this source
		// source: Object
		//		the source which provides items
		// nodes: Array
		//		the list of transferred items
		if(this == source){
			return !this.copyOnly || this.selfAccept;
		}
		for(var i = 0; i < nodes.length; ++i){
			var type = source.getItem(nodes[i].id).type;
			// type instanceof Array
			var flag = false;
			for(var j = 0; j < type.length; ++j){
				if(type[j] in this.accept){
					flag = true;
					break;
				}
			}
			if(!flag){
				return false;	// Boolean
			}
		}
		return true;	// Boolean
	},
	copyState: function(keyPressed, self){
		// summary:
		//		Returns true if we need to copy items, false to move.
		//		It is separated to be overwritten dynamically, if needed.
		// keyPressed: Boolean
		//		the "copy" key was pressed
		// self: Boolean?
		//		optional flag that means that we are about to drop on itself
		
		if(keyPressed){ return true; }
		if(arguments.length < 2){
			self = this == dojo.dnd.manager().target;
		}
		if(self){
			if(this.copyOnly){
				return this.selfCopy;
			}
		}else{
			return this.copyOnly;
		}
		return false;	// Boolean
	},
	destroy: function(){
		// summary:
		//		prepares the object to be garbage-collected
		dojo.dnd.Source.superclass.destroy.call(this);
		dojo.forEach(this.topics, dojo.unsubscribe);
		this.targetAnchor = null;
	},

	// markup methods
	markupFactory: function(params, node){
		params._skipStartup = true;
		return new dojo.dnd.Source(node, params);
	},

	// mouse event processors
	onMouseMove: function(e){
		// summary:
		//		event processor for onmousemove
		// e: Event
		//		mouse event
		if(this.isDragging && this.targetState == "Disabled"){ return; }
		dojo.dnd.Source.superclass.onMouseMove.call(this, e);
		var m = dojo.dnd.manager();
		if(!this.isDragging){
			if(this.mouseDown && this.isSource &&
					(Math.abs(e.pageX - this._lastX) > this.delay || Math.abs(e.pageY - this._lastY) > this.delay)){
				var nodes = this.getSelectedNodes();
				if(nodes.length){
					m.startDrag(this, nodes, this.copyState(dojo.isCopyKey(e), true));
				}
			}
		}
		if(this.isDragging){
			// calculate before/after
			var before = false;
			if(this.current){
				if(!this.targetBox || this.targetAnchor != this.current){
					this.targetBox = dojo.position(this.current, true);
				}
				if(this.horizontal){
					before = (e.pageX - this.targetBox.x) < (this.targetBox.w / 2);
				}else{
					before = (e.pageY - this.targetBox.y) < (this.targetBox.h / 2);
				}
			}
			if(this.current != this.targetAnchor || before != this.before){
				this._markTargetAnchor(before);
				m.canDrop(!this.current || m.source != this || !(this.current.id in this.selection));
			}
		}
	},
	onMouseDown: function(e){
		// summary:
		//		event processor for onmousedown
		// e: Event
		//		mouse event
		if(!this.mouseDown && this._legalMouseDown(e) && (!this.skipForm || !dojo.dnd.isFormElement(e))){
			this.mouseDown = true;
			this._lastX = e.pageX;
			this._lastY = e.pageY;
			dojo.dnd.Source.superclass.onMouseDown.call(this, e);
		}
	},
	onMouseUp: function(e){
		// summary:
		//		event processor for onmouseup
		// e: Event
		//		mouse event
		if(this.mouseDown){
			this.mouseDown = false;
			dojo.dnd.Source.superclass.onMouseUp.call(this, e);
		}
	},
	
	// topic event processors
	onDndSourceOver: function(source){
		// summary:
		//		topic event processor for /dnd/source/over, called when detected a current source
		// source: Object
		//		the source which has the mouse over it
		if(this != source){
			this.mouseDown = false;
			if(this.targetAnchor){
				this._unmarkTargetAnchor();
			}
		}else if(this.isDragging){
			var m = dojo.dnd.manager();
			m.canDrop(this.targetState != "Disabled" && (!this.current || m.source != this || !(this.current.id in this.selection)));
		}
	},
	onDndStart: function(source, nodes, copy){
		// summary:
		//		topic event processor for /dnd/start, called to initiate the DnD operation
		// source: Object
		//		the source which provides items
		// nodes: Array
		//		the list of transferred items
		// copy: Boolean
		//		copy items, if true, move items otherwise
		if(this.autoSync){ this.sync(); }
		if(this.isSource){
			this._changeState("Source", this == source ? (copy ? "Copied" : "Moved") : "");
		}
		var accepted = this.accept && this.checkAcceptance(source, nodes);
		this._changeState("Target", accepted ? "" : "Disabled");
		if(this == source){
			dojo.dnd.manager().overSource(this);
		}
		this.isDragging = true;
	},
	onDndDrop: function(source, nodes, copy, target){
		// summary:
		//		topic event processor for /dnd/drop, called to finish the DnD operation
		// source: Object
		//		the source which provides items
		// nodes: Array
		//		the list of transferred items
		// copy: Boolean
		//		copy items, if true, move items otherwise
		// target: Object
		//		the target which accepts items
		if(this == target){
			// this one is for us => move nodes!
			this.onDrop(source, nodes, copy);
		}
		this.onDndCancel();
	},
	onDndCancel: function(){
		// summary:
		//		topic event processor for /dnd/cancel, called to cancel the DnD operation
		if(this.targetAnchor){
			this._unmarkTargetAnchor();
			this.targetAnchor = null;
		}
		this.before = true;
		this.isDragging = false;
		this.mouseDown = false;
		this._changeState("Source", "");
		this._changeState("Target", "");
	},
	
	// local events
	onDrop: function(source, nodes, copy){
		// summary:
		//		called only on the current target, when drop is performed
		// source: Object
		//		the source which provides items
		// nodes: Array
		//		the list of transferred items
		// copy: Boolean
		//		copy items, if true, move items otherwise
		
		if(this != source){
			this.onDropExternal(source, nodes, copy);
		}else{
			this.onDropInternal(nodes, copy);
		}
	},
	onDropExternal: function(source, nodes, copy){
		// summary:
		//		called only on the current target, when drop is performed
		//		from an external source
		// source: Object
		//		the source which provides items
		// nodes: Array
		//		the list of transferred items
		// copy: Boolean
		//		copy items, if true, move items otherwise
		
		var oldCreator = this._normalizedCreator;
		// transferring nodes from the source to the target
		if(this.creator){
			// use defined creator
			this._normalizedCreator = function(node, hint){
				return oldCreator.call(this, source.getItem(node.id).data, hint);
			};
		}else{
			// we have no creator defined => move/clone nodes
			if(copy){
				// clone nodes
				this._normalizedCreator = function(node, hint){
					var t = source.getItem(node.id);
					var n = node.cloneNode(true);
					n.id = dojo.dnd.getUniqueId();
					return {node: n, data: t.data, type: t.type};
				};
			}else{
				// move nodes
				this._normalizedCreator = function(node, hint){
					var t = source.getItem(node.id);
					source.delItem(node.id);
					return {node: node, data: t.data, type: t.type};
				};
			}
		}
		this.selectNone();
		if(!copy && !this.creator){
			source.selectNone();
		}
		this.insertNodes(true, nodes, this.before, this.current);
		if(!copy && this.creator){
			source.deleteSelectedNodes();
		}
		this._normalizedCreator = oldCreator;
	},
	onDropInternal: function(nodes, copy){
		// summary:
		//		called only on the current target, when drop is performed
		//		from the same target/source
		// nodes: Array
		//		the list of transferred items
		// copy: Boolean
		//		copy items, if true, move items otherwise
		
		var oldCreator = this._normalizedCreator;
		// transferring nodes within the single source
		if(this.current && this.current.id in this.selection){
			// do nothing
			return;
		}
		if(copy){
			if(this.creator){
				// create new copies of data items
				this._normalizedCreator = function(node, hint){
					return oldCreator.call(this, this.getItem(node.id).data, hint);
				};
			}else{
				// clone nodes
				this._normalizedCreator = function(node, hint){
					var t = this.getItem(node.id);
					var n = node.cloneNode(true);
					n.id = dojo.dnd.getUniqueId();
					return {node: n, data: t.data, type: t.type};
				};
			}
		}else{
			// move nodes
			if(!this.current){
				// do nothing
				return;
			}
			this._normalizedCreator = function(node, hint){
				var t = this.getItem(node.id);
				return {node: node, data: t.data, type: t.type};
			};
		}
		this._removeSelection();
		this.insertNodes(true, nodes, this.before, this.current);
		this._normalizedCreator = oldCreator;
	},
	onDraggingOver: function(){
		// summary:
		//		called during the active DnD operation, when items
		//		are dragged over this target, and it is not disabled
	},
	onDraggingOut: function(){
		// summary:
		//		called during the active DnD operation, when items
		//		are dragged away from this target, and it is not disabled
	},
	
	// utilities
	onOverEvent: function(){
		// summary:
		//		this function is called once, when mouse is over our container
		dojo.dnd.Source.superclass.onOverEvent.call(this);
		dojo.dnd.manager().overSource(this);
		if(this.isDragging && this.targetState != "Disabled"){
			this.onDraggingOver();
		}
	},
	onOutEvent: function(){
		// summary:
		//		this function is called once, when mouse is out of our container
		dojo.dnd.Source.superclass.onOutEvent.call(this);
		dojo.dnd.manager().outSource(this);
		if(this.isDragging && this.targetState != "Disabled"){
			this.onDraggingOut();
		}
	},
	_markTargetAnchor: function(before){
		// summary:
		//		assigns a class to the current target anchor based on "before" status
		// before: Boolean
		//		insert before, if true, after otherwise
		if(this.current == this.targetAnchor && this.before == before){ return; }
		if(this.targetAnchor){
			this._removeItemClass(this.targetAnchor, this.before ? "Before" : "After");
		}
		this.targetAnchor = this.current;
		this.targetBox = null;
		this.before = before;
		if(this.targetAnchor){
			this._addItemClass(this.targetAnchor, this.before ? "Before" : "After");
		}
	},
	_unmarkTargetAnchor: function(){
		// summary:
		//		removes a class of the current target anchor based on "before" status
		if(!this.targetAnchor){ return; }
		this._removeItemClass(this.targetAnchor, this.before ? "Before" : "After");
		this.targetAnchor = null;
		this.targetBox = null;
		this.before = true;
	},
	_markDndStatus: function(copy){
		// summary:
		//		changes source's state based on "copy" status
		this._changeState("Source", copy ? "Copied" : "Moved");
	},
	_legalMouseDown: function(e){
		// summary:
		//		checks if user clicked on "approved" items
		// e: Event
		//		mouse event
		
		// accept only the left mouse button
		if(!dojo.mouseButtons.isLeft(e)){ return false; }
		
		if(!this.withHandles){ return true; }
		
		// check for handles
		for(var node = e.target; node && node !== this.node; node = node.parentNode){
			if(dojo.hasClass(node, "dojoDndHandle")){ return true; }
			if(dojo.hasClass(node, "dojoDndItem") || dojo.hasClass(node, "dojoDndIgnore")){ break; }
		}
		return false;	// Boolean
	}
});

dojo.declare("dojo.dnd.Target", dojo.dnd.Source, {
	// summary: a Target object, which can be used as a DnD target
	
	constructor: function(node, params){
		// summary:
		//		a constructor of the Target --- see the `dojo.dnd.Source.constructor` for details
		this.isSource = false;
		dojo.removeClass(this.node, "dojoDndSource");
	},

	// markup methods
	markupFactory: function(params, node){
		params._skipStartup = true;
		return new dojo.dnd.Target(node, params);
	}
});

dojo.declare("dojo.dnd.AutoSource", dojo.dnd.Source, {
	// summary:
	//		a source that syncs its DnD nodes by default
	
	constructor: function(node, params){
		// summary:
		//		constructor of the AutoSource --- see the Source constructor for details
		this.autoSync = true;
	},

	// markup methods
	markupFactory: function(params, node){
		params._skipStartup = true;
		return new dojo.dnd.AutoSource(node, params);
	}
});

}

if(!dojo._hasResource["wm.base.widget.Layers.TabsDecorator"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.widget.Layers.TabsDecorator"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide("wm.base.widget.Layers.TabsDecorator");


dojo.declare("wm.TabsDecorator", [wm.LayersDecorator, wm.TouchMixinOptional], {
	decorationClass: "wmtablayers",
        decoratorPadding: "7, 0, 0, 0",
        verticalDecoratorPadding: "0,0,0,7",
	undecorate: function() {
		this.inherited(arguments);
		this.tabsControl.destroy();
	},
	decorateContainer: function() {
		this.inherited(arguments);
		this.btns = [];
	    if (this.tabsControl)
		this.tabsControl.destroy();
		this.tabsControl = new wm.TabsControl({
			parent: this.decoree,
		        owner: this.decoree,
		    padding: this.decoree.verticalButtons ? this.verticalDecoratorPadding : this.decoratorPadding,
		    name: "tabsControl"
		});
		this.decoree.moveControl(this.tabsControl, 0);
		if (this.decoree.verticalButtons) {
		  this.decoree.setLayoutKind("left-to-right");
		}
	    if (this.decoree.dndTargetName || this.decoree._designer) {
		
    		this.dndObj = new dojo.dnd.Source(this.tabsControl.domNode, {accept: [this.decoree.dndTargetName || "designMoveLayers"]});
		this.dndObjConnect = this.tabsControl.connect(this.dndObj, "onDndDrop", this, "onTabDrop");
	    }

	},
    createTab: function(inCaption, inIndex, inLayer) {
        var b = this.btns[inIndex] = document.createElement("button");
        dojo.attr(b, "id", this.decoree.domNode.id + "_decorator_button" + this.btns.length);
        dojo.attr(b, "type", "button");
        dojo.attr(b, "type", "button");
        /*
        if (!this.decoree.verticalButtons && inLayer.borderExtents.t > 1) {
        b.style.top = (inLayer.borderExtents.t - 1) + "px";
        }
        */
        //b.style.outline = "none";
        b.style.display = inLayer.showing ? "" : "none";
        this.setBtnText(b, inCaption, inLayer.closable || inLayer.destroyable);
        if (!wm.isMobile) {
            this.decoree.connect(b, "onclick", dojo.hitch(this, "onTabClick", inLayer));
        } else {
            this.addTouchListener(b);
        }

        /*
        } else if (wm.isFakeMobile) {
        this.decoree.connect(b,'onmousedown', dojo.hitch(this, "touchTabStart", inLayer));
        this.decoree.connect(b,'onmousemove', dojo.hitch(this, "touchTabMove",  inLayer));
        this.decoree.connect(b,'onmouseup',   dojo.hitch(this, "touchTabEnd",   inLayer));
        } else {
        this.decoree.connect(b,'ontouchstart',dojo.hitch(this, "touchTabStart", inLayer));
        this.decoree.connect(b,'ontouchmove', dojo.hitch(this, "touchTabMove",  inLayer));
        this.decoree.connect(b,'ontouchend',  dojo.hitch(this, "touchTabEnd",   inLayer));
        }
        */
        var tabstyleName = (this.decoree.verticalButtons) ? "-verticaltab" : "-tab";
        b.className = this.decorationClass + tabstyleName + (inLayer.closable || inLayer.destroyable ? " " + this.decorationClass + "-closabletab" : "");
        if (!inCaption) b.style.display = "none";
        this.tabsControl.domNode.appendChild(b);

        if (this.dndObj) {
            this.dndObj.destroy()
            dojo.disconnect(this.dndObjConnect);
            dojo.addClass(b, "dojoDndItem");
            dojo.attr(b, "dndType", this.decoree.dndTargetName || "designMoveLayers");
            this.dndObj = new dojo.dnd.Source(this.tabsControl.domNode, {
                accept: [this.decoree.dndTargetName || "designMoveLayers"]
            });
            this.dndObjConnect = this.tabsControl.connect(this.dndObj, "onDndDrop", this, "onTabDrop");
        }
    },



    onTabClick: function(inLayer, evt) {
        // prevent designer click
        if (this.decoree.isDesignLoaded()) dojo.stopEvent(evt);

        /* IE 8 does not gaurentee that evt will still have its properties after a delay, so
         * we capture the event properties we need and pass that rather than the event object itself.
         * Other browsers don't require this, but it seems like a good practice regardless.
         */
        if (evt.type == "submit") return;
        var pseudoEvent = {
            target: evt.target,
            clientX: evt.clientX,
            clientY: evt.clientY
        };

        wm.onidle(this, function() {
            this.tabClicked(inLayer, pseudoEvent);
            pseudoEvent.target.style.borderWidth = "";
        });
    },
    onTouchStart: function(event) {
        var target = event.target;
        while (target.tagName != "BUTTON" && target.tagName != "BODY") {
            target = target.parentNode;
        }
        var index = dojo.indexOf(this.btns, target);

        if (index >= 0) {
            this._touchedLayer = this.decoree.layers[index];
        }

    },
    onTouchMove: function(event, yPosition, yChangeFromInitial, yChangeFromLast, xPosition, xChangeFromInitial, xChangeFromLast) {},
    onTouchEnd: function(event, isMove) {
        if (!isMove) {
            this.tabClicked(this._touchedLayer, event);
        }
        delete this._touchedLayer;
    },
    getRuntimeId: function() {
        return this.decoree.getRuntimeId() + ".decorator";
    },
/*
    touchTabStart: function(inLayer,evt) {
	if (!inLayer._touchStarted) {
	    inLayer._touchStarted = true;
	    inLayer._touchTarget = evt.target;
	    this.btns[inLayer.getIndex()].style.borderWidth = "3px";
	    wm.job(inLayer.getRuntimeId() + ".onClick", app.touchToClickDelay, dojo.hitch(this, "touchTabEnd", inLayer));
	}
    },
    touchTabMove: function(inLayer,evt) {
	if (inLayer._touchStarted) {
	    wm.cancelJob(inLayer.getRuntimeId() + ".onClick");
	    delete inLayer._touchStarted;
	    delete inLayer._touchTarget;
	    this.btns[inLayer.getIndex()].style.borderWidth = "";
	}
    },
    touchTabEnd: function(inLayer,evt) {
	if (inLayer._touchStarted) {
	    delete inLayer._touchStarted;
	    this.btns[inLayer.getIndex()].style.borderWidth = "";
	    this.tabClicked(inLayer, {target: inLayer._touchTarget});
	    delete inLayer._touchTarget;
	}
    },
    */

	 onTabDrop: function(dndSource,nodes,copy,dndTarget,event) {
	     if (dojo.dnd.manager().target != this.dndObj) return;
	     var tabLayers = wm.getWidgetByDomNode(nodes[0]);

	     var indexWas = dojo.indexOf(tabLayers.decorator.btns, nodes[0]);
	     if (indexWas == -1) return;
	     var layer = tabLayers.layers[indexWas];
	     if (!layer) return;

	     var indexIs = dojo.indexOf(this.tabsControl.domNode.childNodes, nodes[0]);
	     var findNewIndex = false;
	     var changeParent = layer.parent != this.decoree;
	     if (changeParent) {
		 layer.setParent(this.decoree);
		 var selectedIndex = tabLayers.layerIndex;
		 tabLayers.layerIndex = -1;
		 tabLayers.setLayerIndex(tabLayers.layers.length > selectedIndex ? selectedIndex : tabLayers.layers.length-1);

		 var managedButtons = this.btns;
		 var currentButtons = this.tabsControl.domNode.childNodes;
		 if (indexIs == this.btns.length-1) {
		     findNewIndex = true;
		 }
		 // Find any buttons currently in the tabControl that aren't in this.btns; this is a new tab dragged in from elsewhere
		 // and needs to be handled
/*
		 for (var i = 0; i < currentButtons.length; i++) {
		     var b = currentButtons[i];
		     if (dojo.indexOf(managedButtons,b) == -1) {
			 draggedFromElsewhere = true;
			 this.decoree.moveLayerIndex(layer, i);
			 dojo.destroy(b);
			 break;
		     }
		 }
		 */
		 if (nodes[0].parentNode)
		     dojo.destroy(nodes[0]);
	     } else if (indexWas == indexIs) {
		 findNewIndex = true;
	     }

	     /* we generally need to find a new index when the user drops a tab between two tabs because dojo fails
	      * to handle this case
	      */
	     if (findNewIndex) {
		 // use the event to see if the index SHOULD have been changed but dojo just messed up.
		 var x = event.offsetX;
		 var found = false;
		 for (var i = 0; i < this.btns.length; i++) {
		     var b = this.btns[i];
		     var coords = dojo.marginBox(b);
		     coords.l += dojo._getContentBox(b).l;
		     if (coords.l > x) {
			 indexIs = i;
			 found = true;
			 break;
		     }
		 }
		 if (!found) {
		     indexIs = this.btns.length;
		 } else if (indexIs > indexWas && !changeParent) {
		     indexIs--;
		 }
	     }
	     this.decoree.moveLayerIndex(layer, indexIs);
	     if (this.decoree.isDesignLoaded()) {
		 studio.refreshWidgetsTree();
	     }
             layer.activate();
	     layer.onTabDrop();
	     if (tabLayers != this.decoree && tabLayers.onTabRemoved) {
		 tabLayers.onTabRemoved();
	     }
	     this.decoree.onTabDrop();
	 },
	tabClicked: function(inLayer, e) {
		var d = this.decoree;

	    var close = dojo.hasClass(e.target, "TabCloseIcon");
	    if (!close && (inLayer.closable || inLayer.destroyable)) {
		var closeIcon = dojo.coords(e.target.firstChild);
		var button = dojo.coords(e.target);
		if (e.clientX >= closeIcon.x &&
		    e.clientY <= closeIcon.y+closeIcon.h)
		    close = true;
	    }
	    if (close) {
		if (inLayer.customCloseOrDestroy != inLayer.constructor.prototype.customCloseOrDestroy)
		    return inLayer.customCloseOrDestroy(inLayer);
		inLayer.onCloseOrDestroy();

		if (inLayer.parent.customCloseOrDestroy != inLayer.parent.constructor.prototype.customCloseOrDestroy)
		    return inLayer.parent.customCloseOrDestroy(inLayer.parent, inLayer);
		var currentLayer = inLayer.parent.getActiveLayer();
		var currentIndex = currentLayer.getIndex();
		var parent = inLayer.parent;
		parent.onCloseOrDestroy(inLayer);
		if (inLayer.destroyable)
		    inLayer.destroy();
		else
		    inLayer.hide();
		this.decoree.renderBounds(); // in case number of rows of tabs has changed
		if (!currentLayer.isDestroyed) {
		    currentLayer.activate();
		    currentLayer.parent.layerIndex = dojo.indexOf(currentLayer.parent.layers, currentLayer);
		} else if (currentIndex > 0) parent.setLayerIndex(currentIndex-1);
		else parent.setLayerIndex(0);

	    } else {
		d.setLayer(inLayer);
	    }
	},
	decorateLayer: function(inLayer, inIndex) {
		this.inherited(arguments);
		this.createTab(inLayer.caption, inIndex, inLayer);
	},
	undecorateLayer: function(inLayer, inIndex) {
		dojo._destroyElement(this.btns[inIndex]);
		this.btns.splice(inIndex, 1);
	},
	setLayerShowing: function(inLayer, inShowing) {
		var i = inLayer.getIndex();
		if (i != -1)
			this.btns[i].style.display = inShowing ? "" : "none";
		this.inherited(arguments);
	},
	setLayerActive: function(inLayer, inActive) {
		var b=this.btns[inLayer.getIndex()];
		if (b)
		    dojo[inActive ? "addClass" : "removeClass"](b, this.decorationClass + '-selected');
		this.inherited(arguments);
	},
	applyLayerCaption: function(inLayer) {
		var d = this.decoree, i = inLayer.getIndex();
		if (i != -1)
		    this.setBtnText(this.btns[i], inLayer.caption, inLayer.closable || inLayer.destroyable);
	},
    setBtnText: function(inBtn, inCaption, closable) {
	var index = dojo.indexOf(this.btns, inBtn);
	var layer = this.decoree.layers[index];
	if (inCaption) {
	    if (inBtn.style.display && layer.showing)
		inBtn.style.display = "";
	    dojo[closable ? "addClass" : "removeClass"](inBtn, this.decorationClass + "-closabletab");
	    inBtn.innerHTML = (closable ? "<span class='TabCloseIcon'>x</span>" : "") +  (inCaption || '&nbsp;');
	} else {
	    inBtn.style.display = "none";
	}

	},
	getBtn: function(inCaption) {
		var d = this.decoree, i = d.indexOfLayerCaption(inCaption);
		if (i != -1)
			return this.btns[i];
	},
	disenableTab: function(inCaption, inDisable) {
		var b = this.getBtn(inCaption);
		if (b)
			b.disabled = inDisable ? "disabled" : "";
	},
	disableTab: function(inCaption) {
		this.disenableTab(inCaption, true);
	},
	enableTab: function(inCaption) {
		this.disenableTab(inCaption, false);
	},
	moveLayerIndex: function(inFromIndex, inToIndex) {
		this.inherited(arguments);
		var d = this.tabsControl.domNode, f = this.btns[inFromIndex], t = this.btns[inToIndex], c = this.decoree.getCount()-1;
		if (inToIndex < inFromIndex) {
			d.insertBefore(f, t);
		} else if (inToIndex > inFromIndex) {
			if (inToIndex == c)
				d.appendChild(f);
			else {
				var nl = this.btns[inToIndex + 1];
				if (nl)
					d.insertBefore(f, nl);
			}
		}
	    wm.Array.removeElement(this.btns, f);
	    wm.Array.insertElementAt(this.btns, f, inToIndex);
	}
});
dojo.declare("wm.RoundedTabsDecorator", wm.TabsDecorator, {}); // backwards compatability
/*
dojo.declare("wm.RoundedTabsDecorator", wm.TabsDecorator, {
	decorateContainer: function() {
		this.inherited(arguments);
		dojo.removeClass(this.tabsControl.domNode, "wmtablayers-tabbar");
		dojo.addClass(this.tabsControl.domNode, "wmtablayers-roundedtabbar");
		this.tabsControl.setPadding("0,0,0,15");
		this.tabsControl.domNode.style.paddingTop = "0px";
		this.tabsControl.domNode.style.paddingLeft = "15px";
	},
	createTab: function(inCaption, inIndex, inLayer) {
		var b = this.btns[inIndex] = document.createElement("div");
		b.style.display = inLayer.showing ? "" : "none";

		var divLeft = document.createElement("div");
		var divCenter = document.createElement("div");
		var divRight = document.createElement("div");

		divLeft.innerHTML = "&nbsp;";
		divCenter.innerHTML = "&nbsp;";
		divRight.innerHTML = "&nbsp;";

		this.setBtnText(divCenter, inCaption, inLayer.closable || inLayer.destroyable);
		this.decoree.connect(b, "onclick", dojo.hitch(this, "tabClicked", inLayer));
		this.decoree.connect(b, "onmouseover", dojo.hitch(this, "mouseoverout", inLayer, true));
		this.decoree.connect(b, "onmouseout", dojo.hitch(this, "mouseoverout", inLayer, false));

		b.className="wmtablayers-roundedtab";
		divLeft.className="wmtablayers-roundedtab-left";
		divCenter.className="wmtablayers-roundedtab-center";
		divRight.className="wmtablayers-roundedtab-right";

		b.appendChild(divLeft);
		b.appendChild(divCenter);
		b.appendChild(divRight);

		dojo.connect(b, "onselectstart", dojo, "stopEvent");
		this.tabsControl.domNode.appendChild(b);
	},
	tabClicked: function(inLayer){
		var b=this.btns[inLayer.getIndex()];
		var divLeft = b.childNodes[0];
		var divCenter = b.childNodes[1];
		var divRight = b.childNodes[2];
		if (b){
			dojo.removeClass(divLeft, 'wmtablayers-roundedtab-left-hover');
			dojo.removeClass(divCenter, 'wmtablayers-roundedtab-center-hover');
			dojo.removeClass(divRight, 'wmtablayers-roundedtab-right-hover');
		}
		this.inherited(arguments);
	},
	mouseoverout: function(inLayer, inActive){
		var inIndex = inLayer.getIndex();
		if(this.decoree.layerIndex != inIndex){ // user has put mouse over an inactive tab
			var b=this.btns[inIndex];
			var divLeft = b.childNodes[0];
			var divCenter = b.childNodes[1];
			var divRight = b.childNodes[2];
			if (b){
				dojo[inActive ? "addClass" : "removeClass"](divLeft, 'wmtablayers-roundedtab-left-hover');
				dojo[inActive ? "addClass" : "removeClass"](divCenter, 'wmtablayers-roundedtab-center-hover');
				dojo[inActive ? "addClass" : "removeClass"](divRight, 'wmtablayers-roundedtab-right-hover');
			}
		}
	},
	applyLayerCaption: function(inLayer) {
		var d = this.decoree, i = inLayer.getIndex();
		if (i != -1)
			this.setBtnText(this.btns[i].childNodes[1], inLayer.caption, inLayer.closable || inLayer.destroyable);
	}

});
*/


dojo.declare("wm.TabsControl", wm.Control, {
	height: "27px",
	width: "100%",
	border: 0,
	init: function() {
	    if (this.parent && this.parent.isRelativePositioned)
		this.isRelativePositioned = true;
	    dojo.addClass(this.domNode, "wmtablayers-tabbar");
	    if (this.owner) {
		if (this.owner.verticalButtons) {
		    this.height = "100%";
		    this.width = this.owner.headerWidth;
		} else {
		    this.height = this.owner._headerHeight;
		}
	    }
	    this.inherited(arguments);
	},
	updateHeaderHeight: function(){
		// dont do anything during design mode as designer decides what height should header have.
/* no longer relevant as this test now needs to be handled by the caller
		if (this.isDesignLoaded())
		  return false;
*/
	        //var _currHeight = dojo.marginBox(this.domNode).h;  these two lines are invoked by the caller before doing a short delay so that IE 6 can update its dom structure
		//this.domNode.style.height = 'auto';
	    if (this.owner._lockHeaderHeight) return this.bounds.h;
		var domHeight = dojo.marginBox(this.domNode).h;
	    return domHeight;
		if (domHeight != _currHeight){
			dojo.marginBox(this.domNode, {h:_currHeight});
			return domHeight;
		}
		return false;
	}
});

}

if(!dojo._hasResource["wm.base.widget.Layers"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.widget.Layers"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide("wm.base.widget.Layers");



//dojo.require("wm.base.widget.Layers.AccordionDecorator");

dojo.declare("wm.Layer", wm.Container, {
    height: "100%",
    width: "100%",
    caption: "",
    layoutKind: "top-to-bottom",
        closable: false,
        destroyable: false,
        showDirtyFlag: false,
    //_requiredParent: "wm.Layers",
    destroy: function() {
        //console.info('layer destroy called');
        this._isLayerDestroying = true;
        var parent = this.parent;
        if (parent && parent instanceof wm.Layers && !parent.isDestroyed) {
            parent.setCaptionMapLayer(this.caption, null);
        }
        this.inherited(arguments);
        if (parent && parent.conditionalTabButtons && !parent.decorator.tabsControl.isDestroyed)
        parent.decorator.tabsControl.setShowing(parent.getVisibleLayerCount() > 1);
    },
    init: function() {

        this.inherited(arguments);
        // bc
        if (this.title) {
            this.caption = this.title;
            delete this.title;
        }
        this.setCaption(this.caption);

        if (!this.isRelativePositioned)
            dojo.addClass(this.domNode, "wmlayer");
    },


    setParent: function(inParent) {
        this.inherited(arguments);
        if(this.parent) {
            /* Apply the wm.Layers clientBorder if the layer hasn't customized its own border */
            if (this.border === wm.Layer.prototype.border) {
                this.setBorder(this.parent.clientBorder);
            }
            if (this.borderColor === wm.Layer.prototype.borderColor) {
                this.setBorderColor(this.parent.clientBorderColor);
            }
        }
    },

    // FIXME: override so that we do not remove and re-add layer
    // this is nasty but avoids dealing with layer order changing
    setName: function(inName) {
        if (this.parent)
            delete this.parent.widgets[this.name];
        this.addRemoveDefaultCssClass(false);
        wm.Component.prototype.setName.apply(this, arguments);
        if (this.parent)
            this.parent.widgets[this.name] = this;
        this.addRemoveDefaultCssClass(true);
    },
    activate: function() {
        var p = this.parent;
        if ((this.showing || wm.BreadcrumbLayers && this.parent instanceof wm.BreadcrumbLayers) && !this.isActive()) {
        if (!this.showing) this.show();
        p.setLayer(this);
        }
    },
    activateAllParents: function() {
        var p = this.parent;
        p.setLayer(this);
        var ancestor = this.parent.isAncestorInstanceOf(wm.Layer);
        if (ancestor) {
        ancestor.activateAllParents();
        } else {
        ancestor = this.parent.isAncestorInstanceOf(wm.Dialog);
        if (ancestor) {
            ancestor.show();
        }
        }
    },
    /* Called when the layer is the event handler */
        update: function() {
        this.activate();
    },
    isActive: function() {
        return this.active;
    },
    setShowing: function(inShowing) {
        if (!this.canChangeShowing())
            return;
            var p = this.parent;
        if (this.showing != inShowing) {
            this.showing = inShowing;
            this.decorator.setLayerShowing(this, inShowing);
            if (!inShowing && p.layerIndex == this.getIndex()) {
            p.setNext();
            }
        }
        if (p && p.conditionalTabButtons && !p.decorator.tabsControl.isDestroyed)
        p.decorator.tabsControl.setShowing(p.getVisibleLayerCount() > 1);
    },
        show: function() {
        this.setShowing(true);
    },
        hide: function() {
        this.setShowing(false);
    },
    setCaption: function(inCaption) {
        this.caption = inCaption;
        if (this.parent) {
        this.parent.setCaptionMapLayer(inCaption, this);
        }
        if (this.decorator)
        this.decorator.applyLayerCaption(this);
    },
        setIsDirty: function(inDirty) {
        if (this.isDirty != inDirty) {
        this.isDirty = inDirty;
        if (this.showDirtyFlag) {
            var caption = this.caption;
            caption = caption.replace(/^\<span class="DirtyTab"\>\*\<\/span\>\s*/, "");
            if (inDirty)
            caption = '<span class="DirtyTab">*</span> ' + caption;
            this.setCaption(caption);
        }
        }
    },
    getIndex: function() {
        var p = this.parent;
        return p && p.indexOfLayer(this);
    },
    // fired by Layers
    onShow: function() {
        this.callOnShowParent();
    },
    // called onDeactivate rather than onHide as its not meant to indicate when its no longer visible; only when its no
    // longer the active Layer in its parent
        onDeactivate: function() {

    },
        onCloseOrDestroy: function() {},
        customCloseOrDestroy: function() {},
    /* Only valid for layers within a TabLayers */
       setClosable: function(isClosable) {
       this.closable = isClosable;
       this.decorator.applyLayerCaption(this);
       },
       setDestroyable: function(isClosable) {
       this.destroyable = isClosable;
       this.decorator.applyLayerCaption(this);
       },
    handleBack: function(inOptions) {
    if (this.active)
        return false;

    this.activate();
    return true;
    },/*
    restoreFromLocationHash: function(inValue) {
    this.activate();
    },
    generateStateUrl: function(stateObj) {
    if (this.active && !this._mobileFoldingGenerated) {
        var index = this.getIndex();
        if (index == this.parent.defaultLayer || index === 0 && this.parent.defaultLayer === -1) return;
        stateObj[this.getRuntimeId()] = 1;
    }
    },*/
    onTabDrop: function() {}
});

dojo.declare("wm.Layers", wm.Container, {
        manageHistory: true,
        manageURL: false,
        isMobileFoldingParent: false,
        transition: "none",
        clientBorder: "",
        clientBorderColor: "",
    layerIndex: -1,
    defaultLayer: -1,
    decoratorClass: wm.LayersDecorator,
    layersType: 'Layers',
    layoutKind: "top-to-bottom",
    height: "100%",
    width: "100%",
    destroy: function() {
        //console.info('LAYERS destroy called');
        this.inherited(arguments);
        if (this.decorator)
        {
            this.decorator.destroy();
            this.decorator = null;
        }

        this.layers = null;
        this.captionMap = null;
        this.client = null;
    },
    prepare: function() {
        this.layers = [];
        this.captionMap = [];
        this.inherited(arguments);

        // needs to happen before build generates the tabsControl or other affected widget
        var isMobile = wm.isMobile || this._isDesignLoaded && studio.currentDeviceType != "desktop";
        this._headerHeight =  (isMobile && this.mobileHeaderHeight) ? this.mobileHeaderHeight || this.headerHeight : this.headerHeight;
    },
    build: function() {
        this.inherited(arguments);
        this.setLayersType(this.layersType);
    },
    init: function() {


        this.userDefHeaderHeight = this.headerHeight;
        if (!this.isRelativePositioned)
            dojo.addClass(this.domNode, "wmlayers");
        else
            this.setHeaderHeight('20px'); // this case should never really come up as we don't use isRelativePositioned any more
            // vertical defaults to justified; once we get rid of justified, we can remove this property
        this.client = new wm.Panel({isRelativePositioned:this.isRelativePositioned,
                    border: "0",
                    margin: "0",
                    padding: "0",
                    name: "client",
                    parent: this,
                    owner: this,
                    height: "100%",
                    width: "100%",
                    verticalAlign: "top",
                    horizontalAlign: "left",
                    flags: {notInspectable: true, bindInspectable: true}}); // bindInspectable means the user can see it as a container to open in the bind inspector
        this.inherited(arguments);
            this._isDesign = this.isDesignLoaded();

    },
    postInit: function() {
        this.inherited(arguments);
        /*
        if (!this.getCount() && this._isDesignLoaded)
            this.addLayer();
            */
        this._initDefaultLayer();
        // fire onshow when loaded
        if (wm.widgetIsShowing(this)) this._fireLayerOnShow();
        if (this.manageURL && this.owner.locationState) {
            this.restoreFromLocationHash(this.owner.locationState[this.getRuntimeId()]);
        }
    },
    /*
    getPreferredFitToContentHeight: function() {
        return this.padBorderMargin.t + this.padBorderMargin.b + this.getActiveLayer().getPreferredFitToContentHeight();
    },
    getPreferredFitToContentWidth: function() {
        return  this.padBorderMargin.l +  this.padBorderMargin.r + this.getActiveLayer().getPreferredFitToContentWidth();
    },
    */

    _initDefaultLayer: function() {
        var d = this.defaultLayer;
        d = d != -1 ? d : 0;
        var dl = this.getLayer(d);
        // call private index setter so we avoid canShow; however, honor showing property
        if (dl && !dl.showing) {
            d = this._getNextShownIndex(d);
            dl = this.getLayer(d);
        }
        if (dl) this._setLayerIndex(dl.getIndex());
    },
    getVisibleLayerCount: function() {
        var count = 0;
        for (var i = 0; i < this.layers.length; i++) {
            if (this.layers[i].showing) {
                count++;
            }
        }
        return count;
    },
    createLayer: function(inCaption) {
        var caption = inCaption;
        if (!caption) {
            caption = this.owner.getUniqueName("layer1");
        }
        var name = caption;
        if (name) name = name.replace(/\s/g, "_");
        var defName = this.owner.getUniqueName(name);
        var props = {
            width: "100%",
            height: "100%",
            caption: caption,
            parent: this,
            horizontalAlign: "left",
            verticalAlign: "top",
            themeStyleType: this.themeStyleType,
            border: this.clientBorder,
            borderColor: this.clientBorderColor
        };
        var o = this.getRoot();
        if (o) return o.createComponent(defName, "wm.Layer", props);
    },
    addPageContainerLayer: function(inPageName, inCaption, activate) {
        var layer = this.getLayerByCaption(inCaption);
        if (layer) {
            if (activate || activate === undefined) layer.activate();
            return layer;
        }
        layer = this.createLayer(inCaption);
        new wm.PageContainer({
            owner: this.owner,
            parent: layer,
            name: this.owner.getUniqueName(layer.name + "PageContainer"),
            width: "100%",
            height: "100%",
            pageName: inPageName,
            deferLoad: false
        });
        if (activate || activate === undefined) layer.activate();

        if (this.conditionalTabButtons) {
            this.decorator.tabsControl.setShowing(this.getVisibleLayerCount() > 1);
        }

        return layer;
    },

    themeStyleType: "",
    setThemeStyleType: function(inMajor) {
        this.themeStyleType = inMajor;
        for (var i = 0; i < this.layers.length; i++) {
            this.layers[i].setThemeStyleType(inMajor);
        }
    },

    setClientBorder: function(inBorder) {
        this.clientBorder = inBorder;
        // in design mode, set_border updates the design borders
        var method = this.isDesignLoaded() ? "set_border" : "setBorder";
        for (var i = 0; i < this.layers.length; i++) {
            this.layers[i][method](inBorder);
        }
    },
    setClientBorderColor: function(inBorderColor) {
        this.clientBorderColor = inBorderColor;
        for (var i = 0; i < this.layers.length; i++) {
            this.layers[i].setBorderColor(inBorderColor);
        }
    },
    // public api for adding a layer
    addLayer: function(inCaption, doNotSelect) {
        var pg = this.createLayer(inCaption);
        if (!doNotSelect) {
            this._setLayerIndex(this.getCount() - 1);
        } else {
            pg.active = false;
        }
        return pg;
    },
    // called by owner automatically.
    addWidget: function(inWidget) {
        if (inWidget instanceof wm.Layer) {
            this.client.addWidget(inWidget);
            this.layers.push(inWidget);
            this.setCaptionMapLayer(inWidget.caption, inWidget);
            if (this.decorator) {
                this.decorator.decorateLayer(inWidget, this.getCount()-1);
                // de-activate layer by default
                this.decorator.setLayerActive(inWidget, false);
            }
        } else {
            this.inherited(arguments);
        }
    },
    removeWidget: function(inWidget) {
        if (inWidget instanceof wm.Layer) {
            var isActive = inWidget.isActive();
            var i = this.indexOfLayer(inWidget);
            this.layers.splice(i, 1);
            this.setCaptionMapLayer(inWidget.caption, null);
            this.decorator.undecorateLayer(inWidget, i);
            inWidget.active = false;
            inWidget.inFlow = false;
            this.client.removeWidget(inWidget);
            /*
            var found = false;
            for (j = 0; j < this.layers.length; j++) {
            if (this.layers[j].active) {
                this.layerIndex = j;
                found = true;
            }
            }
            if (!found)
            this.setLayerIndex(this.layers.length == 0 ? -1 : (i > 0 ? i - 1 : 0));
            */
            if (isActive && !this._isDestroying && this.layers.length) {
                if (this.layers.length > i) {
                   this.layerIndex = -1;
                   this.setLayerIndex(i);
                } else {
                    this.setLayerIndex(i-1);
                }
            } else if (!this._isDestroying && i <= this.layerIndex) {
                this.layerIndex--;
            }
        } else {
            this.inherited(arguments);
        }
    },
    addControl: function(inControl) {
        if (inControl.owner == this) {
            this.inherited(arguments);
        } else if (inControl instanceof wm.Layer) {
            this.client.addControl(inControl);
        }
    },
    removeControl: function(inControl) {
        if (inControl.owner == this) {
            this.inherited(arguments);
        } else if (inControl instanceof wm.Layer) {
            this.client.removeControl(inControl);
        }
    },
    insertControl: function(inControl, inIndex) {
        if (inControl instanceof wm.Layer) {
            this.addControl(inControl);
            this.moveLayerIndex(inControl, inIndex);
        } else {
            this.inherited(arguments);
        }

    },
    moveControl: function(inControl, inIndex) {
        if (inControl instanceof wm.Layer) {
            if (dojo.indexOf(this.layers, inControl) != -1) {
                this.moveLayerIndex(inControl, inIndex);
                this.client.moveControl(inControl, inControl.getIndex());
            } else {

            }
        } else {
            this.inherited(arguments);
        }
    },
    isWidgetTypeAllowed: function(inChildType) {
        return inChildType == "wm.Layer";
    },
    getLayer: function(inIndex) {
        return this.layers[inIndex != undefined ? inIndex : this.layerIndex];
    },
    getActiveLayer: function() {
      if (this.layerIndex != -1) return this.layers[this.layerIndex];
      var defaultIndex = (this.defaultLayer == -1) ? 0 : this.defaultLayer;
      return this.layers[defaultIndex];
    },
    // public api for removing a layer
    removeLayer: function(inIndex) {
        if (!this.layers)
            return;
        var p = this.getLayer(inIndex);
        if (p)
            this.removeWidget(p);
    },
    indexOfLayer: function(inLayer) {
        for (var i=0, l; (l=this.getLayer(i)); i++)
            if (l == inLayer)
                return i;
        return -1;
    },
    indexOfLayerName: function(inLayerName) {
        for (var i=0, l; (l=this.getLayer(i)); i++)
            if (l.name == inLayerName)
                return i;
        return -1;
    },
    indexOfLayerCaption: function(inCaption) {
        return this.indexOfLayer(this.captionMap[inCaption]);
    },
    getLayerCaption: function(inIndex) {
        var p = this.getLayer(inIndex);
        return p && p.caption;
    },
    getLayerByCaption: function(inCaption) {
        return this.getLayer(this.indexOfLayerCaption(inCaption));
    },
    setLayerByCaption: function(inCaption) {
        var p = this.captionMap[inCaption];
        this.setLayerByName(p && p.name ? p.name : inCaption);
    },
    setLayerByName: function(inName) {
        var l = this.client.widgets[inName];
        if (l)
            this.setLayer(l);
        else if (inName)
            this.addLayer(inName);
    },
    setLayer: function(inNameOrLayer) {
        if (inNameOrLayer instanceof wm.Layer)
            // note: use setProp so we can call design version
            this.setProp("layerIndex", inNameOrLayer.getIndex());
        else
            this.setLayerByName(inNameOrLayer);
    },
    setLayerInactive: function(inLayer) {
        wm.fire(inLayer.decorator, "deactivateLayer", [inLayer]);
        inLayer.onDeactivate();
        inLayer.onHide();
    },
    setLayerIndex: function (inIndex) {
        if (inIndex == this.layerIndex) return;
        var fireEvents = !this.loading;
        var oldLayer = this.layers[this.layerIndex];
        var l = this.getLayer(inIndex);
        if (fireEvents) {
            var info = {
                newIndex: inIndex,
                canChange: undefined
            };
            this.oncanchange(info);
            if (info.canChange === false) return;
            inIndex = info.newIndex;
        }
        if (inIndex < 0 || inIndex > this.getCount() - 1) return;

        if (fireEvents && oldLayer) {
        oldLayer.callOnHideParent();
        }
        this._setLayerIndex(inIndex);
        if (fireEvents) {
            if (l) {
                if (app.debugDialog && !this.isAncestor(app.debugDialog)) {
                    var i = 0;
                    var caller = arguments.callee.caller;
                    var ignoreFunctions = ["setProp", "setLayer", "setLayerByName", "setLayerByCaption", "addLayer","activate","update"];
                    while (caller && dojo.indexOf(ignoreFunctions, caller.nom) != -1 && i < 15) {
                        caller = caller.caller;
                        i++;
                    }
                    var eventId = app.debugDialog.newLogEvent({
                                eventType: "layer",
                                sourceDescription: (caller && caller.nom ? caller.nom + "()" : ""),
                                resultDescription: "Activating Layer: " + l.getRuntimeId() + ".activate()",
                                firingId: l.getRuntimeId(),
                                affectedId: l.getRuntimeId(),
                                method: "hide"
                            });

                }
                l.onShow();
                if (eventId) app.debugDialog.endLogEvent(eventId);
            }
            if (oldLayer) {
            	oldLayer.onDeactivate();
            	oldLayer.onHide();
            }
        }
        if (fireEvents && this.lastLayerIndex != this.layerIndex) this.onchange(this.layerIndex);
        if (!this._initialization && oldLayer &&  !this._isDesignLoaded && this.manageHistory) {
        app.addHistory({id: oldLayer.getRuntimeId(),
                   options: {},
                title: "Show " + l.caption});
        }
    },
    _setLayerIndex: function(inIndex) {
        this.lastLayerIndex = this.layerIndex;
        this.layerIndex = inIndex;
        var l = this.getLayer(inIndex);
        if (l) {
        this.decorator.activateLayer(l);
        var page = this.getParentPage();
        if (page && page.validateVisibleOnly) {
            this.validate();
        }
        }
    },
    setDecoratorClass: function(inClass) {
        this.decoratorClass = inClass;
        this.createDecorator();
    },
    createDecorator: function() {
        if (this.decorator)
            this.decorator.destroy();
        this.decorator = this.decoratorClass ? new this.decoratorClass(this) : null;
    },
    setLayersType: function(inLayersType) {
        var ctor = wm[inLayersType + 'Decorator'];
        if (!ctor)
            return;
        this.layersType = inLayersType;
        var i = this.layerIndex;
        if (this.decorator) {
        this.decorator.undecorate();
        this.decorator.destroy();
        this.decorator = null;
        }
        this.setDecoratorClass(ctor);
        this.decorator.decorate();
        this._setLayerIndex(i);
        this.reflow();
    },
    setDefaultLayer: function(inLayerIndex) {
        this.defaultLayer = inLayerIndex;
    },
    getCount: function() {
        return this.layers.length;
    },
    setCaptionMapLayer: function(inCaption, inLayer) {
        try
        {
            this.captionMap[inCaption] = inLayer;
        }
        catch(e)
        {
            // do nothing as this might happen when we are trying to destroy all the layers.
        }
    },
    _getNextShownIndex: function(inIndex, isSecondCall) {
    var count = this.layers.length;
    for (var i = inIndex + 1; i < count && !this.layers[i].showing; i++) ;
    if (this.layers[i] && this.layers[i].showing) return i;
    if (!isSecondCall)
        return this._getPrevShownIndex(inIndex,true);
    return 0;
    },
    _getPrevShownIndex: function(inIndex, isSecondCall) {
    for (var i = inIndex - 1; i >= 0 && !this.layers[i].showing; i--) ;
    if (this.layers[i] && this.layers[i].showing) return i;
    if (!isSecondCall)
        return this._getNextShownIndex(inIndex,true);
    return 0;
    },
/*
    _getPrevNextShownIndex: function(inIndex, inPrev, inBounded) {
        var
            d = inPrev ? -1 : 1,
            c = this.getCount(),
            e = inPrev ? 0 : c-1,
            w = inPrev ? c-1 : 0,
            i = inPrev ? Math.min(inIndex+d, w) : Math.max(inIndex+d, 0),
            l;
        while (i != inIndex) {
            l = this.getLayer(i);
            if (l && l.showing)
                return i;
            if (inPrev ? i > e : i < e)
                i = i + d;
            else {
                if (inBounded)
                    return;
                else
                    i = w;
            }
        }
    },
    */
    setNext: function(inBounded) {
        var p = this._getNextShownIndex(Number(this.layerIndex), false);
        if (p !== undefined)
            this.setLayerIndex(p);
    },
    setPrevious: function(inBounded) {
        var p = this._getPrevShownIndex(Number(this.layerIndex), false);
        if (p !== undefined)
            this.setLayerIndex(p);
    },
    moveLayerIndex: function(inLayer, inIndex) {
        if (inIndex == -1) inIndex = this.layers.length-1;
        var i = inLayer.getIndex(), inIndex = Math.max(0, Math.min(inIndex, this.getCount()-1));
        if (i == inIndex)
            return;
        // fixup layers array
        this.layers.splice(i, 1);
        this.layers.splice(inIndex, 0, inLayer);
        // decorate
        this.decorator.moveLayerIndex(i, inIndex);
        // change layer
            if (inLayer.active) {
            this._setLayerIndex(inIndex);
        } else {
            for (var i = 0; i < this.layers.length; i++) {
            if (this.layers[i].active) {
                this.layerIndex = i;
                break;
            }
            }
        }
    },
    _fireLayerOnShow: function() {
        var l = this.getLayer(this.layerIndex);
        l && l.onShow();
    },
    _onShowParent: function() {
        this._fireLayerOnShow();
    },
    /* This method destroyes the client, not just the layers; and as best I can tell, should never be used */
    clear: function() {
        wm.forEach(this.widgets, function(w) {
            w.destroy();
        });
        this.widgets = {};
        this.layers = [];
        this.domNode.innerHTML = "";
    },
    // events
   _oncanchangeBeforeStart: 1,
    oncanchange: function(inChangeInfo) {
        var l = this.getLayer(inChangeInfo.newIndex);
        inChangeInfo.canChange =  (l && l.showing);
    },
    onchange: function(inIndex) {
    },
    // used only by Tabs
    headerHeight: "27px",
    mobileHeaderHeight: "37px",
    setHeaderHeight: function(inHeight) {
        if (this.layersType != 'Tabs' && this.layersType != "RoundedTabs" && this.layersType != "Wizard" && this.layersType != "Breadcrumb")
            return;
        this._headerHeight = inHeight;
        this.decorator && this.decorator.tabsControl && this.decorator.tabsControl.setHeight(inHeight);

        delete this._lastTabHeight;
        this.renderBounds();

    },
    renderBounds: function() {
        this.inherited(arguments);
        if (this.layersType != 'Tabs' && this.layersType != "RoundedTabs") return;
        if (!this.decorator || !this.decorator.tabsControl) return;
        if (this.decorator.tabsControl.isDestroyed) return;

        wm.job(this.getRuntimeId() + ".renderBounds", 10, this, function() {
            if (this.isDestroyed || this._lockHeaderHeight) return;
            if (this.decorator.btns.length <= 1) return;
            var originalHeight = this.decorator.tabsControl.bounds.h;
            this.decorator.tabsControl.domNode.style.height = 'auto';
            var newheight;
            var lastShowingTab, firstShowingTab;
            for (var i = this.decorator.btns.length - 1; i >= 1; i--) {
                if (this.decorator.btns[i].style.display != "none") {
                    if (!firstShowingTab) firstShowingTab = this.decorator.btns[i];
                    lastShowingTab = this.decorator.btns[i];
                    break;
                }
            }
            /* Sometimes the buttons are a few px off, but we know they've wrapped to the next line of they are many pixels different in offsetTop */
            if (lastShowingTab && Math.abs(firstShowingTab.offsetTop - lastShowingTab.offsetTop) > 4 ) {
                if (this._headerHeight == this.decorator.tabsControl.height) {
                    this.decorator.tabsControl.domNode.style.height = this.decorator.tabsControl.bounds.h + "px";
                } else {
                    this.decorator.tabsControl.setHeight(this._headerHeight);
                }
            } else {
                newheight = Math.max(this.decorator.tabsControl.domNode.clientHeight, parseInt(this._headerHeight));
                if (newheight != this.decorator.tabsControl.bounds.h) {
                    this.decorator.tabsControl.setHeight(newheight + "px");
                } else {
                    this.decorator.tabsControl.domNode.style.height = this.decorator.tabsControl.bounds.h + "px"; // clear the "auto"
                }
            }
        });
    },
    getMinHeightProp: function() {
        if (this.minHeight) return this.minHeight;
        var minHeight = 15;
        if (this.layersType.match(/tabs/i)) minHeight += parseInt(this._headerHeight);
        return minHeight;
    },
    getMinWidthProp: function() {
        if (this.minWidth) return this.minWidth;
        var minWidth = 80;
        if (this.layersType.match(/tabs/i)) minWidth += 120; // need horiz space for tabs
        return minWidth;
    },
    restoreFromLocationHash: function(inValue) {
    var value = inValue;
    if (value !== undefined) {
        var w = this.manageHistory;
        this.manageHistory = false;
        var index = Number(inValue);
        this.setLayerIndex(inValue);
        this.manageHistory = w;
    }
    },
    generateStateUrl: function(stateObj) {
    if (!this._isDesignLoaded && this.getActiveLayer()) {
        var defaultIndex = this.defaultLayer == -1 ? 0 : this.defaultLayer;
        var index = this.layerIndex;
        if (index != defaultIndex && !this.getActiveLayer()._mobileFoldingGenerated) {
        stateObj[this.getRuntimeId()] = this.layerIndex;
        }
    }
    }
});


dojo.declare("wm.TabLayers", wm.Layers, {
       dndTargetName: "",
        //useDesignBorder: 0,
       themeStyleType: "ContentPanel",
       layersType: 'Tabs',
       conditionalTabButtons: false,
       verticalButtons: false,
        headerWidth: "50px",
/*
        setHeaderHeight: function(inHeight) {
        this.headerHeight = inHeight;
        this.c$[0].setHeight(inHeight);
    },
    */
    postInit: function() {
    this.inherited(arguments);
    if (this.conditionalTabButtons) {
        this.decorator.tabsControl.setShowing(this.getVisibleLayerCount() > 1);
    }
    },
    addLayer: function(inCaption, doNotSelect) {
        var result = this.inherited(arguments);
        if (!this._cupdating && !this.owner._loadingPage)
        this.renderBounds();
        if (this.conditionalTabButtons)
        this.decorator.tabsControl.setShowing(this.getVisibleLayerCount() > 1);
        return result;
    },
    removeLayer: function(inIndex) {
        this.inherited(arguments);
        if (this.conditionalTabButtons && !this.isDestroyed)
        this.decorator.tabsControl.setShowing(this.getVisibleLayerCount() > 1);
    },
    // onClose handles both destroy and close as long as it came from clicking the close icon in the tab button
    onCloseOrDestroy: function(inLayer) {

    },
    customCloseOrDestroy: function(inLayer) {

    },
    onTabDrop: function() {},
    onTabRemoved: function() {}
/*,
       afterPaletteDrop: function(){
        this.inherited(arguments);
        this.setLayersType("RoundedTabs");
       }        */
});




}

if(!dojo._hasResource["wm.base.RbacPlugin"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.RbacPlugin"] = true;
/*
 * Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide("wm.base.RbacPlugin");





wm.Plugin.plugin("rbac", wm.Widget, {
    roles: '',
    prepare: function() {
        this.rbacSocket(arguments);
        if (this.roles && this.roles.length && app.isSecurityEnabled) {
            this._rbacShowingRequested = this.showing;
            this.showing = this.updateRbacShowing(this.showing);
            this.subscribe("wmRbacUpdate", this, "reshowRbac");
        }
    },
    reshowRbac: function() {
    this.setShowing(this._rbacShowingRequested);
    },
    setShowing: function(inValue) {
    /* wm.Layer.setShowing calls TabDecorator.setShowing which calls wm.Control.setShowing, which would clobber our
     * _mobileShowingRequested value
     */
    if (this instanceof wm.Layer == false && this.roles)
        inValue = this.updateRbacShowing(inValue);
    this.rbacSocket(arguments);
    },
    updateRbacShowing: function(inValue) {
    if (!this._cupdating)
        this._rbacShowingRequested = inValue; // cache whether it should be showing even if we don't let it show
    return inValue && this.isRbacShowAllowed();
    },

    isRbacShowAllowed: function() {
        var userRoles = this._getUserRoles();
        if (userRoles) {
            for (var i=0, r; (r=this.roles[i]); i++) {
                for (var j=0, ur; (ur=userRoles[j]); j++) {
                    if (r == ur) {
                        return true;
                    }
                }
            }
            return false;
        }
        return true;
    },
    _getUserRoles: function() {
        if (this.isDesignLoaded()) {
            // this should return the "Preview By Role(s)" roles
            return null;
        } else {
            return wm.getUserRoles();
        }
    }
});

wm.Plugin.plugin("rbacLayer", wm.Layer, {
    setShowing: function(inValue) {
        if (this.roles && this.roles.length) {
            inValue = this.updateRbacShowing(inValue);
        }
        this.rbacLayerSocket(arguments);
    }
});

wm.Plugin.plugin("rbacservice", wm.ServiceVariable, {
    roles: '',
    update: function() {
        if (djConfig.isDebug) {
            try {
                this.log("update", arguments.callee.caller.nom || arguments.callee.caller.name || "anonymous");
            } catch (e) {}
        }
        if (!this.roles || this.isRbacUpdateAllowed()) {
            return this.rbacserviceSocket(arguments);
        } else {
            console.log(this.getId() + " blocked by role settings");
            return new dojo.Deferred();
        }
    },
    updateInternal: function() {
        if (!this.roles || this.isRbacUpdateAllowed()) {
            return this.rbacserviceSocket(arguments);
        } else {
            console.log(this.getId() + " blocked by role settings");
        }
    },
    isRbacUpdateAllowed: function() {
        var userRoles = this._getUserRoles();
        if (userRoles) {
            for (var i = 0, r;
            (r = this.roles[i]); i++) {
                for (var j = 0, ur;
                (ur = userRoles[j]); j++) {
                    if (r == ur) {
                        return true;
                    }
                }
            }
            return false;
        }
        return true;
    },
    _getUserRoles: function() {
        if (this.isDesignLoaded()) {
            // this should return the "Preview By Role(s)" roles
            return null;
        } else {
            return wm.getUserRoles();
        }
    }
});


}

if(!dojo._hasResource["wm.base.MobilePlugin"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.MobilePlugin"] = true;
dojo.provide("wm.base.MobilePlugin");




wm.Plugin.plugin("mobile", wm.Control, {
    deviceSizes: '',
    prepare: function(inProps) {
        this.mobileSocket(arguments);
        if (this.deviceSizes || inProps.deviceSizes || window["studio"] && this.deviceType) {
            this._mobileShowingRequested = this.showing;
            this.showing = this.updateMobileShowing(this.showing);
            this.subscribe("deviceSizeRecalc", this, "reshowMobile");
        }
    },
    reshowMobile: function() {
        this.setShowing(this._mobileShowingRequested || this.showing);
    },
    setShowing: function(inValue) {
        /* wm.Layer.setShowing calls TabDecorator.setShowing which calls wm.Control.setShowing, which would clobber our
         * _mobileShowingRequested value
         */
        if (this instanceof wm.Layer == false && this.deviceSizes || this._isDesignLoaded && this.deviceType) inValue = this.updateMobileShowing(inValue);
        this.mobileSocket(arguments);
    },
    updateMobileShowing: function(inValue) {
        if (!this._cupdating) this._mobileShowingRequested = inValue; // cache whether it should be showing even if we don't let it show
        if (this.deviceSizes && this.deviceSizes.length || this._isDesignLoaded && this.deviceType) {
            return inValue && this.isMobileShowAllowed();
        } else {
            return inValue;
        }
    },
    isMobileShowAllowed: function() {
        if (window["studio"] && this.isDesignLoaded()) {
            var deviceType = studio.currentDeviceType;
            if (deviceType && this.deviceType && dojo.indexOf(this.deviceType, deviceType) == -1) {
                return false;
            }

            var deviceSize = studio.deviceSizeSelect.getDataValue();
            if (!deviceSize) return true;
            if (deviceType == "desktop" || studio.portraitToggleButton.clicked) {
                deviceSize = deviceSize.width;
            } else {
                deviceSize = deviceSize.height;
            }
            if (deviceSize == "100%") return true;
            deviceSize = app.appRoot.calcDeviceSize(parseInt(deviceSize));
            var isOk = true;
            if (this.deviceSizes && dojo.indexOf(this.deviceSizes, deviceSize) == -1) return false;
            return true;
        } else {
            var deviceSize = app.appRoot.deviceSize;
            return (!deviceSize || dojo.indexOf(this.deviceSizes, deviceSize) != -1);
        }
    }
});

wm.Plugin.plugin("mobileLayer", wm.Layer, {
    deviceSizes: '',
    setShowing: function(inValue) {
        inValue = this.updateMobileShowing(inValue);
        this.mobileLayerSocket(arguments);
    }
});

}

if(!dojo._hasResource["wm.base.I18nPlugin"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.I18nPlugin"] = true;
/*
 * Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */


dojo.provide("wm.base.I18nPlugin");


wm.getDictionaryItem = function(name, params) {
    if (params == undefined) return wm.locale.phrases[name];

    var newparams = {};
    for (var i in params) {
        newparams[i] = (params[i] === undefined || params[i] === null) ? "" : params[i];
    }
    return dojo.string.substitute(wm.locale.phrases[name], newparams);
}

wm.Plugin.plugin("i18n", wm.Component, {
    prepare: function(inProps) {
        if (inProps && inProps.owner) {
            var entry = inProps.owner.getDictionaryItem(inProps.name);
        }
        if (entry) {
            inProps = dojo.mixin(inProps, entry);
        }
        if (wm.branding) {
            var app = inProps.owner ? inProps.owner.getOwnerApp() : null;
            if (app && app._brandingDictionary) {
                var owner = inProps.owner;
                var ownerName;
                if (owner == app) {
                    ownerName = "app";
                } else if (owner instanceof wm.Page) {
                    ownerName = owner.declaredClass;
                }
                if (ownerName && app._brandingDictionary[ownerName] && app._brandingDictionary[ownerName][inProps.name]) {
                    var componentProps = app._brandingDictionary[ownerName][inProps.name];
                    var locale = dojo.locale;
                    for (prop in componentProps) {
                        var propHash = componentProps[prop];
                        if (propHash[locale] !== undefined) {
                            inProps[prop] = propHash[locale];
                        } else if (propHash["default"] !== undefined) {
                            inProps[prop] = propHash["default"];
                        }
                    }
                }
            }
        }
        this.i18nSocket(arguments);
    },
    getDictionaryItem: function(name, params) {
        if (!this._i18nDictionary) {
            if (this.owner) {
                return this.owner.getDictionaryItem(name, params);
            } else {
                return "";
            }
        }
        if (params == undefined) {
            return this._i18nDictionary[name];
        } else {
            // undefined as a value can throw errors:
            var newparams = {};
            for (var i in params)
            newparams[i] = (params[i] === undefined || params[i] === null) ? "" : params[i];
            return dojo.string.substitute(this._i18nDictionary[name], newparams);
        }
    }
});

}

if(!dojo._hasResource["wm.base.components.NavigationService"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.components.NavigationService"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide("wm.base.components.NavigationService");


/**
    Service for client side navigation.
    <br /><br />
    Navigation methods on this class are also
    available as service operations where noted.
    Service operation inputs match the
    arguments on the related method, and so they
    are not documented separately.
    <br />
    @name wm.NavigationService
    @class
    @extends wm.Service
*/
dojo.declare("wm.NavigationService", wm.Service, {
    /** @lends wm.NavigationService.prototype */
    layer: "",
    layers: "",
    operation: "",
    _operations: {
        gotoLayer: {
            parameters: {
                layer: { type: "wm.Layer"},
                showOnlyParentLayer: {type: "boolean"}
            },
            returnType: "any",
            hint: "This operations displays the selected layer."
        },
        nextLayer: {
            parameters: {
                layers: { type: "wm.Layers"}
            },
            returnType: "any",
            hint: "The operation displays the next layer in the selected layers widget."
        },
        previousLayer: {
            parameters: {
                layers: { type: "wm.Layers"}
            },
            returnType: "any",
            hint: "The operation displays the previous layer in the selected layers widget."
        },
        gotoPage: {
            parameters: {
                pageName: { type: "string" }
            },
            returnType: "any",
            hint: "This operation displays a different page and requires a pageName."
        },
        gotoHomePage: {
            returnType: "any",
            hint: "This operation displays the home page."
        },
        gotoPageContainerPage: {
            parameters: {
                pageName: { type: "string" },
                pageContainer: { type: "wm.PageContainer" }
            },
            returnType: "any",
            hint: "This operation displays a page in a pageContainer and requires both a pageContainer and a pageName."
        },
        gotoDialogPage: {
            parameters: {
                pageName: {type: "string"},
                hideControls: {type: "boolean"},
                title: {type: "string"},
                modal: {type: "boolean"},
                width: {type: "number"},
                height: {type: "number"}
            },
            returnType: "any",
            hint: "This operation displays a page in a dialog."
            },
        showToast: {
            parameters: {
                content: {type: "string"},
                duration: {type: "number"},
                cssClasses: {type: "string"},
                            dialogPosition: {type: "string"}
            },
            returnType: "any",
            hint: "This operation displays a page in a dialog."
        }
    },
    update: function() {
        this[this.operation || "gotoLayer"]();
    },
        invoke: function(inMethod, inArgs, inOwner) {
        var
            d = this._deferred = new dojo.Deferred(),
            m = this[inMethod];

        if (m) {
               inArgs.push(inOwner);
               m.apply(this, inArgs);
        } else {
            this.onError();
                /* TODO: Localize (probably not needed */
            d.errback("operation: " + inMethod + " does not exist.");
        }
        return d;
    },
    doResult: function() {
        if (this._resultConnect) {
            dojo.disconnect(this._resultConnect);
            this._resultConnect = null;
        }
        if (this._cancelConnect) {
            dojo.disconnect(this._cancelConnect);
            this._cancelConnect = null;
        }
        this.onResult();
        if (this._deferred && this._deferred.fired == -1)
            this._deferred.callback(true);
        this._deferred = null;
    },
    doError: function() {
        if (this._resultConnect) {
            dojo.disconnect(this._resultConnect);
            this._resultConnect = null;
        }
        if (this._cancelConnect) {
            dojo.disconnect(this._cancelConnect);
            this._cancelConnect = null;
        }
        this.onError();
        if (this._deferred && this._deferred.fired == -1)
            this._deferred.callback(true);
        this._deferred = null;
    },
    /**
        Shows a layer.
        <br /><br />
        This method is available as a configurable operation on this service.
        @param {wm.Layer} inLayer The layer to show.
    */
    gotoLayer: function(inLayer,showParentOnly) {
        var l = inLayer instanceof wm.Layer ? inLayer : null;
        if (l)
          this.showLayer(l,showParentOnly);
        this.doResult();
    },
    /**
        Show the next layer in a set of layers.
        <br /><br />
        This method is available as a configurable operation on this service.
        @param {wm.Layers} inLayers The set of layers to operate on.
    */
    nextLayer: function(inLayers) {
        var l = inLayers instanceof wm.Layers ? inLayers : null;
        if (l)
            l.setNext();
        this.doResult();
    },
    /**
        Show the previous layer in a set of layers.
        <br /><br />
        This method is available as a configurable operation on this service.
        @param {wm.Layers} inLayers The set of layers to operate on.
    */
    previousLayer: function(inLayers) {
        var l = inLayers instanceof wm.Layers ? inLayers : null;
        if (l)
            l.setPrevious();
        this.doResult();
    },
    showLayer: function(inLayer,showParentOnly) {
        var l = inLayer;
        while (l) {
            wm.fire(l, "activate");
            l = l.parent;
            if (showParentOnly) break;
        }
    },
    /**
        Dynamically load and show a top level page.
        <br /><br />
        This method is available as a configurable operation on this service.
        @param {String} inPageName The page to load.
    */
    gotoPage: function(inPageName, inOwner) {
        var page = inOwner == app ? app._page : inOwner.getParentPage();
        // If no app level page exists yet (untested condition that probably never arises)
        // Or if inOwner has no page (untested condition that implies the owner is app level or has an improperly set owner)
        // Or if the page of inOwner is the app level page, then change the app level page
        if(!app._page || !page || page == app._page) {
            this._resultConnect = dojo.connect(app, "onPageChanged", this, "doResult");
            this._cancelConnect = dojo.connect(app.pageContainer, "pageChangeIgnored", this, "doError");
            // Delay openning the page as loading the page immediately will cause the widgets/components that triggered this to be destroyed in the
            // middle of calling this.  Use wm.job so that if another page request fires, this one is canceled
            wm.job(this.getRuntimeId() + ": PageChange", 1, function() {
                app.loadPage(inPageName);
            });
        } else if(page.owner instanceof wm.PageContainer || page.owner instanceof wm.PageContainerMixin) {
            this.gotoPageContainerPage(inPageName, page.owner);
        }
    },
    gotoHomePage:function(inOwner){
        this.gotoPage(app.main,inOwner);
    },
    /**
        Dynamically load and show a page inside of a page container.
        <br /><br />
        This method is available as a configurable operation on this service.
        @param {String} inPageName The page to load.
        @param {wm.PageContainer} inPageContainer The page container that will contain the page.
    */
    gotoPageContainerPage: function(inPageName, inPageContainer) {
        if (inPageContainer) {
            // note, pageContainer does not call onPageChanged unless a page actually changed
            // to avoid confusion, we choose to process the navigation regardless
            // so call doResult manually if the page will not change.
            if (inPageName != inPageContainer.pageName) {
                this._resultConnect = dojo.connect(inPageContainer, "onPageChanged", this, "doResult");
                this._cancelConnect = dojo.connect(inPageContainer, "pageChangeIgnored", this, "doError");

                inPageContainer.setPageName(inPageName);

            } else
                this.doResult();
        } else
            wm.logging && console.debug("pageContainer not found", inPageContainer);
    },
    /**
        Dynamically load and show a page inside of dialog box.
        <br /><br />
        This method is available as a configurable operation on this service.
        @param {String} inPageName The page to load.
        @param {Boolean} inHideControls Set true to hide the default dialog controls.
        @param {Number} inWidth The width of the dialog content area in pixels.
        @param {Number} inHeight The height of the dialog content area in pixels.
    */
        gotoDialogPage: function(inPageName, inHideControls, inTitle, inModal, inWidth, inHeight) {
            this._resultConnect = dojo.connect(app.pageDialog, "onPageReady", this, "doResult");
            app.pageDialog.showPage(inPageName, inHideControls, String(inWidth || 450) +"px", String(inHeight || 300) +"px", inTitle, Boolean(inModal));
        },
        showToast: function(inContent, inDuration, cssClasses, toastPosition) {
            app.createToastDialog();
        app.toastDialog.showToast(inContent, inDuration, cssClasses, toastPosition);
        this._deferred.callback(); // the action is now complete; fire any deferred code (clears this._requester)
    }

});

wm.services.add({name: "navigationService", ctor: "wm.NavigationService", isClientService: true, clientHide: true});

dojo.declare("wm.NavigationCall", [wm.Component, wm.ServiceCall], {
    /** @lends wm.Variable.prototype */
    service: "navigationService",
    operation: "gotoLayer",
    // page navigation can lead to destruction, so abort processing
    processResult: function(inResult) {
        if (!this.owner)
            return;
        return this.inherited(arguments);
    },
    processError: function(inError) {
        if (!this.owner)
            return;
        return this.inherited(arguments);
    }
});


}

if(!dojo._hasResource["wm.base.components.NotificationService"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.components.NotificationService"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide("wm.base.components.NotificationService");


dojo.declare("wm.NotificationService", wm.Service, {
	/** @lends wm.PhoneGapService.prototype */
	operation: "",
	_operations: {
		alert: {
			parameters: {
			    text: { type: "string" }
			},
		    returnType: "any"
		},
		confirm: {
			parameters: {
			    text: { type: "string" },
			    OKButtonText: {type: "string"},
			    CancelButtonText: {type: "string"}
			},
		    returnType: "any"
		},
		prompt: {
			parameters: {
			    text: { type: "string" },
			    defaultValue: {type: "string"},
			    OKButtonText: {type: "string"},
			    CancelButtonText: {type: "string"}
			},
		    returnType: "StringData"
		},
		warnOnce: {
			parameters: {
			    text: { type: "string" },
			    cookieName: {type: "string"}
			},
		    returnType: "StringData"
		},

		toast: {
			parameters: {
			    text: {type: "string"},
			    duration: {type: "number"},
 			    cssClasses: {type: "string"},
                            dialogPosition: {type: "string"}
			},
			returnType: "any",
			hint: "This operation displays a page in a dialog."
		}
	},
    update: function() {
        this[this.operation]();
    },
    invoke: function(inMethod, inArgs, inOwner) {
        var m = this[inMethod];
        var d;
        if (m) {
            inArgs.push(inOwner);
            var newd = m.apply(this, inArgs);
            if (newd instanceof dojo.Deferred) d = newd;
        } else {
            this.onError(); /* TODO: Localize (probably not needed */
            d.errback("operation: " + inMethod + " does not exist.");
        }
        this._deferred = d || new dojo.Deferred();
        return this._deferred;
    },
    alert: function(text) {
        var d = new dojo.Deferred();
        app.alert(text);
        this.connectOnce(app.alertDialog, "onClose", function() {
            d.callback();
        });
        return d;
    },
    confirm: function(text, OKButtonText, CancelButtonText) {
        var d = new dojo.Deferred();
        var ok = OKButtonText || wm.getDictionaryItem("wm.Application.CAPTION_ALERT_OK");
        var cancel = CancelButtonText || wm.getDictionaryItem("wm.Application.CAPTION_CONFIRM_CANCEL");
        app.confirm(text, false, function() {
            d.callback(true);
        }, function() {
            d.errback();
        }, ok, cancel, false);
        return d;
    },
    prompt: function(text, defaultValue, OKButtonText, CancelButtonText) {
        var d = new dojo.Deferred();
        var ok = OKButtonText || wm.getDictionaryItem("wm.Application.CAPTION_ALERT_OK");
        var cancel = CancelButtonText || wm.getDictionaryItem("wm.Application.CAPTION_CONFIRM_CANCEL");
        app.prompt(text, defaultValue, function(inText) {
            d.callback(inText);
        }, function() {
            d.errback();
        }, ok, cancel);
        return d;
    },
    warnOnce: function(text, cookieName) {
        var d = new dojo.Deferred();
        if (!app.warnOnce(cookieName, text)) {
            d.callback();
        } else {
            this.connectOnce(app.alertDialog, "onClose", function() {
                d.callback();
            })
        }
        return d;
    },
    toast: function(text, inDuration, cssClasses, toastPosition) {
        var d = new dojo.Deferred();
        app.createToastDialog();
        app.toastDialog.showToast(text, inDuration, cssClasses, toastPosition);
        /*
        this.connectOnce(app.toastDialog, "onClose", function() {
            d.callback();
        });
*/
        d.callback(); // toast invokation does not need to wait for the dialog to dismiss; doing so would prevent additional calls to this notification
        return d;
    }

});

wm.services.add({name: "notificationService", ctor: "wm.NotificationService", isClientService: true, clientHide: true});

dojo.declare("wm.NotificationCall", [wm.Component, wm.ServiceCall], {
    service: "notificationService",
    operation: "alert",

    // this is called if the dialog dismisses normally
    processResult: function(inResult) {
        switch (this.operation) {
        case "alert":
        case "confirm":
        case "prompt":
        case "warnOnce":
            this.onOk(inResult);
            break;
        }
        this.onClose();
    },
    // this is called if the user clicks cancel
    processError: function() {
        this.onCancel();
        this.onClose();
    },
    onCancel: function() {},
    onOk: function(inResult) {},
    onClose: function() {}
});

wm.Object.extendSchema(wm.NotificationCall,{
    owner: { group: "common", order: 1, readonly: true, options: ["Page", "Application"]},
    service: {ignore: 1, writeonly: 1},
    operation: { group: "data", order: 1},
    updateNow: { ignore: 1},
    queue: {ignore:1},
    clearInput: { group: "operation", operation:1, order: 30},
    input: {group: "data", order: 3, putWiresInSubcomponent: "input", bindTarget: 1, treeBindField: true, editor: "wm.prop.NavigationGroupEditor"},
    inFlightBehavior: {ignore:1},
    autoUpdate: {ignore:1},
    startUpdate: {ignore:1},
    onError: {ignore:1},
    onSuccess: {ignore:1},
    onBeforeUpdate: {ignore:1},
    onCanUpdate: {ignore:1},
    onResult: {ignore:1}
});


}

if(!dojo._hasResource["wm.base.components.PhoneGapService"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.components.PhoneGapService"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide("wm.base.components.PhoneGapService");


dojo.declare("wm.PhoneGapService", wm.Service, {
    /** @lends wm.PhoneGapService.prototype */
    operation: "",
    _operations: {
        contacts_read: {
            parameters: {
                filter: { type: "string" }
            },
            returnType: "[phonegap.Contact]"
        },
        contacts_delete: {
            parameters: {
                id: { type: "number" }
            },
            returnType: "any"
        },
        contacts_save: {
            parameters: {
                contact: { type: "phonegap.Contact" }
            },
            returnType: "any"
        },
        notification_beep: {
            parameters: {
                times: { type: "number" }
            },
            returnType: "any"
        },
        notification_vibrate: {
            parameters: {
                miliseconds: { type: "number" }
            },
            returnType: "any"
        },
        capture_audio: {
        parameters: {}, // TODO Support the limit property so we can return multiple images
        returnType: "StringData"
        },
        capture_picture: {
        parameters: {
            quality: {type: "number"},
            sourceType: {type: "string"},
            allowEdit: {type: "boolean"}
        },
        returnType: "StringData"
        },
        geolocation_getCurrentPosition: {
        parameters: {
            enableHighAccuracy: {type: "boolean"},
            timeout: {type: "number"}, // phonegap example uses value of 5000
            maximumAge: {type: "number"} // phonegap example uses value of 3000 though I think our users could use something on the order of 1-5 minutes (convert to miliseconds before using here)
        },
        returnType: "phonegap.Coordinates"
        }
    },
    update: function() {
        this[this.operation]();
    },
    invoke: function(inMethod, inArgs, inOwner) {
        var
        d = this._deferred = new dojo.Deferred(),
            m = this[inMethod];

        if (m) {
            inArgs.push(inOwner);
            var newd = m.apply(this, inArgs);
            if (newd instanceof dojo.Deferred) d = this._deferred = newd;
        } else {
            this.onError(); /* TODO: Localize (probably not needed */
            d.errback("operation: " + inMethod + " does not exist.");
        }
        return d;
    },
    geolocation_getCurrentPosition: function(enableHighAccuracy, timeout, maximumAge) {
        var d = new dojo.Deferred();
        if (window["PhoneGap"]) {
            navigator.geolocation.getCurrentPosition(
                dojo.hitch(this, function(inResult) {
                    d.callback(inResult.coords);
                }),
                function(inError) {
                    d.errback(inError);
                },
                {
                    enableHighAccuracy: enableHighAccuracy || false,
                    timeout: timeout || 5000,
                    maximumAge: maximumAge || 1200000
                }
            );
        }
        return d;
    },
    capture_audio: function() {
        var d = new dojo.Deferred();
        if (window["PhoneGap"]) {
            navigator.device.capture.captureAudio(
            dojo.hitch(this,
                function(inResult) {
                    //alert("Audio Capture Success:"+inResult.length);
                    var filePath = inResult[0].fullPath;
                    var name = inResult[0].name;
                    this.readDataUrl(filePath, d);
                }),
                function(inError) {
                    this.handleCaptureError(inError.code, d);
                },
                {
                    limit: 1
                }
            );
        }
        return d;
    },

    capture_picture: function(quality, sourceType, allowEdit) {
        var params = {
            destinationType: Camera.DestinationType.DATA_URL
        };

        if (!sourceType) {
            params.sourceType = Camera.PictureSourceType.CAMERA;
        } else {
            params.sourceType = Camera.PictureSourceType[sourceType.toUpperCase()];
        }
        params.allowEdit = Boolean(allowEdit);
        if (quality !== undefined && quality !== null) params.quality = quality;

        var d = new dojo.Deferred();
        if (window["PhoneGap"]) {
            navigator.camera.getPicture(
            dojo.hitch(this,
                function(imageData) {
                    d.callback({
                        dataValue: "data:image/jpeg;base64," + imageData
                    });
                }),
                dojo.hitch(this, function(inError) {
                    this.handleCaptureError(inError.code, d);
                }),
                params
            );
        }
        return d;
    },
/* this version uses the PhoneGap device capture API, which does not constrain the size of the picture, and causes out of memory errors on android
    capture_picture: function(times) {
    var d = new dojo.Deferred();
    if (window["PhoneGap"]) {
        navigator.device.capture.captureImage(
        dojo.hitch(this, function(inResult) {
            console.log("Image Capture Success");
            var filePath = inResult[0].fullPath;
            var name = inResult[0].name;
            this.readDataUrl(filePath, d);
        }),
        dojo.hitch(this, function(inError) {
            this.handleCaptureError(inError.code, d);
        }),
        {limit: 1});
    }
    return d;
    },
    */
    handleCaptureError: function(inErrorCode, d) {
        switch (inErrorCode) {
            case 20:
                d.errback("CAPTURE_NOT_SUPPORTED");
                break;
            case 0:
                d.errback("CAPTURE_INTERNAL_ERR");
                break;
            case 1:
                d.errback("CAPTURE_APPLICATION_BUSY");
                break;
            case 2:
                d.errback("CAPTURE_INVALID_ARGUMENT");
                break;
            case 3:
                d.errback("CAPTURE_NO_MEDIA_FILES");
                break;
            default:
                d.errback(inErrorCode);
        }
    },
    readDataUrl: function(file, deferred) {
        app.showLoadingDialog("Processing...");

        var reader = new FileReader();
        reader.onload = function(evt) {
            //alert("File Length: " + evt.target.result.length);
            app.hideLoadingDialog();
            deferred.callback({
                dataValue: evt.target.result
            });
        };
        reader.onabort = reader.onerror = function(evt) {
            console.error("Reader Error:" + evt);
            app.hideLoadingDialog();
            deferred.errback(evt);
        }
        reader.readAsDataURL(file);
    },
    notification_beep: function(times) {
        var d = new dojo.Deferred();
        d.callback();
        if (window["PhoneGap"]) {
            navigator.notification.beep(times || 1);
        }
        return d;
    },
    notification_vibrate: function(miliseconds) {
        var d = new dojo.Deferred();
        d.callback();
        if (window["PhoneGap"]) {
            navigator.notification.vibrate(miliseconds || 100);
        }
        return d;
    },
    contacts_delete: function(id) {
        var d = new dojo.Deferred();
        if (window["PhoneGap"]) {
            var contact = navigator.contacts.create();
            contact.id = id;
            //alert("DELETE " + id);
            contact.remove(
                function(inResult) {
                    //alert("DELETE SUCCESS");
                    d.callback(inResult);
                },
                function(inError) {
                    console.error("ERROR: " + inError);
                    d.errback(inError);
                }
            );
        }
        return d;
    },
    contacts_save: function(inContact) {
        var d = new dojo.Deferred();
        if (window["PhoneGap"]) {
            var contact = navigator.contacts.create();
            for (var prop in inContact) {
                if (typeof inContact[prop] != "object") {
                    contact[prop] = inContact[prop];
                }
            }
            contact.name = new ContactName();
            for (var prop in inContact.name) {
                contact.name[prop] = inContact.name[prop];
            }

            contact.addresses = [];
            dojo.forEach(inContact.address, function(inAddress) {
                var a = new ContactAddress();
                for (var prop in inAddress) {
                    a[prop] = inAddress[prop];
                }
                contact.addresses.push(a);
            });

            contact.phoneNumbers = [];
            dojo.forEach(inContact.phoneNumbers, function(inPhone) {
                var a = new ContactField(inPhone.name, inPhone.dataValue, false);
                contact.phoneNumbers.push(a);
            });

            contact.emails = [];
            dojo.forEach(inContact.emails, function(inPhone) {
                var a = new ContactField(inPhone.name, inPhone.dataValue, false);
                contact.emails.push(a);
            });


            contact.urls = [];
            dojo.forEach(inContact.urls, function(inPhone) {
                var a = new ContactField(inPhone.name, inPhone.dataValue, false);
                contact.urls.push(a);
            });


            contact.organization = new ContactOrganization();
            for (var prop in inContact.organization) {
                contact.organization[prop] = inContact.organization[prop];
            }

            contact.rawId = Number(contact.id);
            contact.save(
                function(inResult) {
                    //alert("Save Success");
                    d.callback(inResult);
                },
                function(inError) {
                    console.error("ERROR: " + inError);
                    d.errback(inError);
                }
            );
        }
        return d;
    },
    contacts_read: function(filter) {
        var d = new dojo.Deferred();
        if (window["PhoneGap"]) {
            var options = new ContactFindOptions();
            if (filter != undefined && filter !== "") options.filter = filter;
            options.multiple = true;

            var fields = ["displayName", "name", "nickname", "phoneNumbers", "emails", "addresses", "ims", "organizations", "birthday", "note", "photos", "categories", "urls"];
            navigator.contacts.find(fields,
                function(inResult) {
                    var normalize = function(inItems) {
                            var result = [];
                            if (inItems) {
                                dojo.forEach(inItems, function(item) {
                                    result.push({
                                        name: item.type,
                                        dataValue: item.value
                                    });
                                });
                            }
                            return result;
                        }

                    for (var i = 0; i < inResult.length; i++) {
                        try {
                            inResult[i].phoneNumbers = normalize(inResult[i].phoneNumbers);
                            inResult[i].emails = normalize(inResult[i].emails);
                            inResult[i].urls = normalize(inResult[i].urls);
                            inResult[i].birthday = Number(inResult[i].birthday);
                            inResult[i].id = Number(inResult[i].id);
                        } catch (e) {
                            console.error(e);
                            console.log(inResult[i]);
                        }
                        //inResult[i].categories = normalize(inResult[i].categories);
                        //inResult[i].photos = normalize(inResult[i].photos);
                    }
                    d.callback(inResult);
                },
                function(inError) {
                    console.error("ERROR: " + inError);
                    d.errback(inError);
                },
                options
            );

        }
        return d;
    }

});

wm.services.add({name: "phoneGapService", ctor: "wm.PhoneGapService", isClientService: true, clientHide: true});
wm.typeManager.addType("phonegap.Contact", {internal: false,
                        fields: {
                        id: {type: "number", order: 1,
                             "exclude": ["insert"],
                             "include": ["delete", "read", "update"],
                             "noChange": ["delete", "read", "update"],
                             required: true
                            },
                        //displayName: {type: "string", order: 2}, a return field but not a writable field
                        name:  {type: "phonegap.ContactName", required: true},
                        nickname:  {type: "string", order: 4},
                        phoneNumbers: {type: "EntryData", isList: true, order: 5},
                        emails:  {type: "EntryData", isList: true, order: 6, hidden: true},
                        addresses: {type: "phonegap.Address", isList: true, order: 7, hidden: true},
                        ims: {type: "EntryData", isList: true, order: 8, hidden: true},
                        organizations: {type: "phonegap.ContactOrganization", isList: true, order: 9, hidden: true},
                        birthday: {type: "java.util.Date", order: 10},
                        note: {type: "string", order: 11},
                        photos: {type: "StringData", isList: true, order: 12, hidden: true},
                        categories: {type: "StringData", isList: true, order: 13, hidden: true},
                        urls: {type: "EntryData", isList: true, order:14, hidden: true}
                        }
                       });
// http://docs.phonegap.com/en/1.4.0/phonegap_contacts_contacts.md.html#ContactAddress
wm.typeManager.addType("phonegap.Address", {internal: false,
                        fields: {
                        pref: {type: "boolean", order: 1},
                        type: {type: "string", order: 2},
                        formatter: {type: "string", order: 3},
                        streetAddress: {type: "string", order: 4},
                        locality: {type: "string", order: 5},
                        region: {type: "string", order: 6},
                        postalCode: {type: "string", order: 7},
                        country: {type: "string", order: 8}
                        }
                       });

// http://docs.phonegap.com/en/1.4.0/phonegap_contacts_contacts.md.html#ContactOrganization
wm.typeManager.addType("phonegap.ContactOrganization", {internal: false,
                             fields: {
                                 pref: {type: "boolean", order: 1},
                                 type: {type: "string", order: 2},
                                 name: {type: "string", order: 3},
                                 department: {type: "string", order: 4},
                                 title: {type: "string", order: 5}
                             }
                            });


// http://docs.phonegap.com/en/1.4.0/phonegap_contacts_contacts.md.html#ContactName
wm.typeManager.addType("phonegap.ContactName", {internal: false,
                         fields: {
                             formatted: {type: "string", order: 1},
                             familyName: {type: "string", order: 2},
                             givenName: {type: "string", order: 3},
                             middleName: {type: "string", order: 4},
                             honorificPrefix: {type: "string", order: 5},
                             honorificSuffix: {type: "string", order: 6}
                         }
                        });

// http://docs.phonegap.com/en/1.4.1/phonegap_geolocation_geolocation.md.html#Coordinates
wm.typeManager.addType("phonegap.Coordinates", {internal: false,
                         fields: {
                        latitude: {type: "number", order: 1},
                        longitude: {type: "number", order: 2},
                        altitude: {type: "number", order: 3},
                        accuracy: {type: "number", order: 4},
                        altitudeAccuracy: {type: "number", order: 5},
                         heading: {type: "number", order: 6},
                         speed: {type: "number", order: 7}
                        }
                       });



dojo.declare("wm.PhoneGapCall", [wm.ServiceVariable], {
    _deviceReady: false,
    service: "phoneGapService",
    operation: "contacts_read",
    postInit: function() {
        this.inherited(arguments);
        document.addEventListener("deviceready", dojo.hitch(this, "_onDeviceReady"), false);
    },
    _onDeviceReady: function() {
        this._deviceReady = true;
        if (this.autoUpdate || this.startUpdate) this.update();
    },
    update: function() {
        if (this._deviceReady) return this.inherited(arguments);
    },
    updateInternal: function() {
        if (this._deviceReady) return this.inherited(arguments);
    }
});

wm.Object.extendSchema(wm.PhoneGapCall,{
    owner: { group: "common", order: 1, readonly: true, options: ["Page", "Application"]},
    service: {ignore: 1, writeonly: 1},
    operation: { group: "data", order: 1},
    updateNow: { ignore: 1},
    queue: {ignore:1},
    clearInput: { group: "operation", operation:1, order: 30},
    input: {group: "data", order: 3, putWiresInSubcomponent: "input", bindTarget: 1, treeBindField: true, editor: "wm.prop.NavigationGroupEditor"}
});


}

if(!dojo._hasResource["wm.base.components.XhrService"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.components.XhrService"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide("wm.base.components.XhrService");


dojo.declare("wm.XhrService", wm.Service, {
    noInspector: true,
    /** @lends wm.PhoneGapService.prototype */
    operation: "",

    /* Static variable shared by all XhrServices */
    _operations: {
        basicRequest: {
            parameters: {
                url: { type: "string" },
                headers: {type: "EntryData", isList: 1},
                requestType: {type: "string"},
                contentType: {type: "string"},
                useProxy: {type: "boolean"}, /* Not yet handled */
                parameters: {type: "EntryData", isList: true} // List of name/value pairs

            },
            returnType: "string" // provide additional operations using some custom tooling in order to get typed return values, and typed parameter lists
        }
    },
    invoke: function(inMethod, inArgs, inOwner) {
        var op = this._operations[inMethod];
        var parameters, requestType, headers, url, contentType, useProxy;
        if (!op) return;
        if (op == this._operations.basicRequest) {
            url = inArgs[0];
            headers = inArgs[1];
            requestType = inArgs[2] || "GET";
             contentType = inArgs[3] || "application/x-www-form-urlencoded";
            useProxy = inArgs[4] === undefined ? true : inArgs[4];
            parameters = inArgs[5];

            var headersHash = {};
            dojo.forEach(headers, function(header) {
                headersHash[header.name] = header.dataValue;
            });

            var parametersHash = {};
            dojo.forEach(parameters, function(p) {
                parametersHash[p.name] = p.dataValue;
            });


            return this._invokeBasicRequest(url, headersHash, requestType, contentType, useProxy, parametersHash, "string", inOwner);
        } else {
            var allParameterDef = op.allParameters || op.parameters;

            /* Turn inArgs (array of parameters) into a hash of name/value pairs so that we know what name each argument is associated with */
            parameters = {};
            var i = 0;
            /* Only iterate over public parameters, not hidden ones; inArgs will only contain the public ones */
            wm.forEachProperty(op.parameters, function(parameterObj, parameterName) {
                parameters[parameterName] = inArgs[i];
                i++;
            });
            url = op.url;
            url = url.replace(/\$\{.*?\}/g, function() {
                var input = arguments[0];
                input = input.substring(2,input.length-1);
                var value = parameters[input];
                if (value === undefined || value === null) {
                    value = allParameterDef[input].defaultValue;
                }
                if (value === undefined || value === null) value = "";
                return value;
            });


            if (op.requestType !== undefined) {
                requestType = op.requestType;
            } else if (parameters.requestType) {
                requestType = parameters.requestType;
                delete parameters.requestType;
            } else {
                requestType = "GET";
            }

            if (op.contentType) {
                contentType = op.contentType;
            } else if (parameters.contentType) {
                contentType = parameters.contentType;
                delete parameters.contentType;
            } else {
                contentType = "application/x-www-form-urlencoded";
            }

            if (op.useProxy !== undefined) {
                useProxy = op.useProxy;
            } else {
                useProxy = parameters.useProxy;
                delete parameters.useProxy;
            }
            headers = {};
            var inputs = {};
            wm.forEachProperty(allParameterDef, function(parameterDef, parameterName) {
                var value = parameters[parameterName];
                if (value === null || value === undefined) {
                    value = parameterDef.defaultValue;
                    if (value === null || value === undefined) value = "";
                }
                if (parameterDef.transmitType == "header") {
                    headers[parameterName] = value;
                } else if (parameterDef.transmitType == "queryString") {
                    /* noEscape is something we can only control for GET no POST; dojo will escape the post request anyways, and we don't want
                    * to escape it and then have dojo escape it again
                    */
                    inputs[parameterName] = typeof value == "string" && !parameterDef.noEscape && requestType === "GET" ? escape(value) : value;
                }
                // ignore transmitType == "path" which is handled in the url.replace call above
            });
            return this._invokeBasicRequest(url, headers, requestType, contentType, useProxy, inputs, op.returnType, op, inOwner);
        }
    },
    _invokeBasicRequest: function(url, headers, requestType, contentType, useProxy, parameters, returnType, op, inOwner) {
        var d = new dojo.Deferred();

        if (wm.useProxyJsonServices !== undefined) {
            useProxy = wm.useProxyJsonServices;
        }


        /* Turn the headers array into a headers hash */

        requestType = requestType.toUpperCase();

        var content;
        switch (contentType) {
        case "application/json":
            content = useProxy ? dojo.toJson(parameters) : parameters;
            break;
        case "application/x-www-form-urlencoded":
            if (!useProxy) {
                content = parameters;
            } else {
                content = "";
                wm.forEachProperty(parameters, function(value, key) {
                    if (content) content += "&";
                    content += escape(key) + "=" + escape(value);
                });
            }
            break;
        }

        /* Use the remoteRESTCall Proxy service */
        if (useProxy) {
            if (this.jsonRpcService && !this.jsonRpcService._service) {
                this.jsonRpcService.destroy();
                delete this.jsonRpcService;
            }
            if (!this.jsonRpcService) {
                this.jsonRpcService = new wm.JsonRpcService({
                    owner: inOwner,
                    service: "waveMakerService"
                });
                this.defaultHeaders = dojo.clone(this.jsonRpcService._service.requestHeaders);
            }
            this.jsonRpcService._service.requestHeaders = dojo.mixin(headers, this.defaultHeaders);
            var dInternal = this.jsonRpcService.requestAsync("remoteRESTCall", [url, content, requestType, contentType]);
        }

        /* No proxy needed, send the call directly */
        else {
            var xhrArgs = {
                headers: headers,
                handleAs: "text",
                contentType: contentType,
                url: url
            };
            if (requestType == "GET") {
                var query = "";
                wm.forEachProperty(parameters, function(value, name) {
                    if (value !== null && value !== undefined) {
                        if (query) query += "&";
                        query += name + "=" + value;
                    }
                });
                if (query && url.match(/\?/)) {
                    url += "&" + query;
                } else {
                    url += "?" + query;
                }
                xhrArgs.url = url;
            } else {
                xhrArgs.postData = dojo.toJson(parameters);
            }
            var dInternal = this._deferred = dojo.xhr(requestType, xhrArgs);
        }

        dInternal.addCallbacks(dojo.hitch(this, "onResult", parameters, op, d), dojo.hitch(this, "onError", parameters, op, d));
        return d;
    },
    onResult: function(parameters, operation, deferred, inResult) {
        var result;
        try {
            if (inResult && inResult.match(/^\s*[\{\[]/)) {
                result = dojo.fromJson(inResult);
            } else {
                result = {dataValue: inResult};
            }
        } catch (e) {
            result = inResult;
        }
        deferred.callback(result);
    },
    onError: function(parameters, operation, deferred, inError) {
        deferred.errback(inError);
    },


    /* {name: operationName, -- Required
     *  url: operationUrl,   -- Required
     *  type: "GET",         -- If not specified, will be an input as with basicRequest
     *  headers: {name/value pair} -- use this to specify headers that never vary, stuff like contentType that we haven't baked in
     *  useProxy: true/false, -- If undefined, will be an input as with basicRequest
     *  parameters: standard parameters object for an operation specifying what parameters should be visible to the developer
     *  returnType: "EntryData" -- If unspecified, is set to "string"
     * }
     */
    addOperation: function(inOperation) {

        /* If the useProxy doesn't have a value, let the user set it */
        if (inOperation.useProxy === undefined) {
            inOperation.parameters.useProxy = this._operations.basicRequest.parameters.useProxy;
        }

        /* If there is no returnType specified, then the user will have to set it. This should really be set */
        if (!inOperation.returnType) {
            inOperation.returnType = "string";
        }

        /* If no contentType specified, then the user can set this.  This should really be set */
        if (!inOperation.contentType) {
            inOperation.contentType = "application/x-www-form-urlencoded"; // TODO: find the right name for this
        }
        this._operations[inOperation.name] = inOperation;
    },
    removeOperation: function(operationName) {
        delete this._operations[operationName];
    }
});

wm.services.add({name: "xhrService", ctor: "wm.XhrService", isClientService: true, clientHide: false});



dojo.declare("wm.XhrDefinition", wm.Component, {
    noInspector: true,
    url: "",
    requestType: "GET",
    headers: null,
    useProxy: true,
    parameters: null,
    returnType: "string",
    contentType: "application/x-www-form-urlencoded",

    postInit: function() {
       this.inherited(arguments);
       this.initType();
   },
   destroy: function() {
           wm.XhrService.prototype.removeOperation(this.name);
           this.inherited(arguments);
   },
   initType: function() {
       if (this.url) {
            var publicParameters = dojo.clone(this.parameters);
            wm.forEachProperty(publicParameters, function(inValue, inName) {
                if (inValue.hidden) delete publicParameters[inName];
            });
           wm.XhrService.prototype.addOperation({
               name: this.name,
               url: this.url,
               requestType: this.requestType,
               headers: this.headers,
               parameters: publicParameters,
               allParameters: this.parameters,
               useProxy: this.useProxy,
               contentType: this.contentType,
               returnType: this.returnType
           });
       }
   },
   designSelect: function() {
       var d = studio.navGotoEditor("XHRServiceEditor", studio.webServiceTab, this.name + "Layer", this.name);
       /*
    var d = studio.xhrDesignerDialog || new wm.PageDialog({owner: studio,
                                   _classes: {domNode: ["studiodialog"]},
                                   name: "xhrDesignerDialog",
                                   modal: false,
                                   hideControls: true,
                                   pageName: "XHRServiceEditor",
                                   width: "800px",
                                   height: "800px",
                                   title: "XHR Service Editor"});
    d.show();
    */
       d.page.setService(this);
   }
});

wm.Object.extendSchema(wm.XhrDefinition, {
    returnType: {type: "string"},
    url: {type: "string"},
    useProxy: {type: "boolean"},
    requestType: {type: "string"},
    contentType: {type: "string"},
    parameters: {type: "any"},
    headers: {type: "any"}
});

}

if(!dojo._hasResource["dojox.uuid.generateRandomUuid"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.uuid.generateRandomUuid"] = true;
dojo.provide("dojox.uuid.generateRandomUuid");

dojox.uuid.generateRandomUuid = function(){
	// summary:
	//		This function generates random UUIDs, meaning "version 4" UUIDs.
	// description:
	//		A typical generated value would be something like this:
	//		"3b12f1df-5232-4804-897e-917bf397618a"
	//
	//		For more information about random UUIDs, see sections 4.4 and
	//		4.5 of RFC 4122: http://tools.ietf.org/html/rfc4122#section-4.4
	//
	//		This generator function is designed to be small and fast,
	//		but not necessarily good.
	//
	//		Small: This generator has a small footprint. Once comments are
	//		stripped, it's only about 25 lines of code, and it doesn't
	//		dojo.require() any other modules.
	//
	//		Fast: This generator can generate lots of new UUIDs fairly quickly
	//		(at least, more quickly than the other dojo UUID generators).
	//
	//		Not necessarily good: We use Math.random() as our source
	//		of randomness, which may or may not provide much randomness.
	// examples:
	//		var string = dojox.uuid.generateRandomUuid();
	var HEX_RADIX = 16;

	function _generateRandomEightCharacterHexString(){
		// Make random32bitNumber be a randomly generated floating point number
		// between 0 and (4,294,967,296 - 1), inclusive.
		var random32bitNumber = Math.floor( (Math.random() % 1) * Math.pow(2, 32) );
		var eightCharacterHexString = random32bitNumber.toString(HEX_RADIX);
		while(eightCharacterHexString.length < 8){
			eightCharacterHexString = "0" + eightCharacterHexString;
		}
		return eightCharacterHexString; // for example: "3B12F1DF"
	}

	var hyphen = "-";
	var versionCodeForRandomlyGeneratedUuids = "4"; // 8 == binary2hex("0100")
	var variantCodeForDCEUuids = "8"; // 8 == binary2hex("1000")
	var a = _generateRandomEightCharacterHexString();
	var b = _generateRandomEightCharacterHexString();
	b = b.substring(0, 4) + hyphen + versionCodeForRandomlyGeneratedUuids + b.substring(5, 8);
	var c = _generateRandomEightCharacterHexString();
	c = variantCodeForDCEUuids + c.substring(1, 4) + hyphen + c.substring(4, 8);
	var d = _generateRandomEightCharacterHexString();
	var returnValue = a + hyphen + b + hyphen + c + d;
	returnValue = returnValue.toLowerCase();
	return returnValue; // String
};

}

if(!dojo._hasResource["wm.base.components.JsonRpcService"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.components.JsonRpcService"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide("wm.base.components.JsonRpcService");




dojo.rpc.JsonService.extend({
	lastSubmissionId: Math.floor(Math.random(new Date().getTime()) * 1000000)
});


wm.inflight = {
    _inflight: [],
    _inflightNames: [],
    getCount: function() {
        return this._inflight.length;
    },
    change: function() {},
    // inName: this.service,
    // this.name, inArgs, inMethod, invoker);
    add: function(inDeferred, inName, optName, inArgs, inMethod, invoker) {
        inDeferred._timeStamp = new Date().getTime();
        if (dojo.indexOf(this._inflight, inDeferred) != -1) return;
        this._inflight.push(inDeferred);

        var name;
        if (inName != "runtimeService") {
            name = inName + "." + inMethod;
        } else if (optName) {
            name = optName + "." + inMethod;
        } else if (inArgs[0]) {
            name = inArgs[0] + ": " + inArgs[1];
        } else {
            name = "LazyLoad: " + inArgs[1];
        }


        this._inflightNames.push(name);
        inDeferred.addBoth(dojo.hitch(this, "remove", inDeferred));
        this.change();
    },
    remove: function(inDeferred, inResult) {
        var i = dojo.indexOf(this._inflight, inDeferred);
        if (i == -1) return;
        var delta = new Date().getTime() - inDeferred._timeStamp;
        //console.info("deferred inflight for ", delta + "ms", inDeferred);
        this._inflight.splice(i, 1);
        this._inflightNames.splice(i, 1);
        this.change();
        return inResult;
    },
    cancel: function() {
        dojo.forEach(this._inflight, function(d) {
            if (!d.canceller) d.canceller = function() {};
            d.cancel();
        });
    }
}

dojo.subscribe("wm-unload-app", wm.inflight, "cancel");

dojo.declare("wm.JsonRpc", dojo.rpc.JsonService, {
    smd: null,
    required: false,
    sync: false,
    _designTime: false,
    requestHeaders: {},
    bind: function(method, parameters, deferredRequestHandler, url){
        //console.log("method", method, "parameters", parameters || [], "url", url || this.serviceUrl);
        url = url || this.serviceUrl;

        //if a query is running for salesforceService, the query service must be provided by the customer application,
        //not from Studio.
        if (method == "runQuery" && parameters[0] == SALESFORCE_SERVICE) {
            url = wm.services.getService(SALESFORCE_SERVICE)._service.serviceUrl;
        }
        if (!url)
            return;
            var requestHeaders = this._requestHeaders || this.requestHeaders;
        var props = {
            url: url||this.serviceUrl,
            postData: this.createRequest(method, parameters || []),
            contentType: this.contentType,
            timeout: this.timeout,
            handleAs: "json",
            sync: this.sync,
            headers: requestHeaders
        }

            if (this._requestHeaders) delete this._requestHeaders; // these headers are for this request only
            if (this._designTime && studio.isCloud()) {
            var postData = props.postData;
            props.postData = this.createRequest("remoteRESTCall", [props.url.replace(/^.*\//, studio._deployedUrl + "/"), postData, "POST", "application/json"]);
            //props.postData = dojo.toJson({"params": [props.url.replace(/^.*\//, studio._deployedUrl + "/"), dojo.toJson(postData)], "method": "remoteRESTCall", "id":1});
            props.url = "waveMakerService.json";
        }

        if (wm.xhrPath) {
        props.url = wm.xhrPath + props.url;
        }
        var def = dojo.rawXhrPost(props);
        if (this._designTime && studio.isCloud()) {
        var newdef = new dojo.Deferred();
        def.addCallbacks(
            function(inResult) {
            newdef.callback(dojo.fromJson(inResult.result));
            },
            function(inError) {
            newdef.errback(inError);
            });
        def = newdef; // return the new deferred, which only notifies after we've decoded the data
        }
        deferredRequestHandler = dojo.mixin(deferredRequestHandler, def.ioArgs);

        def.addCallbacks(this.resultCallback(deferredRequestHandler), this.errorCallback(deferredRequestHandler));
    },
    // override dojo default, we want full result object, not just {result: ...}
    parseResults: function(obj){
        return obj;
    },
    addRequestHeader: function(headerName, headerValue) {
    if (!this.requestHeaders) this.requestHeaders = {};

    /* Temporary request header object */
    if (!this._requestHeaders) {
        this._requestHeaders = dojo.clone(this.requestHeaders);
    }
    this._requestHeaders[headerName] = headerValue;
    },
    setRequestHeaders: function(reqHeaders) {
        this._requestHeaders = reqHeaders;
    },

    /* Override parent method which passes data.message and therefore loses the fact that its actually an instance of Error */
errorCallback: function(/* dojo.Deferred */ deferredRequestHandler){
        // summary:
        //      create callback that calls the Deferres errback method
        //  deferredRequestHandler: Deferred
        //      The deferred object handling a request.
        return function(data){
            deferredRequestHandler.errback(data);
        };
    }
});

dojo.declare("wm.JsonRpcService", wm.Service, {
    operations: "",
    ready: false,
    service: "",
    // 0 indicates no timeout.
    timeout: 0,
    errorLevel: 10,
    sync: false,
    url: "",
    _methods: [],
    _operations: {},
    _service: null,
    init: function() {
        //dojo.mixin(this.readonlyProps, { methods: 1, ready: 1 });
        this.inherited(arguments);
        this.initService();
    },
    setSync: function(inSync) {
        this.sync = inSync;
    },
    getServiceRoot: function() {
        return this.getPath() + "services/";
    },
    getJsonPath: function() {
        var p = '';
        // this window.studio test is needed for the login page to run when not in debug mode
        if(this.isDesignLoaded() && window.studio && studio.project) {
            p = '/' + studio.project.getProjectPath() + '/';
        }
        return p;
    },
    // FIXME: we're making a new service object for every rpc service.
    // This is unnecessary and one side effect is that the smd is re-requested for each rpc service
    // at the least we could cache this smd data to avoid re-retrieving it.
    // it seems unnecessary to have more than one JsonRpc per service
    // and it may be unnecessary to have more than one JsonRpcService (ever) per service
    // JsonRpcService has a few properties that make collapsing the number of them non-trivial (e.g. sync, timeout)
    initService: function() {
    var n = this.service || this.name;
    var rand = this.owner && this.isDesignLoaded() && studio.application ? studio.application.getFullVersionNumber() : (app && !window["studio"] ? app.getFullVersionNumber() : new Date().getTime());
    var cachedName = this.url || n + ".smd";
    var url = this.url || (n && (this.getServiceRoot() + n + ".smd"));
/* Don't do this; xhrpath is used in phonegap apps; all smd files reside locally on device
    if(wm.xhrPath){
        url=wm.xhrPath+url;
    }*/
    this._service = null;
    if (url) {
        try{
        /* SMD files change at design time, never use a cached SMD file at design time */
        if (window["studio"]) {
            this._service = new wm.JsonRpc(url + "?rand=" + rand);
        } else if (wm.JsonRpcService.smdCache[url]) {
            this._service = wm.JsonRpcService.smdCache[url];
        } else if (wm.JsonRpcService.smdCache[cachedName]) {
            var cachedStruct = wm.JsonRpcService.smdCache[cachedName];
            this._service = new wm.JsonRpc({methods: cachedStruct.methods,
                            serviceType: cachedStruct.serviceType,
                            serviceUrl: url.replace(/\.smd/,".json")});
        } else {
            var randomParam = window["PhoneGap"] ? "" : "?rand=" + rand
            this._service = new wm.JsonRpc(url + randomParam);
            this._service.serviceUrl = "services/" + this._service.serviceUrl;
        }
        wm.JsonRpcService.smdCache[url] = this._service;
            //The following lines are not being used now.  They may be used in the future to differenciate requests from Studio from
            //requests deployed application.
            if (this._designTime)
            this._service._designTime = true;

            this._service.timeout = this.timeout;
            this.ready = Boolean(this._service && this._service.smd);
            if (this.ready) {
            this._service.serviceUrl = this.getJsonPath() + this._service.serviceUrl;
            this.listOperations();
            }
        }catch(e){
        console.debug(e);
        }
    }
    },
    setName: function(inName) {
        this.inherited(arguments);
        if (!this.url)
            this.initService();
    },
    ensureArgs: function(inMethod, inArgs) {
        if (inMethod in this._operations && dojo.isArray(inArgs)) {
            var op = this._operations[inMethod], argCount=0;
            if (op) {
                for (var o in op.parameters)
                    argCount++;
                for (var i=inArgs.length; i<argCount; i++)
                    inArgs.push(null);
            }
        }
    },
    invoke: function(inMethod, inArgs, owner, invoker) {
        this.invoke(inMethod, inArgs, owner, invoker, false, false, null);
    },
    invoke: function(inMethod, inArgs, owner, invoker, inLoop, inLongDeferred, requestId) {
        if (!this._service)
            return null;
        this._service.sync = this.sync;
        this.ensureArgs(inMethod, inArgs);
        //if (wm.logging)
            this.debugLastMethod = inMethod;

        this.result = null;
        this.error = null;

        var d;
        this._service._designTime = this._isDesignLoaded;
        if (wm.connectionTimeout > 0 ) {
            if (inLoop) {
                this._service.addRequestHeader("wm-polling-request", requestId);
            } else {
                requestId = dojox.uuid.generateRandomUuid();
                this._service.addRequestHeader("wm-initial-request", requestId);
            }

            d = this._service.callRemote(inMethod, inArgs || []);

            var longDeferred = inLongDeferred || new dojo.Deferred();
            d.addCallbacks(dojo.hitch(this, "onLongResponseTimeResult", inMethod, inArgs, owner, invoker, inLoop, requestId, longDeferred, d),
                dojo.hitch(this, "onLongResponseTimeError", inMethod, inArgs, owner, invoker, inLoop, requestId, longDeferred, d));
            d = longDeferred;
        } else {
            d = this._service.callRemote(inMethod, inArgs || []);
            d.addCallbacks(dojo.hitch(this, "onResult"), dojo.hitch(this, "onError"));
        }
        if (invoker && app.debugDialog) invoker._jsonRpcServiceDeferred = d;
        wm.inflight.add(d, this.service, this.name, inArgs, inMethod, invoker);
        this.inflight = true;
        return d;
    },
    request: function(inMethod, inArgs, inResult, inError, invoker) {
        var d = this.invoke(inMethod, inArgs, null, invoker);
        if (inResult) {
            if (dojo.isFunction(inResult))
                d.addCallback(inResult);
            else
                d.addCallback(this.owner, inResult);
        }
        if (inError) {
            if (dojo.isFunction(inError))
                d.addErrback(inError);
            else
                d.addErrback(this.owner, inError);
        }
        return d;
    },
    // force a sync call, irrespective of our sync setting
    requestSync: function(inMethod, inArgs, inResult, inError, invoker) {
        var s = this.sync;
        this.sync = true;
            var d = this.request.apply(this, [inMethod, inArgs, inResult, inError, null, invoker]);
        this.sync = s;
        return d;
    },
    // force an async call, irrespective of our sync setting
        requestAsync: function(inMethod, inArgs, inResult, inError, invoker) {
        var s = this.sync;
        this.sync = false;
        var
            cb = inResult ? dojo.hitch(this, function() {
                this.sync = s;
                return inResult.apply(this, dojo._toArray(arguments));
            }) : null,
            eb = inError ? dojo.hitch(this, function() {
                this.sync = s;
                return inError.apply(this, dojo._toArray(arguments));
            }) : null;
             return this.request(inMethod, inArgs, cb, eb, null, invoker);
    },
    getResultSync: function(inMethod, inArgs) {
        var d = this.requestSync(inMethod, inArgs);
        return d.results[0];
    },
    onLongResponseTimeResult: function(inMethod, inArgs, owner, invoker, inLoop, requestId, longDeferred, deferred, inResult) {
        var r;
        this.inflight = false;
        var callInvoke = false;
        if (inLoop) {
                var processStatus = deferred.xhr.getResponseHeader("wm-json-response-status");
            if (processStatus == "processing") {
                callInvoke = true;
            } else if (processStatus == "error") {
                return this.onLongResponseTimeError(inMethod, inArgs, owner, invoker, inLoop, requestId, longDeferred, inResult.result);
            } else if (processStatus == "done") {
                r = this.fullResult = inResult;
                this.result = (r || 0).result;
                longDeferred.callback(this.result);
            } else {
                callInvoke = true;
            }
            if (callInvoke) {
                wm.onidle(this, function() {
                    this.invoke(inMethod, inArgs, owner, invoker, true, longDeferred, requestId);
                });
            }
        } else {

            longDeferred.callback(this.onResult(inResult));
        }
    },
    onLongResponseTimeError: function(inMethod, inArgs, owner, invoker, inLoop, requestId, longDeferred, deferred, inError) {
         // happens with livelayout requests from studio
        if (!deferred.xhr) {
            longDeferred.errback(inError);
           return;
        }
        if ((deferred.xhr.status == 504) || (deferred.xhr.status == 502 &&
                deferred.xhr.getResponseHeader("X-Squid-Error") === "ERR_ZERO_SIZE_OBJECT 0" )) {
            this.invoke(inMethod, inArgs, owner, invoker, true, longDeferred, requestId);
        } else {
            longDeferred.errback(this.onError(inError));
        }
    },

    onResult: function(inResult) {
        this.inflight = false;
        var r = this.fullResult = inResult;
        this.result = (r || 0).result;
/*
        if (djConfig.isDebug && !dojo.isFF) {
            console.group("Service Call Completed: " + this.name + "." + this.debugLastMethod);
            if (this.result) {
                console.log(this.result);
            } else {
                console.log("Response was null");
            }
            console.groupEnd();
        }
        */
        return this.result;
    },
    onError: function(inError) {
        this.inflight = false;
        var message = inError != null && dojo.isObject(inError) ? inError.message : inError;
        try {
        if (!inError || message.match(/No ServiceWire found/) && !djConfig.isDebug)
            return;
        /* If a headless app sends a request, it may not have wm.connectionTimeout set; this error detects that and fixes it */
        if (message.indexOf("Invalid Long Polling Request:") == 0) {
            var matches = message.match(/Timeout for this server is: (\d+)/);
            wm.connectionTimeout = matches ? Number(matches[1]) : 30;
            return;
        }

        if (console.groupCollapsed)
                console.groupCollapsed("Service Call Failed: " + this.name + "." + this.debugLastMethod);
        else
                console.group("Service Call Failed: " + this.name + "." + this.debugLastMethod);

        if (message)
          console.error(message);
                console.groupEnd();
        var errCodes = message.match(/(\d+)$/);
        var errCode = (errCodes) ? errCodes[0] : "";

        // If the failer is a security access error, AND if its NOT a security error that comes from live view
        // (happens when a project accesses the server while running within studio), then tell the user to log back in.
        // Also don't repeat this alert more than once every 3 minutes (it takes 4 server accesses to open a page, so thats 4 alerts in a row!)
        if (errCode == 403) {
            dojo.publish("session-expiration", []);
            if (app) app._onSessionExpiration();
        }
        } catch(e) {
        if (wm.logging) {
            console.dir(e);
            console.dir(inError);
        }
        }
        this.reportError(inError);
        return this.error = inError;
    },

    reportError: function(inError) {
        var m = dojo.isString(inError) ? inError : (inError.message ? "Error: " + inError.message : "Unspecified Error");
        m = (this.name ? this.name + ": " : "") + m;
        if (this.errorLevel > 5) {
            if (!inError.dojoType == "cancel")
                console.error(m);
        } else if (this.errorLevel > 0)
            wm.logging && console.debug(m);
    },
    paramArrayToHash: function(inParams) {
        var hash = {};
        for (var i=0, p; (p=inParams[i]); i++)
            hash[p.name] = { type: p.type, hidden: p.hidden };
        return hash;
    },
    listOperations: function() {
        this._methods = [];
        this._operations = {};
        var m = (this._service.smd||0).methods || [];
        for (var i=0, op; (op=m[i]); i++){
            this._methods.push(op.name);
            this._operations[op.name] = {
                parameters: this.paramArrayToHash(op.parameters || []),
                returnType: op.returnType || "any",
                operationType: op.operationType || ""
                //responseTime: op.responseTime || ""
            };
        }
        this._methods.sort();
    },
    makePropEdit: function(inName, inValue, inEditorProps) {
        if (inName == "operations")
            return new wm.SelectMenu(dojo.mixin(inEditorProps, {options:this._methods || []}));
        return this.inherited(arguments);
    }
});

wm.Object.extendSchema(wm.JsonRpcService, {
    ready: { ignore: 1 }
});

wm.JsonRpcService.description = "Any JsonRpc service.";
wm.JsonRpcService.smdCache = {};

}

if(!dojo._hasResource["wm.base.components.LiveView"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.components.LiveView"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide("wm.base.components.LiveView");



// View related utitlities
wm.getViewField = function(inTypeSchema, inPropName) {
	if (inTypeSchema) {
		var propInfo = wm.typeManager.getPropertyInfoFromSchema(inTypeSchema, inPropName);
		return {
			caption: wm.capitalize(inPropName.split(".").pop()),
			sortable: true,
			dataIndex: inPropName,
			type: propInfo.type,
			//displayType: wm.getPrimitiveDisplayType(propInfo.type),
			displayType: wm.getDisplayType(propInfo), //xxx
			required: propInfo.required,
			readonly: dojo.indexOf(propInfo.noChange||[], "read") >= 0,
			includeLists: true,
			includeForms: true,
			order: propInfo.fieldOrder,
			subType: propInfo.fieldSubType //xxx
		};
	}
}

wm.getDefaultView = function(inTypeName, inPropertyPath) {
	inPropertyPath = inPropertyPath || "";
	var
		v = [], tm = wm.typeManager,
		schema = tm.getTypeSchema(inTypeName),
		propSchema = inPropertyPath ? tm.getTypeSchema(tm.getPropertyInfoFromSchema(schema, inPropertyPath).type) : schema,
		fields = wm.typeManager.getSimplePropNames(propSchema);
		wm.forEach(fields, function(f) {
			v.push(wm.getViewField(schema, (inPropertyPath ? inPropertyPath + "." : "") + f));
		});

                /* This block adds in related objects that aren't live types: That means it adds in composite keys */
                fields = wm.typeManager.getStructuredPropNames(propSchema);
                wm.forEach(fields, function(field) {
		    var type = propSchema[field].type;
		    var typeDef = wm.typeManager.getType(type);
		    if (typeDef && !typeDef.liveService) {
			v.push(wm.getViewField(schema, (inPropertyPath ? inPropertyPath + "." : "") + field));
			var subfields = wm.typeManager.getSimplePropNames(typeDef.fields);
			wm.forEach(subfields, function(f) {
			    var path = (inPropertyPath ? inPropertyPath + "." : "") + field + "." + f;
			    v.push(wm.getViewField(schema, path));
			});
		    }
		});

	return v;
}

/**
	Component that provides information about live service, datatype,
	related objects, and field information.
	@name wm.LiveView
	@class
	@extends wm.Component
*/
dojo.declare("wm.LiveView", wm.Component, {
	/** @lends wm.LiveView.prototype */
	/** Name of the service on which this view operates. */
	service: "",
	/** Fully qualified data type we operate on. */
	dataType: "",
	/** Fields to fetch */
	related: [],
	/** Fields to display */
	view: [],
	constructor: function() {
		this.related = [];
		this.view = [];
	},
	init: function() {
		this.inherited(arguments);
		this.setDataType(this.dataType);
	},
	loaded: function() {
		this.inherited(arguments);
		this.viewChanged();
	},
	viewChanged: function() {
		dojo.publish(this.getRuntimeId() + "-viewChanged", [this.getId()]);
	},
	createDefaultView: function() {
		this.setFields(this.related || [], wm.getDefaultView(this.dataType));
	},
	getRelatedFields: function(){
		if (!this.related || this.related.length == 0)
			this.related = this.getRequiredRelatedFields();
		return this.related || [];
	},
	getRequiredRelatedFields: function(){
		try
		{
			var ts = [];
			var schema = wm.typeManager.getTypeSchema(this.dataType);
			for (var i in schema) {
				var field = schema[i];
				var isRelatedField = wm.typeManager.isStructuredType(field.type);
				if (isRelatedField && field.required)
				{
					if (field.type == "com.sforce.soap.enterprise.salesforceservice.QueryResultType")
						continue; //xxx
					this.addRelated(i);
					ts.push(i);
				}
			}

			return ts;
		}
		catch(e)
		{
			console.info('error finding required fields.', e);
		}

		return [];
	},
	setFields: function(inRelated, inView) {
		this.related = inRelated;
		this._sortView(inView);
		this.view = inView;
	},
	getFieldIndex: function(inField) {
		var di = dojo.isObject(inField) ? inField.dataIndex : inField;
		for (var i=0, view=this.view, f; f=view[i]; i++)
			if (f.dataIndex == di)
				return i;
		return -1;
	},
	hasField: function(inField) {
		return (this.getFieldIndex(inField) > -1);
	},
	getRelatedIndex: function(inRelated) {
		for (var i=0, related=this.related, r; r=related[i]; i++)
			if (r == inRelated)
				return i;
		return -1;
	},
	hasRelated: function(inRelated) {
		return (this.getRelatedIndex(inRelated) > -1);
	},
	addField: function(inField) {
		var f = inField && wm.getViewField(wm.typeManager.getTypeSchema(this.dataType), inField);
		if (f && !this.hasField(f)) {
			this.view.push(f)
			this._sortView(this.view);
		}
		return f;
	},
	removeField: function(inField) {
		var i = this.getFieldIndex(inField);
		if (i > -1)
			this.view.splice(i, 1);
	},
	addRelated: function(inRelated) {
		if (inRelated && !this.hasRelated(inRelated)) {
			this.related.push(inRelated);
			this.addRelatedDefaultView(inRelated);
		}
	},
	removeRelated: function(inRelated) {
		var i = this.getRelatedIndex(inRelated);
		if (i > -1)
			this.related.splice(i, 1);
	},
	addRelatedDefaultView: function(inRelated) {
		var relatedFields = wm.getDefaultView(this.dataType, inRelated);
		dojo.forEach(relatedFields, function(f) {
			if (!this.hasField(f))
				this.view.push(f);
		}, this);
		this._sortView();
	},

	_sortView: function(inView) {
		if (dojo.isArray(inView)) {
			var t = this.dataType;
			// sort view by order or alpha place property chain
			inView.sort(function(a, b) {
				// if either has order, compare by order
				if (wm.isNumber(a.order) || wm.isNumber(b.order)) {
					return wm.data.compareNumbers(a.order, b.order);
				// otherwise compare by "shallowest" or alpha
				} else {
					a = a.dataIndex;
					b = b.dataIndex;
					var al = a.split(".").length, bl = b.split(".").length;
					return al == bl ? wm.data.compare(a, b) : wm.data.compareNumbers(al, bl);
				}
			});
		}
	},
	_copyView: function(inView) {
		var view = [];
		for (var i=0, v; (v=inView[i]); i++)
			view.push(dojo.mixin({}, v));
		return view;
	},
	getViewById: function(inLiveViewId) {
		if (inLiveViewId instanceof wm.LiveView)
			return inLiveViewId;
		else if (inLiveViewId)
			return this.getRoot().app.getValueById(inLiveViewId);
	},
	copyLiveView: function(inLiveView) {
		var lv = this.getViewById(inLiveView);
		if (lv) {
			this.setService(lv.service);
			this.setDataType(lv.dataType);
			var v = this._copyView(lv.view);
			this.setFields(lv.related, v);
		} else
			this.clearView();
	},
	clearView: function() {
		this.setService("");
		this.setDataType("");
		this.setFields([], []);
	},
	setService: function(inService) {
		this.service = inService;
	},
	//$ Set the dataType for the dataView. This is a type that supports crud operations.
	setDataType: function(inType) {
		var t = this.dataType;
		this.dataType = inType;
		if (t != this.dataType) this.dataTypeChanged();
		if (this._defaultView) this.createDefaultView();

		if (this._isDesignLoaded && this.owner instanceof wm.Variable) {
			var typeInfo = wm.typeManager.getType(this.dataType);
			if (typeInfo) {

				// see if the type has changed to something that invalidates this view
				if (this.view) {
					for (var i = this.view.length - 1; i >= 0; i--) {
						if (this.view[i].dataIndex.indexOf(".") == -1) {
							if (!typeInfo.fields[this.view[i].dataIndex]) {
								wm.Array.removeElementAt(this.view, i);
							}
						}
					}

					/* Sometimes fields are added to a database design; these need to show up in the LiveView or they don't also become available to the DojoGrid columns */
					if (this.owner instanceof wm.LiveVariable) {
						wm.forEachProperty(typeInfo.fields, dojo.hitch(this, function(inFieldDef, inFieldName) {
							if (!wm.typeManager.isStructuredType(inFieldDef.type)) {
								if (!dojo.some(this.view, function(fieldDef) { return fieldDef.dataIndex == inFieldName;})) {
									this.addField(inFieldName);
								}
							}
						}));
					}
				}
			}
		}
	},

	dataTypeChanged: function() {
		// FIXME: we need to do something smart here. changing the datatype should probably zot
		// the view info and may need to inform things bound to this and/or update.
		this.related = [];
		this.view = [];
	},
	hasRelatedProp: function(inRelatedProp) {
		for (var i=0, related=this.related, r; (r=related[i]); i++)
			if (r == inRelatedProp)
				return true;
	},
	getListView: function(inPropPath) {
		var schema = wm.typeManager.getTypeSchema(this.getSubType(inPropPath));
		return dojo.filter(this.getSubView(inPropPath), function(v) {
			return !wm.typeManager.isPropInList(schema, v.dataIndex);
		})
	},
	// get the type of a property path from our dataType
	getSubType: function(inPropPath) {
		if (inPropPath) {
			var schema = wm.typeManager.getTypeSchema(this.dataType);
			return (schema && (wm.typeManager.getPropertyInfoFromSchema(schema, inPropPath) || 0).type) || this.dataType;
		} else
			return this.dataType;
	},
	// get a related list starting at inPropPath
	getSubRelated: function(inPropPath) {
		inPropPath = inPropPath ? inPropPath + "." : "";
		if (inPropPath) {
			var list = [], l = inPropPath.length;
			dojo.forEach(this.related, function(r) {
				if (r.indexOf(inPropPath) == 0)
					list.push(r.substring(l));
			});
			return list;
		}
		else
			return this.related;
	},
	// get a view starting at inPropPath
	getSubView: function(inPropPath) {

	    // update the view if we're designing and the view is managed by a variable
	    if (this._isDesignLoaded && this.owner instanceof wm.Variable && this.view.length == 0)
		this.createDefaultView();

		inPropPath = inPropPath ? inPropPath + "." : "";
		var view = this._copyView(this.view);
		if (inPropPath) {
			var list = [], l = inPropPath.length;
			dojo.forEach(view, function(v) {
				if (v.dataIndex.indexOf(inPropPath) == 0) {
					v.dataIndex = v.dataIndex.substring(l);
					list.push(v);
				}
			});
			return list;
		} else
			return view;
	},

	//check if any picklist(for salesforce for now) exists
	pickListExists: function() { //xxx
		var exists = false;
		if (SALESFORCE_SERVICE == this.service) {
			for (var i=0; i<this.view.length; i++) {
				var e = this.view[i];
				if ("picklist" == e.subType) {
					exists = true;
					break;
				}
			}
		}

		return exists;
	}
});

wm.Object.extendSchema(wm.LiveView, {
	related: { ignore: 1, writeonly: 1 },
	view: { ignore: 1, writeonly: 1 },
	service: { ignore: 1, writeonly: 1 },
	dataType: {ignore: 1, writeonly: 1}
});

}

if(!dojo._hasResource["wm.base.components.LiveVariable"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.components.LiveVariable"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide("wm.base.components.LiveVariable");



/**
	Component that marshalls a LiveView and can perform all data operations: read, insert, update, delete.
	@name wm.LiveVariable
	@class
	@extends wm.ServiceVariable
*/
dojo.declare("wm.LiveVariable", wm.ServiceVariable, {
	/**
		@lends wm.LiveVariable.prototype
	*/
	autoUpdate: true,
	startUpdate: true,
	operation: "read",
	/** First row of results */
	firstRow: 0,
	/** Optional starting source data */
	sourceData: null,
	/** Method by which data is filtered */
	matchMode: "start",
	/** Toggle for data sorting to ignore alphabetical case or not. */
	ignoreCase: false,
	/** Optional order by clause, example "asc: cityId, desc: city" */
	orderBy: "",

	/** LiveView or LiveTable from which this LiveVariable gets its field information; can use a liveView or liveTable */
	liveSource: null,  /* LiveSource is now deprecated; TODO: Hide liveSource unless its an old LIveVar already pointing to an app.liveview */

    refireOnDbChange: false,

	/** Maximum number of results to return */
	maxResults: 500,
	//designMaxResults: 50,
	/** Field in view to use as our root object / type */
	_rootField: "",
	destroy: function() {
		this._unsubscribeLiveView();
		this.inherited(arguments);
	},
	init: function() {
		this.inherited(arguments);
		this.filter = new wm.Variable({name: "filter", owner: this, type: this.type || "any" });
		this.sourceData = new wm.Variable({name: "sourceData", owner: this, type: this.type || "any" });
	    this.setupSubscriptions();
	    // default assumption is that its a list until we have some actual
	    // data to tell us otherwise
	    if (this.isList === undefined && this.operation == "read")
		this.isList = true;
	},
    setupSubscriptions: function() {
		this.subscribe(this.filter.getRuntimeId() + "-changed", this, "filterChanged");
		this.subscribe(this.sourceData.getRuntimeId() + "-changed", this, "sourceDataChanged");
    },
	postInit: function() {
	    this._inLVPostInit = true;
		this.inherited(arguments);
		// initialize via liveSource or optionally directly with a liveView)

	    /* if there is an existing liveView subcomponent, use it*/
	    if (this.$.liveView) {
		this.setLiveView(this.$.liveView);
	    }

	    /* DEPRECATED; if its old style and points to an app.liveView, use that liveview */
	    else if (this.liveSource && this.liveSource != "app") {
		this.setLiveSource(this.liveSource);
	    }

	    /* Else create a new LiveView */
	    else {
		this.setLiveView(this.liveView || this.createLiveView(this.type));
	    }
	    this._inPostInit = true;
	    this.doAutoUpdate();
	    this._inPostInit = false;
	    this._inLVPostInit = false;
	},
	_subscribeLiveView: function() {
		this._unsubscribeLiveView();
		if (this.liveView)
			this._liveViewSubscription = dojo.subscribe(this.liveView.getRuntimeId() + "-viewChanged", dojo.hitch(this, "_liveViewChanged"));
	},
	_unsubscribeLiveView: function() {
		dojo.unsubscribe(this._liveViewSubscription);
		this._liveViewSubscription = null;
	},
        /* Basically, is this a valid type for a LiveVariable; unless type is unset, should return true */
	isLiveType: function() {
		return wm.typeManager.getLiveService(this.type);
	},
	doAutoUpdate: function() {
		if (this.isLiveType())
			this.inherited(arguments);
	},
	filterChanged: function() {
	    if (this.autoUpdate) {
		if (djConfig.isDebug) this.log("autoUpdate");
		this.doAutoUpdate();
		if (djConfig.isDebug) this.endLog("autoUpdate");
	    }
	},
	sourceDataChanged: function() {
	    if (this.autoUpdate) {
		if (djConfig.isDebug) this.log("autoUpdate");
		this.doAutoUpdate();
		if (djConfig.isDebug) this.endLog("autoUpdate");
	    }
	},

	/** Set the filter used for read operations */
	setFilter: function(inFilter) {
		if ((inFilter || 0).type == this.type) {
			this.filter.setDataSet(inFilter);
		}
	},
	/** Set the orderBy property used for read operations */
	setOrderBy: function(inOrderBy) {
		this.orderBy = inOrderBy;
		this.doAutoUpdate();
	},
	/** Set the source data which is used for operations. */
	setSourceData: function(inSourceData) {
		var liveType = this.isLiveType();
	    // if no livetype, accept anything...
	    // if passing in a hash (no declaredClass) thats fine if we already have a type
	    // else if passing in a variable, its type should match our current type
	    if (!liveType || (this.type && inSourceData && !inSourceData.declaredClass) || (inSourceData || 0).type == this.type) {
			this.sourceData.setDataSet(inSourceData);
			if (!liveType) {
			    this._updating++;
			    /* Deprecated if clause */
			    if (inSourceData.liveView && inSourceData.liveView.getId().match(/^app\./)) {
				this.setLiveSource(this.sourceData.type);
			    } else {
				if (!this.liveView)
				    this.liveView = this.createLiveView();
				this.liveView.setDataType(inSourceData.liveView.dataType);
				this.liveView.related = dojo.clone(inSourceData.liveView.related);
				this.liveView.service = inSourceData.liveView.service;
				this.liveView.view = dojo.clone(inSourceData.liveView.view);
				this.setLiveView(this.liveView);
			    }
			    this._updating--;
			}
	    } else if (!inSourceData) {
		this.sourceData.setDataSet(null);
	    }
	},
	// ==========================================================
	// LiveView integration
	// ==========================================================
	/** Set the LiveView or LiveTable from which we will get data information */
	/* valid input: LiveView full id or LiveTable full name */
	    /* DEPRECATED */
	setLiveSource: function(inLiveSource) {
	    var s = this.liveSource = inLiveSource;
	    var v;
	    try {
            if (this._isDesignLoaded) {
                v = studio.application.getValueById(s);
            } else {
                v = app.getValueById(s);
            }
	    } catch(e) {}
	    if (!v)
		v = this.createLiveView(s);
	    if (v)
		this.setLiveView(v);
	    if (!this._inLVPostInit) {
		this.doAutoUpdate();
	    }
	},
		     /*
	setLiveSource: function(inLiveSource) {
	    studio.testThis = this;
	    var s =this.liveSource = inLiveSource;
	    var v;
	    if (this.getRoot().app)
		v = this.getRoot().app.getValueById(s);
	    if (!v)
		v = this.createLiveView(s);
	    if (v)
		this.setLiveView(v);
	    this.doAutoUpdate();
	},*/
	setLiveView: function(inLiveView) {
		this.clearData();
		this.liveView = inLiveView;
	    if (this._isDesignLoaded) {
		this._subscribeLiveView();
	    }
	    this.setType(this.getViewType());
	},
	createLiveView: function(inType) {
		return new wm.LiveView({
			name: "liveView",
			owner: this,
			dataType: inType,
			_defaultView: true
		});
	},
	setType: function(inType) {

	    var oldSourceType = this.sourceData.type + "|" + dojo.toJson(this.sourceData._dataSchema);
	    var oldFilterType = this.filter.type + "|" + dojo.toJson(this.filter._dataSchema);

	    this.inherited(arguments);
	    var hasChanged = this._hasChanged;

	    // until we have data, assume any read livevar is a list.
	    if (this.operation == "read" && wm.isEmpty(this.getData()))
		this.isList = true;

	    this.filter.setType(this.type);
	    this.sourceData.setType(this.type);

        if (this.liveView && this.liveView.owner == this && (this.liveView.dataType != this.type || hasChanged)) {
            this.liveView.setDataType(this.type);
            this.liveView.createDefaultView();
        }

	    // I've been seeing these bindings fire way too often, so
	    // some extra tests to insure its needed
	    var newSourceType = this.sourceData.type + "|" + dojo.toJson(this.sourceData._dataSchema);
	    var newFilterType = this.filter.type + "|" + dojo.toJson(this.filter._dataSchema);
	    if (!this._updating && !this._inLVPostInit && this.$.binding && (hasChanged || oldSourceType != newSourceType || oldFilterType != newFilterType)) {
    		this.$.binding.refresh();
        }
      	if (this.refireOnDbChange) {
    		if (this._updateOnDbSubscribe) {
    		    dojo.unsubscribe(this._updateOnDbSubscribe);
    		}
    		if (this.type) {
    		    this._updateOnDbSubscribe = this.subscribe(this.type + "-server-changed", this, "updateOnDbChange");
    		}
	    }
	},
	_liveViewChanged: function() {
		this.setType(this.liveView.dataType);
		if (this.isDesignLoaded())
			this.doAutoUpdate();
	},

	// ==========================================================
	// Server I/O
	// ==========================================================
/* Commented out in 6.4; sourceData no longer available when doing a read
	_getCanUpdate: function() {
		return this.inherited(arguments) &&
			!(this.operation == "read" && this._isSourceDataBound() && wm.isEmpty(this.sourceData.getData()) );
	},
	*/
	// FIXME: need to zot this
	operationChanged: function() {
	},
    updateOnDbChange: function(inComponent) {
	// If the component that changed is this component, we don't need to update
	if (inComponent === this) return;
	if (djConfig.isDebug) this.log("autoUpdate", "updateOnDbChange");
	this.update();
    },
	_update: function() {

		// note: runtime service only available when application is deployed
		// so must wait until here to set it.
		//The following lines for checking designTime flag are not being used now.  They may be used in the future to differenciate requests from
		//Studio from requests deployed application.
		if (this._designTime)
			this._service = wm.getRuntimeServiceDesignTime(this);
		else
			this._service = wm.getRuntimeService(this);
		//console.log(this.name, "update");
		return this.inherited(arguments);
	},
	getArgs: function() {
	    wm.getDataConvertDates = true;
		var
			d = this.sourceData.getData(true),
			t = this.sourceData.type || this.type,
			s = wm.typeManager.getService(this.type),
			args = [s, t, wm.isEmpty(d) ? null : d];
		if (this.operation == "read") {
			args = args.concat(this._getReadArguments());
		}
	    delete wm.getDataConvertDates;
		return args;
	},
    getDebugArgs: function() {
	if (this.operation == "read") {
	    return this.filter.getData();
	} else {
	    return this.sourceData.getData();
	}
    },
	_getReadArguments: function() {
		var
			props = {properties: this._getEagerProps(this), filters: this._getFilters(), matchMode: this.matchMode, ignoreCase: this.ignoreCase},
			paging = this.orderBy ? {orderBy: (this.orderBy || "").split(",")} : {},
			max = this.isDesignLoaded() ? this.designMaxResults : this.maxResults,
			results = max ? { maxResults: max, firstResult: this.firstRow } : {};
		dojo.mixin(paging, results);
		return [props, paging];
	},
	_getFilters: function() {
		return this._getFilterValues(this.filter.getData());
	},
	_getFilterValues: function(inData, inPrefix) {
		var f = [], d, p;
		for (var i in inData) {
			d = inData[i];
			p = (inPrefix ? (inPrefix ||"") + "." : "") + i;
			if (dojo.isObject(d) && d !== null)
				f = f.concat(this._getFilterValues(d, p));
			else if (p !== undefined && d !== undefined && d !== null)
				f.push(p + "=" + d);
		}
		return f;
	},
	_isSourceDataBound: function() {
		var wires = this.$.binding.wires, w;
		for (var i in wires) {
			w = wires[i];
			if ((w.targetProperty || "").indexOf("sourceData") == 0)
				return true;
		}
	},
	processResult: function(inResult) {
	    this.dataSetCount = this._service.fullResult ? this._service.fullResult.dataSetSize : 0;
	    if (this._appendData) {
    		inResult = this.data._list.concat(inResult);
    		delete this._appendData;
	    }
		this.inherited(arguments);
	        if (this.operation != "read") {
		    dojo.publish(this.type + "-server-changed", [this]);
		}
	},
	//===========================================================================
	// Paging
	//===========================================================================
	/** Return the current data page; only relevant when maxResults is set. */
	getPage: function() {
		return Math.floor(this.firstRow / (this.maxResults || 1));
	},
	/** Return the total number of data pages. */
	getTotalPages: function() {
		return Math.ceil((this.dataSetCount || 1) / (this.maxResults || 1));
	},
	/** Set and retrieve the current data page.
		@param {Number} inPageIndex the page number to set
	 */
	setPage: function(inPageIndex) {
		inPageIndex = Math.max(0, Math.min(this.getTotalPages()-1, inPageIndex));
		this.firstRow = inPageIndex * (this.maxResults || 0);
		this.update();
	},
	/** Set and retrieve the next page of data. */
	setNextPage: function() {
		this.setPage(this.getPage()+1);
	},
	/** Set and retrieve the previous page of data. */
	setPreviousPage: function() {
		this.setPage(this.getPage()-1);
	},
	/** Set and retrieve the first page of data. */
	setFirstPage: function() {
		this.setPage(0);
	},
	/** Set and retrieve the last page of data. */
	setLastPage: function() {
		this.setPage(this.getTotalPages()-1);
	}
});


}

if(!dojo._hasResource["wm.base.components.LogoutVariable"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.components.LogoutVariable"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide("wm.base.components.LogoutVariable");


//===========================================================================
// Main service calling class: calls services with input data and returns data
//===========================================================================
/**
	Main service calling class: calls services with input data and returns data
	@name wm.ServiceVariable
	@class
	@extends wm.Variable
	@extends wm.ServiceCall
*/
dojo.declare("wm.LogoutVariable", wm.ServiceVariable, {
    service: "securityService",
    operation: "logout",
    autoUpdate: 0,
    startUpdate: 0,
    clearDataOnLogout: true,
    logoutNavCall: null,
    init: function() {
        this.inherited(arguments);
        if(!this.clearDataOnLogout || window["PhoneGap"]) {
            this.logoutNavCall = new wm.NavigationCall({
                name: "logoutNavCall",
                owner: this,
                operation: "gotoPage"
            });
            this.logoutNavCall.input.setData({
                pageName: "Login"
            });
        }
    },
    onSuccess: function(inData) {
        if(window["PhoneGap"]) {
            window.localStorage.clear(); // remove any stored information, especially their login information
        }

        if(!this.clearDataOnLogout || window["PhoneGap"]) {
            this.logoutNavCall.update();
        } else {
            window.location.reload();
            /*
              var path = window.location.pathname;
              if (path.match(/[^\/]*\.html/)) {
                  path = path.replace(/[^\/]*\.html/, "login.html");
              } else {
                  if (!path.match(/\/$/)) path += "/";
                  path += "login.html";
              }

              window.location = window.location.protocol + "//" + window.location.host + path + window.location.search;
          */
        }
    },
    onError: function(inError) {
        this.inherited(arguments); /* TODO: Localize this */
        app.alert(wm.getDictionaryItem("wm.LogoutVariable.FAILED", {
            error: inError
        }));
    },
    _end: 0
});


dojo.declare("wm.LoginVariable", wm.ServiceVariable, {
    useDefaultSuccessHandler: true,
    service: "securityService",
    operation: "login",
    _setOperation: function(inOperation) {
	this._service._operations.login = {name: "login",
				     parameters: {
					 username: {type: "string"},
					 password: {type: "string"},
                     hash : {type: "string"}
				     },
				     returnType: "java.lang.String"};
	this.inherited(arguments);
    },
    request: function() {
	var user = this.input.getValue("username");
	var pass = this.input.getValue("password");
    var hash = this.input.getValue("hash");
    if (!user || !pass) {
	    var d = new dojo.Deferred();
	    var e = new Error("Username and Password are required");
	    d.errback(e);
	    this.onResult();
	    this.onError(e);
	    return d;
	}

	var deferred = wm.login([user,pass,hash],
				this.useDefaultSuccessHandler ? null : function() {});
	deferred.addCallbacks(
	    dojo.hitch(this, function() {
		this.onResult();
		this.onSuccess();
	    }),
	    dojo.hitch(this, function(e) {
		this.onResult();
		this.onError(e);
	    })
	);

	return deferred;
    }

});

}

if(!dojo._hasResource["wm.base.components.Page"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.components.Page"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide("wm.base.components.Page");

dojo.connect(window, "onresize", function(){ dojo.publish("window-resize"); });

var wmObjectList = [];
wm.getObject = function(inType){
	if (!wmObjectList[inType])
	{
		wmObjectList[inType] = dojo.getObject(inType);
	}

	return wmObjectList[inType];
}

dojo.declare("wm.Page", wm.Component, {
        validateVisibleOnly: false,
        i18n: false,
	name: '',
        deletionDisabled: 1,
        enableMobileFolding: false,
	create: function() {
	    this.inherited(arguments);
	    if (!this.name)
		this.name = this.declaredClass.toLowerCase();

	    wm.Page.registerPage(this);

	    //dojo.addOnLoad(wm.async(dojo.hitch(this, "render")));
	    this.render();
	},
	getMainPage: function() {
	  if (!this.owner)
	  	return null;
	  var owner = this.owner;
	  while(owner.owner) {
	    owner = owner.owner;
	  }
	  if (owner instanceof wm.Application)
	    return owner;
	},
	destroy: function() {
    	this._isUnloading = true;
	    wm.Page.deregisterPage(this);
	  	var owner = this.getMainPage();
	  	if (owner)
			owner.subPageUnloaded(this);
	  	if (window.app)
			window.app.subPageUnloaded(this);
		wm.fire(this.root, "destroy");
		this.inherited(arguments);
		delete this.app;
		delete this.domNode;
		delete this.root;
		owner = null;
		delete this._designee;
	},

	init: function() {
	    this.app = window.app;
	    if (this.owner == app.pageContainer)
		window[this.name] = this;
	    this.owner[this.name] = this;
	    this.inherited(arguments);
	},
	forEachWidget: function(inFunc) {
		if (this.root)
			return wm.forEachWidget(this.root, inFunc);
		// returning pure "false" will halt the forEach, undefined is ok
	},
	render: function() {
		//console.time('renderTime ');
		// FIXME: hiding pages not owned by app when rendered
		// this really only applies to pages loaded into pageContainers
		// however, due to asynchronous rendering it's not convenient to put
		// this code elsewhere right now.
	    var notAppOwned = (this.owner != app.pageContainer);
	    var d = notAppOwned ? this.domNode || document.body : app.appRoot.domNode;
	    var ds = d.style;
		dojo.addClass(d, this.declaredClass);

		// if noAppOwned, we set left to negetive value so that user cannot see
		// the actual rendering. After this is done, we should place this div at
		// the place it was earlier(ie, previousStyleLeft).
		var previousStyleLeft = ds.left;
		if (notAppOwned)
			ds.left = "-100000px";
		wm.timePage && console.time("page.loadComponents");
	    this._loadingPage = true;
	    var startTime = new Date().getTime();
	    var widgets = this.constructor.widgets || this.widgets;
	    if (wm.isEmpty(widgets) && !this.isDesignLoaded()) {
	        console.error("Page " + this.name + " has been corrupted, and no longer has a wm.Layout nor any widgets; please create a new project or edit " + this.name + ".widgets.js by hand");

		/* Some users have asked to have their own error handlers and be able to disable our toasts */
		if (!wm.disablePageLoadingToast)
		    app.toastError(wm.getDictionaryItem("wm.Page.PAGE_ERRORS", {name: this.name}));
            }

	    if (this.owner) {
		this.locationState = (this.owner == app.pageContainer) ? app.locationState : this.owner._locationState;
	    }

	    if (wm.useDojoParser) {
		var oldOwner = wm._dojoParserCurrentOwner;
		wm._dojoParserCurrentOwner = this;
		var loaderNode = this.owner._pageLoader.htmlLoader.getHtmlNode();
		while(loaderNode.childNodes.length) {
		    if (loaderNode.firstChild)
			this.domNode.appendChild(loaderNode.firstChild);
		    else
			loaderNode.removeChild(loaderNode.firstChild);
		}
		var result = dojo.parser.parse(this.domNode);
		wm._dojoParserCurrentOwner = oldOwner;
	    } else {
		if (app.debugDialog) {
		    this.debugId = app.debugDialog.newLogEvent({eventType: "loadComponents",
								                        sourceDescription: "Page Loading",
                                                        resultDescription: this.name + " page's widgets and components initialized",
                        								method: "loadComponents",
                        								affectedId: this.getRuntimeId(),
                        								firingId: this.getRuntimeId()});
		}
		this.loadComponents(widgets, null);
		if (this.debugId) {
		    app.debugDialog.endLogEvent(this.debugId);
		    delete this.debugId;
		}
	    }
	    //this._layoutPanel.parentNode.appendChild(this._layoutPanel.domNode);

		//this.loadCssHtml();
		wm.timePage && console.timeEnd("page.loadComponents");
		var self = this;

		// reverting Michael's change here.
		//if (this.getRoot() instanceof wm.Page && this.getRoot()._loadingPage) {
		//this.postRender();
		//this.onShow();
	    //} else

		dojo.addOnLoad(dojo.hitch(this, function(){
		    this.postRender();
		    if (notAppOwned)
			ds.left = previousStyleLeft;
                    if (!this.root.isAncestorHidden())
			this.onShow();
			this.root.callOnShowParent();
		    //alert("Page rendered in " + ( new Date().getTime() - startTime) + " ms");
		    //console.timeEnd('renderTime ');
		    //console.info('postInitCalled = ' + postInitCalled);
		    //postInitCalled = 0;
		}));

		//console.profile();

	},
	postRender: function() {
		wm.timePage && console.time("root.reflow");
		wm.fire(this.root, "reflow");
		wm.timePage && console.timeEnd("root.reflow");
		/*
		if (this.owner && this.owner.reflowParent)
			this.owner.reflowParent();
		else
			dojo.publish("window-resize");
		*/
		// FIXME: automatically unload support for parts used in the studio interface
		// so as not to conflict with user parts
		wm.fire(this, "unloadSupport");
		try {
	        this._loadingPage = false;
		    if (this.root) {
			//this.root.leafFirstRenderCss();
			this.reflow();
		    }
		    if (app.debugDialog) {
    			this.debugId = app.debugDialog.newLogEvent({eventType: "start",
                                                            sourceDescription: "",
                        								    resultDescription: this.name + ".start()",
                        								    method: "start",
                        								    affectedId: this.getRuntimeId(),
                        								    firingId: this.getRuntimeId()});
		    }

		    var backState = this.owner ? this.owner._restoreBackState : undefined; // owner is PageContainer


		    if (!window["studio"] || !studio.page || this != studio.page && !this.isAncestor(studio.page)) {
			     this.start(backState, this.locationState);
		    }
		    if (this.debugId) {
    			app.debugDialog.endLogEvent(this.debugId);
    			delete this.debugId;
		    }
                    this._startCalled = true;
	        if (wm.debugPerformance) {
	            var timeToLoad = this.stopTimerWithName("LoadPage", "wm.Layout");

		    console.log("PAGE "+ timeToLoad + " ms");
		}
		    //if (!this._isDesignLoaded) {
			     this.onStart();
		    //}

                    /* Moved to Application.pageChanged
		    if (this.owner == app) {
			this.connect(document, "keydown", this, "keydown");
		    }*/
		} catch(e) {
		  console.error("Failed to initialize page " + this.name + "; " + e);
		}

	},
	start: function() {
	},
	reflow: function() {
		wm.fire(this.root, "reflow");
	},
	addComponent: function(inComponent) {
		this[inComponent.name] = inComponent;
		if (inComponent instanceof wm.Control) {
			// FIXME: hack to resolve clickability problem on IE at design-time
			// nodes must have some background or content to receive mouse events
			// on IE.
			if (this._designer && dojo.isIE <= 8) {
				var s = inComponent.domNode && dojo.getComputedStyle(inComponent.domNode);
				if (s && s.backgroundImage=="none"){
					inComponent.domNode.style.backgroundImage = "url(images/blank.gif)";
				}
			}
		/*}else{
			this.inherited(arguments);
		*/
		}
		this.inherited(arguments);
	},
	removeComponent: function(inComponent) {
		delete this[inComponent.name];
		this.inherited(arguments);
	},
	// design support
	isDesignLoaded: function() {
	    //return Boolean(this._designer);
            return this.name == "wip";
	},
	getRoot: function() {
		return this;
	},
	getId: function(inName) {
		return inName;
	},
	getRuntimeId: function(inId) {
		inId = this.name + (inId ? "." + inId : "");
		return this.owner != app.pageContainer ? this.owner.getRuntimeId(inId) : inId;
	},
	getComponent: function(inName) {
		return this.components[inName] || this[inName] || this.owner && this.owner.getComponent(inName);
	},
	_create: function(ctor, props) {
		if (ctor.prototype instanceof dijit._Widget && window.dijit){
			return new wm.DijitWrapper(dojo.mixin(props||{}, { dijitClass: ctor, publishClass: p.declaredClass }));
		}
		return this.inherited(arguments);
	},
	warnDroppedWidgets: function(inName, deviceType, inChildren, parentDropped) {
      	if (parentDropped) {
      		console.warn(inName + " was not loaded because its parent was not loaded");
      	} else {
      		console.warn(inName + " was not loaded because its deviceType property is " + deviceType + " and app is running as " + wm.device);
      	}
      	if (inChildren) {
      		wm.forEachProperty(inChildren, dojo.hitch(this, function(w, inName) {
      			if (inName != "binding") {
      				this.warnDroppedWidgets(inName, deviceType, w[3], true);
      			}
      		}));
      	}
    },
	loadComponent: function(inName, inParent, inType, inProps, inEvents, inChildren, isSecond) {
		if (!this._isDesignLoaded && inProps.deviceType && wm.device && dojo.indexOf(inProps.deviceType, wm.device) == -1) {
			if (djConfig.isDebug) this.warnDroppedWidgets(inName, inProps.deviceType.join(","), inChildren);
			return;
		}
		// Some code for debugging performance; normally skipped
		if (wm.debugPerformance) {
			if (inType == "wm.Layout") {
				if (dojo.isFF) console.groupCollapsed("LOAD COMPONENT " + inType + ": " + inName);
				else console.group("LOAD COMPONENT " + inType + ": " + inName);
			}

			this.startTimerWithName("LoadComponent", inType);
			this.startTimerWithName("LoadPage", inType);
		}

		var ctor = wm.getObject(inType);
		if (!ctor) {
			try {
				wm.getComponentStructure(inType);
				ctor = dojo.getObject(inType);
			} catch (e) {
				console.info('Error : Page.js trying to get component dynamically-------------> ' + e);
			}

			if (!ctor) {
				console.debug('Component type "' + inType + '" is not available.');
				ctor = wm.Box;
			}
		}


		// FIXME: this check really needs to go
		// yuk
		var props = {};
		isWidget = (ctor.prototype instanceof wm.Control || ctor.prototype instanceof dijit._Widget);
		if (isWidget) {
			var parentNode = (inParent ? inParent.containerNode || inParent.domNode : this.domNode);
			props = {
				owner: this,
				parent: inParent,
				domNode: parentNode ? null : document.body,
				parentNode: parentNode
			};
		}


		// props.name should overwrite getUniqueName(inName), which should overwrite inProps.
		if (!props.owner) {
			if (inParent && inParent instanceof wm.Layout) props.owner = inParent.owner;
			else if (inParent) props.owner = inParent;
			else props.owner = this;
		}
	    if (this[inName] instanceof wm.Binding) {
			c = this[inName];
	    } else {
			props = dojo.mixin({}, inProps, {
			    name: props.owner.getUniqueName(inName),
				_designer: this._designer,
				_loading: true
			}, props);
	    }
	    if (!c) {

	        /* This _isDesignLoaded case is a Special case where a Composite being designed opens a
	         * PageDialog at designtime where the PageDialog is itself not being designed but is in fact a wizard
	         */
	        if (inProps._isDesignLoaded === false) delete props._designer;

	        /* isRelativePositioned not currently supported */
			if (this.isRelativePositioned && inType == "wm.Layout") {
				props.isRelativePositioned = true;
			}

			// All custom methods should be page methods; page methods have not been evaled, so
			// can not be defined nor invoked at design time
			if (!this.isDesignLoaded()) {
				for (var p in props) {
					if (p.indexOf("custom") == 0 && dojo.isFunction(ctor.prototype[p])) {
						var owner = props.owner;
						props[p] = dojo.hitch(owner, owner[props[p]]);
					}
				}
			}



			// Calls Component.create, which calls prepare, build, init and postInit
			var c = this._create(ctor, props);


			// FIXME: this initialization should be in Component
			// to remove the distinction between 'loading' and 'creating'
			if (!inParent && isWidget) {
				c.moveable = false;
				this.root = c;
			}
	    }
		this.makeEvents(inEvents, c);
		//if (!(c instanceof wm.Layer) || !c.deferLoading)
		if (inChildren) this.loadComponents(inChildren, c);

		c.loaded(); // Component.loaded calls postInit
		var timeToLoad = this.stopTimerWithName("LoadComponent", inType);
		if (wm.debugPerformance) {
			if (inType == "wm.Layout") {
				console.log(inType + ": " + inName + " TOOK " + timeToLoad + " ms");
				console.groupEnd();
				this.printPagePerformanceData();
				console.log(inType + ": " + inName + " TOOK " + timeToLoad + " ms");
			}
		}

		return c;
	},
		printPagePerformanceData: function() {
	  var totalsByMethod = {};

			    for (var componentType in wm.Component.timingByComponent) {
			      var obj = wm.Component.timingByComponent[componentType];

			      var display = false;
			      for (var i in obj) {
				if (wm.sum(obj[i]) > 10) display = true;
			      }
			      //if (!display) continue;
			      console.group("Timing for " + componentType);
			      for (var i in obj) {
				console.log(i + ": Total: " + wm.sum(obj[i]) + ", Average: " + wm.average(obj[i]) + ", Worst: " + wm.max(obj[i]) + ", Instances: " + obj[i].length);
				if (!totalsByMethod[i]) totalsByMethod[i] = 0;
				totalsByMethod[i] += wm.sum(obj[i]);
			      }
			      console.groupEnd();
			    }
			    for (var i in totalsByMethod) {
			      console.log("TOTAL TIME IN " + i + ": " + totalsByMethod[i]);
			    }

	},

	loadComponents: function(inChildren, inParent) {
		for (var i in inChildren) {
			try
			{
			 this.loadComponent(i, inParent, inChildren[i][0], inChildren[i][1] || {}, inChildren[i][2], inChildren[i][3]);
			} catch(e) {
			  console.error("FAILED TO LOAD " + "[" + inChildren[i][1].name + "] " + i + ": ", e);
			  console.log("COMPONENT:");console.log(inChildren);
			  console.log("PARENT:");console.log(inParent);
			}
		}
	},
	onShow: function() {
	},
	onStart: function(inPage) {
	},
    keydown: function(e) {
        // if there are any modal dialogs showing, do not handle keypress, as
        // that would allow the user to interact with the page which is deliberately
        // blocked
        for (var i = 0; i < wm.dialog.showingList.length; i++) {
            if (wm.dialog.showingList[i].modal) return;
        }

        // only the application's main page should be receiving keyboard events
        if (this.owner != app.pageContainer || this != app._page) return true;

        var isInput = (e.target.tagName == "INPUT");
        var chr = app._keys[e.keyCode];
        var isSpecial = chr && chr.length > 1;

        if (e.keyCode == dojo.keys.ESCAPE) {
            this.onEscapeKey();

        } else if (e.shiftKey) {
            // we get a keyCode for the shiftKey being pressed which we should ignore; and a second keycode when a key is hit while shiftKey is held
            if (e.keyCode != dojo.keys.SHIFT && !isInput) {
                if (this.onShiftKey(chr)) dojo.stopEvent(e);
            }
        } else if (e.ctrlKey) {
            if (e.keyCode != dojo.keys.CTRL) {
                if (this.onCtrlKey(chr)) dojo.stopEvent(e);
            }
        } else if (e.keyCode == dojo.keys.ENTER && !isInput) {
            if (this.onEnterKey()) dojo.stopEvent(e);
        } else if (!isInput && e.keyCode) {
            if (isSpecial) {
                if (this.onMiscKey(chr)) dojo.stopEvent(e);
            } else {
                if (this.onLetterKey(chr)) dojo.stopEvent(e);
            }
        }

    },

        onEnterKey: function() {},
        onShiftKey: function(inCharacter) {},
        onCtrlKey: function(inCharacter) {},
        onEscapeKey: function() {},

        onLetterKey: function(inCharacter) {},
        onMiscKey: function(inCharacter) {},
	// bc only: load page css and html
	/*loadCssHtml: function() {
		var path = wm.pagesFolder + this.declaredClass + "/" + this.declaredClass;
		var hasCssLoader, hasHtmlLoader;
		for (var i in this.$) {
			if (this.$[i] instanceof wm.CssLoader)
				hasCssLoader = true;
			if (this.$[i] instanceof wm.HtmlLoader)
				hasHtmlLoader = true;
		}
		if (!hasCssLoader)
			this.loadComponent("cssLoader", null, "wm.CssLoader", {owner: this, url: path + ".css"});
		if (!hasHtmlLoader)
			this.loadComponent("htmlLoader", null, "wm.HtmlLoader", {owner: this, url: path + ".html"});
	},*/
        toString: function(inText) {
	    var t = inText || "";
	    if (this._loadingPage) {
		t += "; PAGE LOADING";
	    }
	    return this.inherited(arguments, [t]);
	},
	_end: 0
});

wm.Page.extend({
	designCreate: function() {
		this.inherited(arguments);
		this.app = this.isDesignLoaded() ? studio.application : app;
	},
	// FIXME: unload support for parts that are specifically loaded into our development environment
	// this is so that they do not conflict with user named parts with the same names.
	// the "_isWaveMakerStudio" flag is set in studio and is specifically to detect if we're in the real studio.
	unloadSupport: function() {
		if (!this.isDesignLoaded() && window.studio && window.studio._isWaveMakerStudio) {
			this.constructor._supported = false;
			this.constructor.widgets = {};
		}
	},
	generateEventName: function(inEventName) {
	    return inEventName;
	},
	_getProp: function(n) {
	    if (window["studio"] && this == studio.page && this.isEventProp(n))
		return (getEvent(n,studio.getScript())) ? n : "";
	    return this.inherited(arguments);
	},

	writeComponents: function() {
        var result = this.inherited(arguments);
        var nonvisual = [];
        var visual = [];
        dojo.forEach(result, function(item) {
            var	startIndex = item.indexOf('"')+1;
            var	endIndex = item.indexOf('"', startIndex);
            var className = item.substring(startIndex, endIndex);
            var obj = dojo.getObject(className);
            if (obj && obj.prototype instanceof wm.Control) {
                visual.push(item);
            } else {
                nonvisual.push(item);
            }
        });
        return nonvisual.concat(visual);
    },

    /* LOCALIZATION TODO:
       1. If there's a dictionary being written, the page must be set to i18n: true
       2. Must handle app level dictionary and i18n:true as well
       3. Need dictionary for terms used in scripts, and prompt to remind users when a given language they are editting does not yet have a term entered
       3. Remind user to save when changing languages
       4. Handle subcomponents
       */
    installDesignDictionary: function(inDictionary) {
    	var lang = studio.languageSelect.getDisplayValue();
    	var isDefaultLang = lang == "" || lang == "default"

    	this._editLanguage = lang

    	/* 1. Restore the default language so we're editting a fresh copy in the new language
    	 * 2. Create a new set of cache values to store the default language in
    	 */
    	var compList = wm.listComponents([this], wm.Component, false);
    	for (var i = 0; i < compList.length; i++) {
    		var c = compList[i];
    		var props = c.listWriteableProperties();
    		for (var prop in props) {
    			var value = c.getProp(prop);
    			// only do this for non-objects or for objects that aren't dojo objects nor domNodes
    			// typeof null should NOT be "object" :-(
    			if (value === null || typeof value != "object" || value.declaredClass === undefined && !wm.isNode(value)) {
    				//if (typeof value == "string" || typeof value == "boolean" || typeof value == "number") {
    				/* Restore the default values any time we change languages and clear the cache */
    				if (c["_original_i18n_" + prop] !== undefined && c["_original_i18n_" + prop] != value) {
    					c.setProp(prop, c["_original_i18n_" + prop]);
    					value = c["_original_i18n_" + prop];
    					delete c["_original_i18n_" + prop];
    				}
    				if (!isDefaultLang) {
    					c["_original_i18n_" + prop] = (typeof value == "object") ? dojo.clone(value) : value;
    				}
    			}
    		}
    	}


    	this._designDictionary = inDictionary;
    	console.log(inDictionary);
    	for (var component in inDictionary) { /* TODO: component may be a subcomponent, and we may have to parse out the "." */
    		var c = this[component];
    		if (c instanceof wm.Component) {
    			var compDesc = inDictionary[component];
    			for (var prop in compDesc) {
    				c.setProp(prop, compDesc[prop]);
    			}
    		}
    	}
    },
    getLanguageWidgets: function() {
    	var result = {};
    	var compList = wm.listComponents([this], wm.Component, false);
    	for (var i = 0; i < compList.length; i++) {
    		var c = compList[i];
    		var props = c.listWriteableProperties();
    		for (var prop in props) {
    			if (c.hasLocalizedProp(prop)) {
    				if (!result[c.name]) result[c.name] = {};
    				result[c.name][prop] = c.getProp(prop);
    			}
    		}
    	}
    	return result;
    },
    setPageProperty: function(inPropName, inValue) {
    	if (typeof inValue == "string") inValue = '"' + inValue + '"';
    	var text = studio.getScript();
    	var newtext;
    	var regex = new RegExp('"' + inPropName + '": .*,');
    	if (text.match(regex)) {
    		newtext = text.replace(regex, '"' + inPropName + '": ' + inValue + ",")
    	} else {
    		newtext = text.replace(/\{(.*?)\n/, '{$1\n\t"' + inPropName + '": ' + inValue + ',\n');
    	}
    	if (newtext != text) {
        	studio.setScript(newtext);
        }

    },
    getPageProperty: function(inPropName) {
    	if (typeof inValue == "string") inValue = '"' + inValue + '"';
    	var text = studio.getScript();
    	var regex = new RegExp('"' + inPropName + '": (.*),');
    	var matches = text.match(regex);
    	if (matches) {
    		var result = matches[1];
    		result = result.replace(/^\"/, "").replace(/\"$/, "");
    		if (typeof this[inPropName] == "boolean") {
    			result = (result == "true");
    		} else if (typeof this[inPropName] == "number") {
    			result = parseInt(result);
    		}
    		return result;
    	}
    },
    setI18n: function(inValue) {
    	this.i18n = Boolean(inValue);
    	if (this._isDesignLoaded) {
    		this.setPageProperty("i18n", this.i18n);
    	}
    },
    getI18n: function() {
    	return this.getPageProperty("i18n");
    },
    setPreferredDevice: function(inType) {
    	this.preferredDevice = inType;
    	if (this._isDesignLoaded) {
    		this.setPageProperty("preferredDevice", this.preferredDevice);
    	}
    },
    getPreferredDevice: function() {
    	return this.getPageProperty("preferredDevice");
    },
    setValidateVisibleOnly: function(inValue) {
    	this.validateVisibleOnly = Boolean(inValue);
    	if (this._isDesignLoaded) {
    		this.setPageProperty("validateVisibleOnly", this.validateVisibleOnly);
    	}
    },
    getValidateVisibleOnly: function() {
    	return this.getPageProperty("validateVisibleOnly");
    },
    set_enableMobileFolding: function(inFolding) {
    	this.enableMobileFolding = Boolean(inFolding);
    	if (this._isDesignLoaded) {
    		this.setPageProperty("enableMobileFolding", this.enableMobileFolding);
    		if (studio.currentDeviceType == "phone") {
    			studio.mobileFoldingToggleButton.setDisabled(!inFolding);
    		}
    	}
    },
    onMobileFolding: function() {},
    onMobileUnfolding: function() {}
});

wm.Object.extendSchema(wm.Page, {
    onStart: {events: ["js", "disableNoEvent"]},
    onShow: {events: ["js", "disableNoEvent"]},
    onShiftKey: {events: ["js", "disableNoEvent"]},
    onCtrlKey: {events: ["js", "disableNoEvent"]},
    onEscapeKey: {}, // allow all events
    onEnterKey: {}, // allow all events
    onLetterKey: {events: ["js", "disableNoEvent"]},
    onMiscKey: {events: ["js", "disableNoEvent"]},
    i18n: {group: "widgetName"},
    preferredDevice: {hidden:1}, // determines which device type studio should use when opening the page for editing
    validateVisibleOnly: {group: "widgetName"},
    enableMobileFolding: {group: "widgetName"}
});

// bc
wm.Part = wm.Page


dojo.mixin(wm.Page, {
    /* static variable for storing all pages; each element is an array so that there can be
     * multiple "page5" pages at the same time.  Note that if it weren't an array, then when
     * we destroy the page and remove page5 from this list, that we could no longer access ANY page5.
     */
    byName: {},
    getPage: function(inName, inIndex) {
        var page = wm.Page.byName[wm.capitalize(inName)];
        if (page && page.length) {
            if (inIndex === undefined) inIndex = page.length - 1;
            return page[inIndex];
        }
    },
    getPages: function(inName) {
        return wm.Page.byName[wm.capitalize(inName)];
    },
    registerPage: function(inPage) {
        // We'll need the page to
        if (!wm.Page.byName[inPage.declaredClass]) wm.Page.byName[inPage.declaredClass] = [];
        wm.Page.byName[inPage.declaredClass].push(inPage);
    },
    deregisterPage: function(inPage) {
        var a = wm.Page.byName[inPage.declaredClass];
        if (a) wm.Array.removeElement(a, inPage);
    }
});
wm.getPage = wm.Page.getPage;

}

if(!dojo._hasResource["wm.base.components.HtmlLoader"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.components.HtmlLoader"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide("wm.base.components.HtmlLoader");

wm.getNodeIds = function(inNode) {
	var ids = [];
	dojo.forEach(inNode.childNodes, function(n) {
		if (n.id)
			ids.push(n.id)
	});
	return ids;
}

dojo.declare("wm.HtmlLoader", wm.Component, {
	url: "",
	html: "",
	relativeUrl: true,
	init: function() {
		this.inherited(arguments);
		this.inherited(arguments);
		if (this.url)
			this.setUrl(this.url);
		else
			this.setHtml(this.html);
	},
	destroy: function() {
		this.html = null;
		dojo.destroy(this._htmlNode);
		this._htmlNode = null;
		this.inherited(arguments);
	},
	setUrl: function(inUrl) {
		this.url = inUrl || "";
		if (this.url) {
			var loadUrl = this.relativeUrl ? this.getPath() + this.url : this.url;
			this.setHtml(wm.load(loadUrl, true));
		}
	},
	setHtml: function(inHtml) {
		this.clearHtml();
		this.html = inHtml || "";
		if (this.html)
			this.addHtml(this.html);
		dojo.publish("wm-markupchanged");
	},
	clearHtml: function() {
		this.html = "";
		this.removeHtml();
	},
	getHtmlNode: function() {
		if (!this._htmlNode) {
			var n = this._htmlNode = document.createElement("div");
			n.style.display = "none";
			document.body.appendChild(n);
		}
		return this._htmlNode;
	},
	/*installHtml: function(inHtml) {
		var n = this.getHtmlNode();
		n.innerHTML = inHtml;
	},*/
	addHtml: function(inHtml) {
		if (this.isDesignLoaded()) {
			var p = this.getPath();
			// if relative paths to images are used in html, prepend the project design path
			// so that the image is resolved at designtime.
			inHtml = inHtml.replace(/<img([^>]*)src[^>]*=[^>]*(["'])([^(http:)\/][^>]*)\2/g, '<img$1src="' + p + '$3"');
		}
		var n = this.getHtmlNode();
		n.innerHTML = [n.innerHTML, inHtml].join("\n");
	},
	removeHtml: function() {
		var n = this.getHtmlNode();
		if (n)
			n.innerHTML = "";
	},
	getNodeIds: function() {
		return wm.getNodeIds(this.getHtmlNode());
	}
});


}

if(!dojo._hasResource["wm.base.components.CssLoader"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.components.CssLoader"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

/* dojo.isIE Notes: This code has been tested in IE 9; all dojo.isIE tests are still needed for IE 9 */

dojo.provide("wm.base.components.CssLoader");

dojo.declare("wm.CssLoader", wm.Component, {
	url: "",
	css: "",
	relativeUrl: true,
	init: function() {
		this.inherited(arguments);
		if (this.url)
			this.setUrl(this.url);
		else
			this.setCss(this.css);
	},
	destroy: function () {
		this._sheet = null;
		this.inherited(arguments);
	},
	getStyleSheet: function() {
		// should we have a shared stylsheet or manage separate ones (IE has a 30 stylesheet limit)
		if (dojo.isIE && !this._sheet)
				this._sheet = wm.CssLoader.sheet || (wm.CssLoader.sheet = this.makeSheet());
		if (!this._sheet) {
			this._sheet = this.makeSheet();
		}
		return this._sheet;
	},
	makeSheet: function() {
		var sheet = document.createElement("style");
		sheet.setAttribute("type", "text/css");
	        document.getElementsByTagName("head")[0].appendChild(sheet);
	        //document.getElementbody.previousSibling.appendChild(sheet); in Firefox 4 beta, this come up as a <TextNode/>
		return sheet;
	},
	setUrl: function(inUrl) {
		this.url = inUrl || "";
		if (this.url) {
			var loadUrl = this.relativeUrl ? this.getPath() + this.url : this.url;
			this.setCss(wm.load(loadUrl, true));
		}
	},
	setCss: function(inCss) {
		this.clearCss();
		this.css = inCss || "";
		if (this.css)
			this.addCss(this.css);
	},
	/*installCss: function(inCss){
		this.removeCss();
		this.addCss(inCss);
	},*/
	clearCss: function() {
		this.css = "";
		this.removeCss();
	},
	removeCss: function() {
		// FIXME: IE uses global stylesheet so do not clear styles
		// this will be an IE limitation until addressed with better stripping logic
		if (dojo.isIE)
			return;
		var s=this.getStyleSheet();
		if (s)
			if(s.styleSheet)//IE
				s.styleSheet.cssText = "";
			else {
				while (s.firstChild)
					s.removeChild(s.firstChild);
			}
	},
	addCss: function(inCss) {
		if (this.isDesignLoaded()) {
			var p = this.getPath();
			// if relative paths to images are used in css, prepend the project design path
			// so that the image is resolved at designtime.
			inCss = inCss.replace(/url\s*\(\s*([^(http:)\/].*)\.*\)/g, "url(" + p + "$1)");
		}
		var s = this.getStyleSheet();
		if(s.styleSheet) {//IE
			s.styleSheet.cssText = [s.styleSheet.cssText, inCss].join("\n");
		} else {
			s.appendChild(document.createTextNode("\n"));
			s.appendChild(document.createTextNode(inCss));
		}
	}
});



}

if(!dojo._hasResource["wm.base.components.PageLoader"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.components.PageLoader"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide("wm.base.components.PageLoader");


wm.load = function(inFile, allowCache,asyncCallback) {
    if (djConfig.isDebug && !dojo.isFF) {
	console.info("wm.load: " + inFile);
    }
    if (asyncCallback) {
        var d = dojo.xhrGet({url: inFile, sync: false , preventCache: !allowCache});
        if (typeof asyncCallback == "function") {
            d.addCallback(asyncCallback);
        }
        return d;
    } else {
        return dojo.xhrGet({url: inFile, sync: true , preventCache: !allowCache}).results[0];
    }
}

// this function will load script file on the fly and uses dojo method to this.
// if there's an error or any problem it returns false else returns true.
// Benefits of using this is that you dont have to do an eval on the js file
// as it is required for wm.load() function.
// And you dont have to put this in try catch block either since that is taken care of.
wm.dojoScriptLoader = function(uri){
	try{
	        dojo._loadUri(uri);
	}catch(e){
		console.error(e);
		return false; // Boolean
	}
}

wm.gzScriptLoader = function(name){
	try{
		var path = 'resources/gzipped/';
		dojo._loadUri(path + name.replace(/[.]/g, '/') + '.js');
	}catch(e){
		console.error('error while loading gzipped file ', e);
		return false; // Boolean
	}
}

dojo.declare("wm.PageLoader", wm.Component, {
    init: function() {
        this.randomNum = wm.saveTimestamp || Math.floor(Math.random() * 1000000);
        this.randomParam = window["PhoneGap"] ? "" : "?dojo.preventCache=" + this.randomNum;
        this.inherited(arguments);
        this._pageConnections = [];
        this.pageProps = {};
        this.cssLoader = new wm.CssLoader({
            owner: this,
            relativeUrl: false
        });
        this.htmlLoader = new wm.HtmlLoader({
            owner: this,
            relativeUrl: false
        });
    },
    // dojo.connect args without source object (first) argument.
    pageConnect: function() {
        var ctor = this.getPageCtor();
        if (ctor) {
            var args = [ctor.prototype].concat(dojo._toArray(arguments));
            this._pageConnections.push(dojo.connect.apply(dojo, args));
        }
    },
    _disconnectPage: function() {
        dojo.forEach(this._pageConnections, dojo.disconnect);
    },
    getPageCtor: function() {
        return dojo.getObject(this.className || "");
    },
    testForSecurityErrrors: function(path) {
        if (app.isSecurityEnabled) {
            try {
                var result = dojo._getText(path);
                if (result.match(/^\<\!DOCTYPE/) && result.match(/new\s*wm\.Application\(/)) {
                    this.isSecurityError = true;
                    throw "SecurityError";
                }
            } catch(e) {}
        }
    },
    loadCombinedFiles: function(inName, inPath) {
        var randpath = inPath + ".a.js" + this.randomParam;
        delete dojo._loadedUrls[randpath];
        wm.dojoScriptLoader(randpath);
        var ctor = dojo.getObject(inName);
        if (ctor) {
            this.cssLoader.setCss(ctor.prototype._cssText);
            this.htmlLoader.setHtml(ctor.prototype._htmlText);
        } else {
            this.testForSecurityErrrors(randpath);
        }
        return ctor;
    },
    loadController: function(inName, inPath) {
        var ctor = dojo.getObject(inName);
        if (!ctor && !djConfig.isDebug) {
            ctor = this.loadCombinedFiles(inName, inPath);
        }
        if (!ctor) {
            var randpath = inPath + ".js" + this.randomParam;
            delete dojo._loadedUrls[randpath];
            wm.dojoScriptLoader(randpath);
            ctor = dojo.getObject(inName);
        }
        if (!ctor) {
            this.testForSecurityErrrors(randpath);
            if (!wm.disablePageLoadingToast) app.toastError(wm.getDictionaryItem("wm.Page.PAGE_ERRORS", {
                name: inName
            }));
            console.error("Error parsing " + inPath + ".js");
            this.onError("Error parsing " + inPath + ".js"); // if you localize onError, then developers can't do tests on the return value
            ctor = dojo.declare(inName, wm.Page); // so at least we can display widgets.js
        }
        return ctor;
    },
    loadSupport: function(inCtor, inPath) {
        if (!inCtor._supported) {
            this.cssLoader.setUrl(inPath + ".css" + this.randomParam);
            inCtor.css = this.cssLoader.css;
            this.htmlLoader.setUrl(inPath + ".html" + this.randomParam);
            inCtor.html = this.htmlLoader.html;
            inCtor.html = inCtor.css = "";

            // We do not propertly cache the widgets.js file after its been loaded...
            // we delete it from memory.  But dojoScriptLoader assumes we keep it in memory and refuses to reload it.
            // By deleting it from its list of loaded urls, it should always reload.
            var randpath = inPath + ".widgets.js" + this.randomParam;
            delete dojo._loadedUrls[randpath];
            wm.dojoScriptLoader(randpath);
            inCtor._supported = true;
        }
    },
    unloadSupport: function(ctor) {
        //this.cssLoader.clearCss();
        //this.htmlLoader.clearHtml();
        if (!ctor) ctor = this.getPageCtor();
        if (ctor) {
            ctor.css = ctor.html = "";
            ctor._supported = false;
        }
    },
    loadPageCode: function(inName) {
        //console.info('this.getpath(): ' + this.getPath());        //console.info('wm.pagesFolder: ' + wm.pagesFolder);
        var path = this.getPath() + wm.pagesFolder + inName + "/" + inName;
        var ctor = dojo.getObject(inName);
        if (!ctor) ctor = this.loadController(inName, path);
        if (ctor) {
            if (ctor.prototype._cssText === undefined || wm.isEmpty(ctor.widgets)) this.loadSupport(ctor, path);
            if (ctor.prototype.i18n) {
                try {
                    dojo["requireLocalization"]("language", inName);
                    ctor.prototype._i18nDictionary = dojo.i18n.getLocalization("language", inName);
                } catch (e) {}
            }
        }
        return ctor;
    },
    loadPage: function(inClassName, inName) {
        inName = inName || inClassName;
        if (!inName) {
            wm.logging && console.debug("Invalid page name. Must load a valid page.");
            return;
        }

        this.previousPage = this.page;
        this.previousClassName = this.className;
        this.className = inClassName;
        try {
            var ctor = this.loadPageCode(inClassName);
            if (ctor) {
                this.onBeforeCreatePage();
                this.createPage(ctor, inName);
                this.pageChanged();
                this.unloadSupport(ctor);
            } else {
                console.error("Page not found:", inClassName);
                this.onError("Page not found:" + inClassName); // if you localize onError, then developers can't do tests on the return value
            }
            if (!this.page || !this.page.root) {
                console.error("Page not found:", inClassName);
                this.onError("Page not loaded:" + inClassName); // if you localize onError, then developers can't do tests on the return value
            }
        } catch (e) {
            if (this.isSecurityError) {
                delete this.isSecurityError;
                app.onSessionExpiration();
            } else {
                console.error("Page not found:", inClassName);
                this.onError(e);
            }
        }

    },
    onError: function(inErrorOrMessage) {},
    createPage: function(inCtor, inName) {
        var props = dojo.mixin({
            name: inName,
            owner: this.owner,
            domNode: this.domNode,
            isRelativePositioned: this.isRelativePositioned
        }, this.pageProps || {});
        this.page = new inCtor(props);
    },
    destroyPage: function(inPage) {
        this._disconnectPage();
        if (inPage) wm.fire(inPage, "destroy");
    },
    destroy: function() {
        this.destroyPage();
        delete this.cssLoader;
        delete this.htmlLoader;
        this.inherited(arguments);
        if (this.domNode) {
            dojo.destroy(this.domNode);
            this.domNode = null;
        }
    },
    pageChanged: function() {
        this.onPageChanged(this.page, this.previousPage);
        if (this.previousPage) {
            this.destroyPage(this.previousPage);
            delete this.previousPage;

            // since we are deleting previous page, we should also mark '_supported = false' because
            // while deleting previous page we are deleting all html nodes too.
            if (this.previousClassName) {
                try {
                    var preObj = dojo.getObject(this.previousClassName);
                    preObj._supported = false;
                } catch (e) {
                    // do nothing.
                }
            }
        }
    },
    onBeforeCreatePage: function() {},
    onPageChanged: function(inNewPage, inPreviousPage) {},
    isDesignLoaded: function() {
        if (!window["studio"]) return false;
        if (this.inherited(arguments)) return true;
        var o = this.owner;
        while (o && o instanceof wm.Application == false && o != studio.page) o = o.owner;
        if (o == studio.page) return true;
        return false;
    }
});


}

if(!dojo._hasResource["wm.base.components.Application"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.components.Application"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide("wm.base.components.Application");


wm.componentLoaders = wm.componentLoaders || {};

wm.registerComponentLoader = function(inType, inLoader){
    wm.componentLoaders[inType] = inLoader;
};

dojo.declare("wm.Application", wm.Component, {
    debugDialog: null,
    sessionExpirationHandler: "nothing",
    touchToClickDelay: 500, // ms user must hold a touch for it to be treated as a click
    touchToRightClickDelay: 1500, // ms user must hold a touch for it to be treated as a right click
    eventDelay: wm.isMobile ? 100 : 0, // 100ms delay during which a user selection is highlighted and before the event is fired
    manageURL: false,
    manageHistory: true,
    i18n: false,
    main: "Main",
    tabletMain: "",
    phoneMain: "",
    isSecurityEnabled: false,
    phoneGapLoginPage: "Login",
    hintDelay: 1500,
        disableDirtyEditorTracking: false,
        deletionDisabled: 1,
        projectSubVersion: "Alpha",
        projectVersion: 1,
        studioVersion: "",
        theme: "wm_notheme",
        toastPosition: "br",
        _lastTheme: "",
    //IERoundedCorners: false,
    init: function() {

        this.history = [];
        if (window["onpopstate"] !== undefined) {
            this._initializingBack = true;
            this.connect(window, "onpopstate", this, "_onBack");
        }

        /* load system dictionaries such as language/nls/component.js */
        this.requireLocalization();

        /* Patches is inlined into Project.a.js so it doesn't need a separate request unless in debug mode */
        if (djConfig.isDebug) {
            dojo["require"]("common." + wm.version.replace(/[^a-zA-Z0-9]/g, "") + "_patches", true);
        }

        /* Setup window.app */
        window.app = wm.application = wm.application || this;
        this.connectList = [];
        this.app = this;

        /* Load application dictionaries: language/nls/app.js */
        if (this.i18n) {
            try {
                dojo["requireLocalization"]("language", "app");
                this._i18nDictionary = dojo.i18n.getLocalization("language", "app");
            } catch (e) {}
        }

        /* If branding property is set, load branding data */
        this.loadBranding();

        /* app.init */
        this.inherited(arguments);

        this._isDesignLoaded = (window["studio"] && this != app);

        /* Init the type manager */
        if (!this._isDesignLoaded) wm.typeManager.initTypes();

        /* There are times when we need to access studio.application before we've finished initializing the app in design mode;
         * this gives us early access to it without mucking up existing logic for when its set/cleared
         */
        if (this._isDesignLoaded) {
            studio._application = this;
        }

        /* All Apps get a .WMApp parent class except for studio; this gives us extra hooks for styling apps without touching studio */
        var node = this._isDesignLoaded ? null : document.body.parentNode;
        if (node) {
            dojo.addClass(node, "WMApp");
        }

        /* Load the theme */
        var themematch = window.location.search.match(/theme\=(.*?)\&/) || window.location.search.match(/theme\=(.*?)$/);
        if (themematch) {
            this._setTheme(themematch[1], true);
        } else if (wm.device == "phone" || window["studio"] && studio.currentDeviceType == "phone") {
            this._setTheme(this.phoneTheme || this.theme, true);
        } else if (wm.device == "tablet" || window["studio"] && studio.currentDeviceType == "tablet") {
            this._setTheme(this.tabletTheme || this.theme, true);
        } else {
            this._setTheme(this.theme, true);
        }

        /* Load app.css */
        if (this._css) {
            this._cssLoader = new wm.CssLoader({
                owner: this
            });
            this._cssLoader.setCss(this._css);
        }

        /* Determines if we need to implement our own touchscrolling due to limitations in the mobile browser's touch scrolling of divs.
         * IOS 4 and and older need this.  Native android browsers for 2.x devices need this.
         */
        if (wm.isMobile) {
            if (wm.isAndroid > 2 || wm.isAndroid == "chrome" || wm.isIOS && wm.isIOS > 4 ) {;
            } else {
                this._touchEnabled = true;
            }
        }


        this.$ = this.components = {};

        this._setupKeys();
    },
    _pollForTimezoneChange: function() {
        if (new Date().getTimezoneOffset() != wm.currentTimeZone) {
            wm.setTimeZoneOffset();
            wm.currentTimeZone = new Date().getTimezoneOffset();
        }
    },
    getServerTimeOffset: function() {
        if (!this.serverTimeSVar) {
            var serverTimeSVar = this.serverTimeSVar = new wm.ServiceVariable({
                owner: this,
                name: "serverTimeSVar",
                service: "waveMakerService",
                operation: "getServerTimeOffset",
                onSuccess: function(inResult) {
                    wm.serverTimeOffset = inResult;
                    wm.setTimeZoneOffset();
                    wm.currentTimeZone = new Date().getTimezoneOffset();
                }
            });
        }
        this.serverTimeSVar.update();
    },
    _setupKeys: function() {
        this._keys = {
            8: 'BACKSPACE',
            9: 'TAB',
            13: 'ENTER',
            16: 'SHIFT',
            17: 'CTRL',
            18: 'ALT',
            19: 'BREAK',
            20: 'CAPS',
            27: 'ESC',
            32: ' ',
            33: 'PAGE UP',
            34: 'PAGE DOWN',
            35: 'END',
            36: 'HOME',
            37: 'LEFT',
            38: 'UP',
            39: 'RIGHT',
            40: 'DOWN',
            45: 'INSERT',
            46: 'DELETE',
            48: '0',
            49: '1',
            50: '2',
            51: '3',
            52: '4',
            53: '5',
            54: '6',
            55: '7',
            56: '8',
            57: '9',
            65: 'a',
            66: 'b',
            67: 'c',
            68: 'd',
            69: 'e',
            70: 'f',
            71: 'g',
            72: 'h',
            73: 'i',
            74: 'j',
            75: 'k',
            76: 'l',
            77: 'm',
            78: 'n',
            79: 'o',
            80: 'p',
            81: 'q',
            82: 'r',
            83: 's',
            84: 't',
            85: 'u',
            86: 'v',
            87: 'w',
            88: 'x',
            89: 'y',
            90: 'z',
            91: 'LEFT WINDOW',
            92: 'RIGHT WINDOW',
            93: 'SELECT',
            96: 'NUMPAD 0',
            97: 'NUMPAD 1',
            98: 'NUMPAD 2',
            99: 'NUMPAD 3',
            100: 'NUMPAD 4',
            101: 'NUMPAD 5',
            102: 'NUMPAD 6',
            103: 'NUMPAD 7',
            104: 'NUMPAD 8',
            105: 'NUMPAD 9',
            106: 'NUMPAD *',
            107: 'NUMPAD +',
            108: 'NUMPAD ENTER',
            109: 'NUMPAD -',
            110: 'NUMPAD .',
            111: 'NUMPAD /',
            112: 'F1',
            113: 'F2',
            114: 'F3',
            115: 'F4',
            116: 'F5',
            117: 'F6',
            118: 'F7',
            119: 'F8',
            120: 'F9',
            121: 'F10',
            122: 'F11',
            123: 'F12',
            144: 'NUMLOCK',
            145: 'SCROLLLOCK',
            186: ';',
            187: '=',
            188: ',',
            189: '-',
            190: '.',
            191: '/',
            192: '`',
            219: '[',
            220: "\\",
            221: ']',
            222: '"'
        };
    },
    requireLocalization: function() { /* Compiled into nls/lib_build for non-debug mode */
        if (djConfig.isDebug) {
            dojo.registerModulePath("wm.language", wm.libPath + "/wm/language");
        }
        wm.locale = {};
        
        wm.locale.phrases = dojo.i18n.getLocalization("wm.language", "components");

        
        wm.locale.props = dojo.i18n.getLocalization("wm.language", "properties");
    },
    loadBranding: function() {
        if (wm.branding) {
            this._brandingDictionary = dojo.fromJson(wm.load("branding/" + wm.branding + "/branding.js"));
            var style = document.createElement("link");
            style.type = "text/css";
            style.rel = "stylesheet";
            style.href = "branding/" + wm.branding + "/branding.css";
            document.getElementsByTagName("head")[0].appendChild(style);
        }
    },
    createDebugDialog: function() {
        dojo["require"]("wm.base.debug.Dialog");
        dojo["require"]("wm.base.components.JsonRpcService");
        if (!this.debugDialog) {
            this.debugDialog = new wm.debug.Dialog({
                owner: this,
                titlebarButtons: "DebuggerHelpIcon",
                name: "debugDialog",
                width: "700px",
                height: "400px",
                corner: "cr"
            });
        }
    },
    setPhoneTheme: function(inTheme) {
        this.phoneTheme = inTheme;
        if (wm.device == "phone" || window["studio"] && studio.currentDeviceType == "phone") {
            this._setTheme(inTheme || this.theme);// inTheme could be ""
        }
    },
    setTabletTheme: function(inTheme) {
        this.tabletTheme = inTheme;
        if (wm.device == "tablet" || window["studio"] && studio.currentDeviceType == "tablet") {
            this._setTheme(inTheme || this.theme);// inTheme could be ""
        }
    },
    _setTheme: function(inTheme, isInit, optionalCss, optionalPrototype, noRegen, forceUpdate) {
        /* Adapt themes from before inTheme was a full package path */
        if (inTheme.indexOf(".") == -1) {
            inTheme = inTheme.indexOf("wm_") == 0 ? "wm.base.widget.themes." + inTheme : "common.themes." + inTheme;
        }
        var themematch = window.location.search.match(/theme\=(.*?)\&/) || window.location.search.match(/theme\=(.*?)$/);
        var node;
        if (this._isDesignLoaded) {
            if (studio.themesListVar.query({dataValue: inTheme, designer: "themedesigner"}).getCount()) {
                node = studio.designer.domNode;
            } else {
                node = studio.designerWrapper.domNode;
            }
        } else {
            node = document.body;
        }

        if (this.themeName) {
            dojo.removeClass(studio.designer.domNode, this.themeName);
            dojo.removeClass(studio.designerWrapper.domNode, this.themeName);
        }

        if (this._isDesignLoaded) studio.themeChanged(inTheme);

        if (this._isDesignLoaded && !isInit) {
            try {
                // write before we change the prototype so defaults are left blank
                if (this._isDesignLoaded && !isInit) {
                    this._themeChanged = true;
                    this.cacheWidgets();
                }
            } catch (e) {}
        }

        this._lastTheme = this._theme;
        this._theme = inTheme;
        this.themeName = inTheme.replace(/^.*\./,"");
        dojo.addClass(node, this.themeName);


        if (this._isDesignLoaded || !isInit || themematch) {
            try {
                this.loadThemeCss(this._theme, this._isDesignLoaded, optionalCss);
                this.loadThemePrototype(this._theme, optionalPrototype);
                if (this._isDesignLoaded && !isInit && !noRegen) {
                    this.useWidgetCache();
                }
            } catch (e) {
                if (inTheme != "wm_notheme") {
                    this._setTheme("wm_notheme", isInit, optionalCss, optionalPrototype, noRegen);
                    app.alert(wm.getDictionaryItem("wm.Application.ALERT_MISSING_THEME", {
                        name: inTheme
                    }));
                } else {
                    app.alert(wm.getDictionaryItem("wm.Application.ALERT_MISSING_NOTHEME", {
                        name: inTheme
                    }));
                }
                return;
            }
        } else {
            this.loadThemePrototype(this._theme, optionalPrototype);
        }

    },
            // don't regenerate over and over; as long as the user remains in the theme designer,
            // widgetsjs shouldn't change except as prototypes change,
            // and we don't want the design to change each time the prototype border changes...
    cacheWidgets: function() {
        if (!this._widgetsjs) {
            var dialogs = "";
            var components = studio.page.components;
            for (c in components) {
                if (components[c] instanceof wm.Dialog) {
                    dialogs += components[c].write("") + ",";
                }
            }
            var widgetsjs = dojo.fromJson("{"+ dialogs + studio.page.root.write("") + "}");
            this._widgetsjs = widgetsjs;
        }
    },
    useWidgetCache: function() {
        studio.page.root.destroy();
        delete studio.page.root;
        var components = studio.page.components;
        for (c in components) {
            if (components[c] instanceof wm.Dialog) {
                components[c].destroy();
            }
        }

        studio.page.loadComponents(this._widgetsjs, null);
        delete this._widgetsjs;
        studio.page.reflow();
        studio.refreshWidgetsTree();
    },
    loadThemePrototype: function(inTheme, optionalThemeData) {
        var inThemeName = inTheme.replace(/^.*\./,"");
        var themeData = wm.Application.themeData[inTheme];
        if (!themeData || optionalThemeData) {
            var path;

            /* Up until WM 6.5, themes were specified by name not path */
            if (inTheme === inThemeName) {
                if (inThemeName.match(/^wm_/)) {
                    path = dojo.moduleUrl("wm") + "base/widget/themes/" + inThemeName + "/Theme.js";
                } else {
                     path = dojo.moduleUrl("common") + "themes/" + inThemeName + "/Theme.js";
                }
            } else {
                path = dojo.moduleUrl(inTheme) + "/Theme.js";
            }
            themeData = optionalThemeData || dojo.fromJson(dojo.xhrGet({
                url: path,
                sync: true,
                preventCache: true
            }).results[0]);
            wm.Application.themeData[inTheme] = themeData || {};
        }

        var propHash = themeData["wm.Control"];
        for (var j in propHash) {
            wm.Control.prototype[j] = propHash[j];
        }
        if (!wm.Application.themePrototypeData) wm.Application.themePrototypeData = {};
        wm.Application.themePrototypeData["wm.Control"] = this._theme;


        /*
    for (var i in themeData) {
        try {
        console.log("Set prototype of " + i);
        var propHash = themeData[i];
        var ctor = dojo.getObject(i);
        if (ctor && ctor.prototype) {
        var prototype = ctor.prototype;
        for (var j in propHash) {
            var property = propHash[j];
            prototype[j] = propHash[j];
        }
        } else {
        console.log("Theme Error: " + i + " not found");
        }
        } catch(e) {console.error("Uncaught error in themes: " + e);}
        }
            */
    },
    loadThemePrototypeForClass: function(ctor, optionalWidget) {
        if (!this._theme || !ctor) return;

        var declaredClass = ctor.prototype.declaredClass;
        if (declaredClass == "wm.Template") declaredClass = "wm.Panel";

        var themeData = wm.Application.themeData[this._theme];
        var ctorData = themeData[ctor.prototype.declaredClass];
        var p = ctor.prototype;

        /* At design time, we cache the original state of the prototype because it may change as the developer changes themes, and
         * as we switch between studio's theme and user's theme
         */
        if ((window["StudioApplication"])) {
            if (!wm.defaultPrototypeValues) {
                wm.defaultPrototypeValues = {};
            }
            if (!wm.defaultPrototypeValues[declaredClass]) {
                wm.defaultPrototypeValues[declaredClass] = {};
                var originalValues = wm.Object.getSchemaClass(ctor).prototype;
                for (var inName in originalValues) {
                    var inValue = originalValues[inName];
                    if (typeof inValue == "object" && inValue && !inValue.method && !inValue.ignore && !inValue.readonly && !inValue.operation && !(typeof p[inName] == "function")) {
                        wm.defaultPrototypeValues[declaredClass][inName] = p[inName];
                    }
                }
                if ("desktopHeight" in wm.defaultPrototypeValues[declaredClass] === false) {
                     wm.defaultPrototypeValues[declaredClass].desktopHeight = undefined;
                }
            }



            /* Restore the prototype to untampered state if we've changed themes */
            if (wm.Application.themePrototypeData[declaredClass] && wm.Application.themePrototypeData[declaredClass] != this._theme) {
                var props = wm.defaultPrototypeValues[declaredClass];
                wm.forEachProperty(props, function(inValue, inName) {
                    if (inValue && typeof inValue == "object") inValue = dojo.clone(inValue); // else all instances will share this object as a property; happens with _classes
                    p[inName] = inValue;
                    if (optionalWidget) optionalWidget[inName] = inValue;
                });
            }
        }

        /* Localization of default properties */
        if (wm.locale.props) {
            dojo.mixin(ctorData,wm.locale.props[declaredClass]);
        }
        if (wm.Application.themePrototypeData[declaredClass] != this._theme) {
            if (ctorData) {
                for (var j in ctorData) {
                    ctor.prototype[j] = ctorData[j];
                    if (optionalWidget) optionalWidget[j] = ctorData[j];
                }
            }
            wm.Application.themePrototypeData[declaredClass] = this._theme;
        } /* End localization of default properties */

    },
    loadThemeCss: function(inTheme, inDesign, optionalCss) {
        var inThemeName = inTheme.replace(/^.*\./,"");
        var path;
        var themecss;

        /* If theme is specified by name (WM 6.5 and older) rather than by path */
        if (inTheme === inThemeName) {
            if (inThemeName.match(/^wm_/)) path = dojo.moduleUrl("wm") + "base/widget/themes/" + inThemeName + "/theme.css";
            else path = dojo.moduleUrl("common") + "themes/" + inThemeName + "/theme.css";
        } else {
            path = dojo.moduleUrl(inTheme) + "/theme.css";
        }
        if (inDesign) {
            var imagepath = path.replace(/\/[^\/]*$/, "/images");
            while (imagepath.match(/[^\/]+\/\.\.\//))
            imagepath = imagepath.replace(/[^\/]+\/\.\.\//, "");
            if (optionalCss) {
                themecss = optionalCss;
            } else {
                var results = dojo.xhrGet({
                    url: path,
                    sync: true,
                    preventCache: false
                }).results;
                if (results[1]) throw results[1];
                themecss = results[0] || "";

                var results = dojo.xhrGet({
                    url: path.replace(/theme\.css/, "custom.css"),
                    sync: true,
                    preventCache: false
                }).results;
                if (!results[1]) {
                    themecss += results[0] || "";
                }
            }
            themecss = themecss.replace(/url\s*\(\s*images/g, "url(" + imagepath);
            setCss("theme_ss", themecss);
        } else {
            wm.headAppend(wm.createElement("link", {
                rel: "stylesheet",
                type: "text/css",
                href: path
            }));
        }
    },
    postInit: function() {
        this.inherited(arguments);
        //this.getRuntimeService();
    },
    destroy: function() {
        this._isDestroying = true;
        wm.fire(this.scrim, "destroy");
        wm.fire(this._runtimeService, "destroy");
        this.inherited(arguments);
        dojo.forEach(this.connectList, dojo.disconnect);
        this.connectList = null;
        delete this._page;
        /*
        if (this._pageLoader)
        {
            this._pageLoader.destroy();
            this._pageLoader = null;
        }
        */
        if (this.pageContainer) {
            this.pageContainer.destroy();
            this.pageContainer = null;
        }
        if (this.domNode) {
            dojo.destroy(this.domNode);
            this.domNode = null;
        }

        if (this.pageDialog) this.pageDialog.destroy();
        delete this.pageDialog;
        if (this.scrim) this.scrim.destroy();
        delete this.scrim;
        delete this.app;
        //dojo.publish('applicationDestroyed',[]);
    },
    createPageContainer: function() {
        if (!this._isDesignLoaded) {
        this.appRoot = new wm.AppRoot({owner: this, name: "appRoot", margin: "0", padding: "0", border: "0", borderColor: "0"});
        if (wm.isMobile) {
            dojo.addClass(document.body, "wmmobile")
        }

        this.pageContainer = new wm.PageContainer({manageHistory: this.manageHistory,
                                                    manageURL: this.manageURL,
                                                    owner: this,
                                                    parent: this.appRoot,
                                                    width: "100%",
                                                    height: "100%",
                                                    margin: wm.AppRoot.prototype.margin,
                                                    padding: wm.AppRoot.prototype.padding,
                                                    border: wm.AppRoot.prototype.border,
                                                    borderColor: wm.AppRoot.prototype.borderColor,
                                                    getRuntimeId: function() {return ""}
                                                    });
        this.connectList[this.connectList.length] = this.connect(this.pageContainer._pageLoader, "onBeforeCreatePage", this, "beforeCreatePage");
        this.connectList[this.connectList.length] = this.connect(this.pageContainer._pageLoader, "onPageChanged", this, "pageChanged");
        }
    },
/*
    createPageLoader: function() {
        this._pageLoader = new wm.PageLoader({owner: this});
        this.connectList[this.connectList.length] = this.connect(this._pageLoader, "onBeforeCreatePage", this, "beforeCreatePage");
        this.connectList[this.connectList.length] = this.connect(this._pageLoader, "onPageChanged", this, "pageChanged");
    },
    */
    // avoid unique names when loading components
    loadComponents: function(inChildren) {
        this._loading = true;
        this.createComponents(inChildren);
        // bc only
        //this.createComponent("cssLoader", "wm.CssLoader", {owner: this, url: "app.css"});
        this._loading = false;
    },
    subPageLoaded: function(inPage) {
        if (djConfig.isDebug) {
            if (this.debugSubPageList === undefined) this.debugSubPageList = {};
            this.debugSubPageList[inPage.name] = inPage;
        }
    },
    subPageUnloaded: function(inPage) {
      if (djConfig.isDebug && inPage) {
        if (this.debugSubPageList != undefined)
          delete(this.debugSubPageList[inPage.name]);
      }
    },
    _onSessionExpiration: function() {
        switch(this.sessionExpirationHandler) {
            case "nothing":
                break;
            case "navigateToLogin":
                if (window.location.pathname.indexOf("index.html") != -1) {
                    window.location.pathname = location.pathname.replace(/index\.html/, "login.html")
                } else {
                    window.location.pathname += window.location.pathname.match(/\/$/) ? "login.html" : "/login.html";
                }
                break;
            case "showLoginDialog":
                if (!this._loginDialog) {
                    this._loginDialog = new wm.PageDialog({
                        name: "_loginDialog",
                        owner: this,
                        width: "80%",
                        height: "80%",
                        title: "Login",
                        pageName: "Login",
                        hideControls: true,
                        noEscape: true,
                        deferLoad: false});
                }
                this._loginDialog.show();
            break;
        }
        wm.fire(this, "onSessionExpiration");
    },

    qualifyName: function(inName) {
        return inName;
    },
    addComponent: function(inComponent) {
        this.inherited(arguments);
        this[inComponent.name] = inComponent;
    },
    removeComponent: function(inComponent) {
        delete this[inComponent.name];
        this.inherited(arguments);
    },

    getRuntimeService: function(owner) {
        if (!this._runtimeService)
            this._runtimeService = new wm.JsonRpcService({service: "runtimeService",
                                    _isDesignLoaded: this._isDesignLoaded,
                                  owner: owner});
        return this._runtimeService;
    },

    //The following lines are not being used now.  They may be used in the future to differenciate requests from Studio from
    //requests deployed application.
    getRuntimeServiceDesignTime: function(owner) {
        if (!this._runtimeService)
            this._runtimeService = new wm.JsonRpcService({service: "runtimeService",
                                  owner: owner || this,
                                  designTime: true});
        return this._runtimeService;
    },

    getRoot: function() {
        return this;
    },

    getRuntimeId: function(inId) {
        return inId;
    },
    getId: function(inId) {
        if (inId) return "app." + inId;
        else return "app";
    },
    reflow: function(resize) {
        var d = this.domNode;
            this.appRoot.reflow();
    },
    reflowParent: function() {
        this.reflow();
    },
    loadComponent: function(inName, inParent, inType, inProps, inEvents, inChildren, isSecond) {
        return inParent.createComponent(inName, inType, inProps, inEvents, inChildren, this);
    },
    hideLoadingIndicator: function() {
        var l = dojo.byId("_wm_loading");
        if (l)
        dojo._destroyElement(l);
    },
    run: function() {
        // highlander when running
        app = wm.application = this;
        dojo.addOnLoad(dojo.hitch(this, "runOnLoad"));
    },
    runOnLoad: function() {
        // In IE6 addOnLoad is sometimes called before the dom is actually ready (bad Dojo)
        // correct here by adding a small delay.
        setTimeout(dojo.hitch(this, "doRun"), dojo.isIE < 7 ? 100 : 1);
    },
    doRun: function() {
        if (wm.isPhonegap) {
            if (!window["cordova"] && !window["PhoneGap"]) {
                wm.job("doRun", 100, this, "doRun");
                return;
            }
            if (!window["PhoneGap"]) window["PhoneGap"] = true;
            /* IFrame added by phonegap build server seems to disrupt touch events */
            if (document.body.nextSibling && document.body.nextSibling.tagName == "IFRAME") {
                dojo.destroy(document.body.nextSibling);
            }
            dojo["require"]("build.Gzipped.wm_phonegap_misc", true);
            dojo.forEach(wm.componentFixList._phonegap, function(fix) {
                try {
                    fix();
                } catch(e){}
            });
        }

		/* Needs to be here rather than postInit because wm.ServiceVariable not loaded in phonegap build until this point */
		if (!this._isDesignLoaded) {

            if (wm.serverTimeOffset === undefined) {
                this.getServerTimeOffset();
            } else {
                wm.currentTimeZone = new Date().getTimezoneOffset();
            }
            window.setInterval(dojo.hitch(this, "_pollForTimezoneChange"), 10000); //3600000); // once per hour check to see if the timezone has changed
        }

        this.createPageContainer();
        this.domNode = this.appRoot.domNode;
        this.reflow();

        /* Load all app-level components from project.js */
        this.loadComponents(this.constructor.widgets || this.widgets);


        if (!this.debugDialog) {
            if (this._overrideDebugDialog !== undefined) {
                if (this._overrideDebugDialog) this.createDebugDialog();
            } else if (djConfig.isDebug && (wm.device != "phone" || wm.isFakeMobile)) {
                this.createDebugDialog();
            }
        }

        if (!wm.isPhonegap) {
            this.pageDialog = new wm.PageDialog({
                name: "pageDialog",
                owner: this
            });
        }


        /* WM-2794: ENTER key in a text input causes focus to move to first button and fire it; make sure its a button that does nothing; only certain this is an issue in IE 8 */
        if (dojo.isIE <= 8) {
            var button = document.createElement("BUTTON");
            button.style.width = "1px";
            button.style.height = "1px";
            this.domNode.appendChild(button);
        }
        var main;
        if (wm.device == "tablet") {
            main = this.tabletMain;
        } else if (wm.device == "phone") {
            main = this.phoneMain;
        }
        if (!main) {
            main = this.main;
        }
        this.pageContainer._initialPageName = main;
        if (window["PhoneGap"] && this.isSecurityEnabled && this.isLoginPageEnabled && this.phoneGapLoginPage) {
            this.loadPage(this.phoneGapLoginPage);
        } else {
            this.loadPage(main);
        }
        this.hideLoadingIndicator();
    },
    start: function() {
        //this.hideLoadingIndicator();
    },
    getServerComponents: function() {
        if (this.serverComponents === undefined) {
            this.loadServerComponents();
        }
        return this.serverComponents;
    },
    loadServerComponents: function(inComponentType) {
        if (inComponentType && this.serverComponents) {
            for (var i=0, c; c=this.serverComponents[i]; i++) {
                if (c.type == inComponentType)
                    this.serverComponents.splice(i--, 1);
            }
            var cl = wm.componentLoaders[inComponentType];
            if (cl)
                this.serverComponents = this.serverComponents.concat(cl.getComponents());
        } else {
            this.serverComponents = [];
            for (var i in wm.componentLoaders) {
                this.serverComponents = this.serverComponents.concat(wm.componentLoaders[i].getComponents());
            }
        }
    },
    addServerComponent: function(inComponent) {
        this.serverComponents.push(inComponent);
    },
    removeServerComponent: function(inComponent) {
        for (var i=0, c; c=this.serverComponents[i]; i++){
            if (c == inComponent) {
                this.serverComponents.splice(i, 1);
                return i;
            }
        }
    },
    removeServerComponentByName: function(inComponentName, inComponentType) {
        for (var i=0, c; c=this.serverComponents[i]; i++){
            if (c.type == inComponentType && c.name == inComponentName) {
                this.serverComponents.splice(i, 1);
                return i;
            }
        }
    },
    beforeCreatePage: function() {
        this.pageContainer._pageLoader.pageConnect("start", this, "start");
        this.pageLoadedDeferred = new dojo.Deferred()
    },
    pageChanged: function(inPage, inPreviousPage) {
        // establish page reference
            this.page = this._page = inPage;
        var n = inPage.name, o = (inPreviousPage || 0).name;
        // clean up previous reference
        if (o) {
            // delete window[o]; Kana reported problems with this in IE so replacing with setting it to undefined
            window[o] = undefined;
            delete this[o];
        }
        window[n] = this[n] = this._page;
        // change callback / event
        if (this.pageLoadedDeferred)
            this.pageLoadedDeferred.callback({page: inPage, previousPage: inPreviousPage});

            // Insures only the main page gets the keydown events unless end user hacks their own
        this.connect(document, "keydown", inPage, "keydown");

        this.onPageChanged(inPage, inPreviousPage);
    },
    loadPage: function(inName) {
        var firstPage = !Boolean(this.pageContainer.page);
        if (firstPage) {
            var hash = window.location.hash;
            if (hash.length > 1) {
                try {
                    this.locationState = dojo.fromJson(hash.substring(1));
                } catch (e) {
                    try {
                        this.locationState = dojo.fromJson(unescape(hash.substring(1)));
                    } catch(e){}
                }
            }
            if (this.manageURL) {
                this._pageName = this.locationState && this.locationState.pageName ? this.locationState.pageName : inName;
            } else {
                this._pageName = inName;
            }
        } else {
            this._pageName = inName;
        }

        //this._pageLoader.unloadSupport();
        try {
            this.pageContainer.setPageName(this._pageName); //_pageLoader.loadPage(inName, inName.toLowerCase());
        } catch (e) {
            // do nothing
            if (djConfig.isDebug) console.error("loadPage error: " + e);
        }
    },
    // Provided for use in debugging. Note that when we do a better job of caching pages from server, we will need to deallocate them in this call
    forceReloadPage: function() {
        this.loadPage(this._pageName);
    },
    onPageChanged: function(inNewPage, inPreviousPage) {
    },
    onSessionExpiration: function() {

    },
    getFullVersionNumber: function() {
        return this.projectVersion + "." + this.projectSubVersion;
    },

    // This sends a synchronous request. I don't like it, but a user calling
    // this expects to get a result.
    getSessionId: function() {
        if (!this.sessionId) {
            var a = new wm.JsonRpcService({
                service: "waveMakerService",
                sync: true
            });
            a.requestSync("getSessionId", []);
            this.sessionId = a.result;
        }
        return this.sessionId;
    },
    echoFile: function(filecontents, filetype, filename) {
        if (!this.echoFileService) {
            this.echoFileService = new wm.ServiceVariable({
                owner: app,
                name: "echoFileService",
                downloadFile: true,
                service: "waveMakerService",
                operation: "echo"
            });
            this.echoFileService.input.setType("");
            wm.typeManager.addType("echoInputs",
                       {internal: false,
                        fields: {contents: {type: "java.lang.String"},
                                 fileType: {type: "java.lang.String"},
                                 fileName: {type: "java.lang.String"}}
                       });
             this.echoFileService.input.setType("echoInputs");
        }

        this.echoFileService.input.setData({contents: filecontents, fileType: filetype,fileName: filename});
        this.echoFileService.update();
    },
    showLoadingDialog: function(inMessage, inMessageWidth, optionalInTarget) {
        if (!this.loadingDialog) {
            this.loadingDialog = new wm.LoadingDialog({
                owner: this,
                name: "loadingDialog",
                widgetToCover: this.appRoot
            });
        }
        this.loadingDialog.widgetToCover = optionalInTarget || this.appRoot;
        this.loadingDialog.setCaption(inMessage || "Loading...");
        if (inMessageWidth) this.loadingDialog._label.setWidth(inMessageWidth);
        this.loadingDialog.show();
    },
    hideLoadingDialog: function() {
        if (this.loadingDialog) this.loadingDialog.hide();
    },
    warnOnce: function(inCookieName, inAlertText) {
        var cookie = dojo.cookie(inCookieName);
        if (cookie) return false;
        wm.require("wm.Checkbox");
        this.alert(inAlertText);
        if (!this._warnOnceCheckbox) {
            this._warnOnceCheckbox = new wm.Checkbox({
                owner: this.alertDialog,
                parent: this.alertDialog.containerWidget.c$[0],
                margin: "10,0,0,0",
                height: "30px",
                width: "100%",
                caption: "Don't warn again",
                captionPosition: "right",
                captionAlign: "left",
                captionSize: "100%"
            });
        }
        if (this._warnOnceConnect) this.disconnect(this._warnOnceConnect);
        this._warnOnceConnect = this.alertDialog.connectOnce(this.alertDialog, "onClose", dojo.hitch(this, "_cleanupWarnOnce", inCookieName));
        return true;
    },
    _cleanupWarnOnce: function(inCookieName) {
            if (this._warnOnceCheckbox.getChecked()) dojo.cookie(inCookieName, true);
            this._warnOnceCheckbox.destroy();
            delete this._warnOnceCheckbox;
            delete this._warnOnceConnect;
    },
    alert: function(inText, nonmodal) {
        if (!this.alertDialog) {
            this.loadThemePrototypeForClass(wm.Dialog);
            this.alertDialog = new wm.GenericDialog({
                name: "alertDialog",
                _noAnimation: true,
                owner: this,
                title: wm.getDictionaryItem("wm.Application.TITLE_ALERT"),
                noEscape: false,
                width: "400px",
                height: "180px",
                button1Caption: wm.getDictionaryItem("wm.Application.CAPTION_ALERT_OK"),
                button1Close: true,
                userPrompt: ""
            });
            this.alertDialog.domNode.style.zIndex = 45;
            dojo.attr(this.alertDialog.domNode, "role", "alertdialog");
        }

        if (this.alertDialog.width != "400px") this.alertDialog.setWidth("400px"); // reset any width changes made by users
        if (dojo.isObject(inText)) inText = inText.toString();
        nonmodal = Boolean(nonmodal);
        this.alertDialog.setUserPrompt(inText);
        this.alertDialog.setModal(!nonmodal);
        this.alertDialog.show();
    },

    confirmOKFunc: null,
    confirmCancelFunc: null,
    confirm: function(inText, nonmodal, onOKFunc, onCancelFunc, optionalOKText, optionalCancelText, noshow) {
        var d = this.confirmDialogDeferred = new dojo.Deferred();
        if (!this.confirmDialog) {
            this.loadThemePrototypeForClass(wm.Dialog);
            this.confirmDialog = new wm.GenericDialog({
                name: "confirmDialog",
                _noAnimation: true,
                owner: this,
                noEscape: false,
                width: "350px",
                height: "180px",
                button1Caption: wm.getDictionaryItem("wm.Application.CAPTION_CONFIRM_OK"),
                button1Close: true,
                button2Caption: wm.getDictionaryItem("wm.Application.CAPTION_CONFIRM_CANCEL"),
                button2Close: true,
                userPrompt: "confirm..."
            });
            this.confirmDialog.domNode.style.zIndex = 50;
            this.confirmDialog.connect(this.confirmDialog, "onButton1Click", this, "confirmDialogOKClick");
            this.confirmDialog.connect(this.confirmDialog, "onButton2Click", this, "confirmDialogCancelClick");
            this.confirmDialog.connect(this.confirmDialog, "_onEsc", this, "confirmDialogCancelClick");
            dojo.attr(this.confirmDialog.domNode, "role", "alertdialog");
        }
        nonmodal = Boolean(nonmodal);
        this.confirmDialog.setUserPrompt(inText);
        this.confirmDialog.setModal(!nonmodal);
        this.confirmDialog.setShowInput(false);
        this.confirmDialog.setTitle(wm.getDictionaryItem("wm.Application.TITLE_CONFIRM"));
        this.confirmOKFunc = onOKFunc;
        this.confirmCancelFunc = onCancelFunc;
        this.confirmDialog.setButton1Caption(optionalOKText || wm.getDictionaryItem("wm.Application.CAPTION_CONFIRM_OK"));
        this.confirmDialog.setButton2Caption(optionalCancelText || wm.getDictionaryItem("wm.Application.CAPTION_CONFIRM_CANCEL"));
        if (!noshow) this.confirmDialog.show();
        return d;
    },
    prompt: function(inText, inDefaultValue, onOKFunc, onCancelFunc, optionalOKText, optionalCancelText) {
        var d = this.confirmDialogDeferred = new dojo.Deferred();
        this.confirm(inText, false, onOKFunc, onCancelFunc, optionalOKText, optionalCancelText, true);
        this.confirmDialog.setShowInput(true);
        this.confirmDialog.setTitle(wm.getDictionaryItem("wm.Application.TITLE_CONFIRM"));
        this.confirmDialog.setInputDataValue(inDefaultValue || "");
        this.confirmDialog.show();
        return d;
    },
    confirmDialogOKClick: function() {
        if (this.confirmDialog.showInput) {
            var val = this.confirmDialog.getInputDataValue();
            if (!val) {
                this.confirmDialogDeferred.errback();
                return this.confirmDialogCancelClick();
            }
            else if (this.confirmOKFunc) {
                this.confirmOKFunc(val);
            }
            this.confirmDialogDeferred.callback(val);
        } else {
            if (this.confirmOKFunc) {
                this.confirmOKFunc();
            }
            this.confirmDialogDeferred.callback(val);
        }

    },
    confirmDialogCancelClick: function() {
        if (this.confirmCancelFunc)
            this.confirmCancelFunc();
        if (this.confirmDialogDeferred) this.confirmDialogDeferred.errback();
    },
    createToastDialog: function() {
        if (!this.toastDialog) {
            this.toastDialog = new wm.Toast({
                name: "toastDialog",
                owner: this
            });
        }
    },
    toastError: function(inMsg, optionalDuration) {
        this.createToastDialog();
        this.toastDialog.showToast(inMsg, optionalDuration || 8000, "Error");
    },
    toastWarning: function(inMsg, optionalDuration) {
        this.createToastDialog();
        this.toastDialog.showToast(inMsg, optionalDuration || 8000, "Warning");
    },
    toastSuccess: function(inMsg, optionalDuration) {
        this.createToastDialog();
        this.toastDialog.showToast(inMsg, optionalDuration || 5000, "Success");
    },
    toastInfo: function(inMsg, optionalDuration) {
        this.createToastDialog();
        this.toastDialog.showToast(inMsg, optionalDuration || 5000, "Info");
    },

    createToolTip: function(message, node, event, source) {
        if (!this.toolTipDialog) {
            this.toolTipDialog = new wm.Dialog({
                _classes: {
                    domNode: ["AppToolTip"]
                },
                title: "",
                name: "toolTipDialog",
                modal: false,
                width: "350px",
                height: "50px",
                fitToContentHeight: true,
                owner: this,
                corner: "tr",
                _fixPosition: true,
                useContainerWidget: true,
                //margin: "0,0,4,4",
                margin: "0",
                border: "1",
                padding: "4",
                manageHistory: false
            });
            this.toolTipDialog.containerWidget.destroy();
            this.toolTipDialog.useContainerWidget = false;
            delete this.toolTipDialog.containerWidget;
            delete this.toolTipDialog.containerNode;
            var html = new wm.Html({
                owner: this.toolTipDialog,
                parent: this.toolTipDialog,
                autoScroll: false,
                name: "html",
                width: "100%",
                height: "100%",
                margin: "0",
                padding: "0",
                autoSizeHeight: true
            });
            this.toolTipDialog.html = html;
        }
        this.toolTipDialog.tipOwner = source;
        if (node) {
            this.toolTipDialog.fixPositionNode = node;
        } else {
            this.toolTipDialog.fixPositionNode = null;
            var originalMouseX = this.toolTipDialog.bounds.l = event.screenX || event.clientX || event.mouseX;
            var originalMouseY = this.toolTipDialog.bounds.t = event.screenY || event.clientY || event.mouseY;
        }
        this.toolTipDialog.html.setHtml();
        this.toolTipDialog.show();
        this.toolTipDialog._cupdating = true;
        this.toolTipDialog.html.setAutoSizeWidth(false);
        this.toolTipDialog.html.setAutoSizeHeight(false);
        this.toolTipDialog.setFitToContentHeight(false);
        this.toolTipDialog.setFitToContentWidth(false);
        this.toolTipDialog.setHeight("25px");
        this.toolTipDialog.setWidth("350px");
        this.toolTipDialog.html.setHeight("100%");
        this.toolTipDialog.html.setWidth("100%");
        this.toolTipDialog._cupdating = false;
        this.toolTipDialog.renderBounds();
        this.toolTipDialog.html.setHtml(message);
        if (String(message).length < 30) {
            this.toolTipDialog.html.setAutoSizeWidth(true);
            this.toolTipDialog.setFitToContentWidth(true);
            dojo.addClass(this.toolTipDialog.domNode, "NoWrap");
        } else {
            this.toolTipDialog.html.setAutoSizeHeight(true);
            this.toolTipDialog.setFitToContentHeight(true);
            dojo.removeClass(this.toolTipDialog.domNode, "NoWrap");
        }

    	this.toolTipDialog.html.setWidth((6 + this.toolTipDialog.html.domNode.firstChild.clientWidth) + "px");
    	this.toolTipDialog.setBestWidth();

        var self = this;
        if (this._testHintConnect) dojo.disconnect(this._testHintConnect);

        this._testHintConnect = this.connect(window.document.body, "onmousemove", this, function(evt) {
            if (evt.target === this.toolTipDialog.domNode || dojo.isDescendant(evt.target, this.toolTipDialog.domNode)) return;

            /* If there is a mouse-over node, and the mouse has left the node, dismiss the tooltip */
            if (node) {
                if (evt.target != node && !dojo.isDescendant(evt.target, node)) {
                    this.hideToolTip();
                }
            }

            /* If there is no node, then just dismiss the tooltip if the mouse moves at least 20px from the location that started this tooltip */
            else if (Math.abs(evt.clientX - originalMouseX) > 20 || Math.abs(evt.clientY - originalMouseY) > 20) {
                this.hideToolTip();
            }
        });


    },
    getToolTip: function() {
        if (this.toolTipDialog) return this.toolTipDialog.userPrompt;
        return "";
    },
    hideToolTip: function() {
        dojo.disconnect(this._testHintConnect);
        delete this._testHintConnect;
        this.toolTipDialog.hide();
    },
    createMinifiedDialogPanel: function() {
        var dockHeight = parseInt(parseInt(wm.isMobile ? wm.Button.prototype.mobileHeight : wm.Button.prototype.height) * 0.8);
        dockHeight += 3; // 2 for border, 1 for padding
        this.wmMinifiedDialogPanel = new wm.Panel({
            name: "wmMinifiedDialogPanel",
            width: "100%",
            height: dockHeight + "px",
            border: "2,0,0,0",
            padding: "1,0,0,0",
            autoScroll: false,
            verticalAlign: "top",
            horizontalAlign: "left",
            layoutKind: "left-to-right",
            owner: this,
            parent: this.appRoot
        });
        //document.body.appendChild(this.wmMinifiedDialogPanel.domNode);
        //this.wmMinifiedDialogPanel.subscribe("window-resize", this, "resizeMinifiedDialogPanel");
        //this.resizeMinifiedDialogPanel();
        this.appRoot.reflow();
    },
    createMinifiedDialogLabel: function(title) {
        var l = new wm.Button({
            caption: title,
            parent: app.wmMinifiedDialogPanel,
            owner: this,
            width: "100px",
            desktopHeight: "100%",
            height: "100%",
            margin: "0",
            padding: "0",
            border: "1"
        });
        app.wmMinifiedDialogPanel.show();
        return l;
    },
    removeMinifiedDialogLabel: function(minifiedLabel) {
        minifiedLabel.destroy();
        if (this.wmMinifiedDialogPanel) {
            this.wmMinifiedDialogPanel.setShowing(Boolean(this.wmMinifiedDialogPanel.c$.length));
        }
    },
    resizeMinifiedDialogPanel: function() {
        var b = {
            l: 0,
            t: this._page.root.bounds.h - this.wmMinifiedDialogPanel.bounds.h,
            w: this._page.root.bounds.w,
            h: 25
        };
        this.wmMinifiedDialogPanel.setBounds(b);
        this.wmMinifiedDialogPanel.renderBounds();
    },
    createLeftToRightDockingPanel: function() {
        if (!this._leftToRightDockingPanel) {
            this._leftToRightDockingPanel = new wm.Panel({
                name: "_leftToRightDockingPanel",
                width: "100%",
                height: "100%",
                border: "0",
                padding: "",
                layoutKind: "left-to-right",
                owner: this,
                parent: this.appRoot
            });
            this.appRoot.moveControl(this._leftToRightDockingPanel, this.appRoot.indexOfControl(this.pageContainer));
            this.pageContainer.setParent(this._leftToRightDockingPanel);
        }
    },
    dockDialog: function(inDialog, inEdge) {
        if (inEdge == "l" || inEdge == "r") {
            this.createLeftToRightDockingPanel();
        }
        var parentPanel;
        var created = false;
        switch (inEdge) {
            case "t":
                if (this._topDock) {
                    parentPanel = this._topDock;
                } else {
                    created = true;
                    parentPanel = this._topDock = new wm.Panel({
                        owner: this,
                        name: "_topDock",
                        width: "100%",
                        height: "100px",
                        border: "0",
                        padding: "",
                        layoutKind: "left-to-right",
                        parent: this.appRoot
                    });
                    this.appRoot.moveControl(parentPanel, 0);
                    this._topSplitter = new wm.Splitter({
                        _classes: {
                            domNode: ["docksplitter"]
                        },
                        owner: this,
                        parent: this.appRoot
                    });
                    this.appRoot.moveControl(this._topSplitter, 1);
                    this._topSplitter.findLayout();
                }
                break;
            case "b":
                if (this._bottomDock) {
                    parentPanel = this._bottomDock;
                } else {
                    created = true;
                    parentPanel = this._bottomDock = new wm.Panel({
                        owner: this,
                        name: "_bottomDock",
                        width: "100%",
                        height: "100px",
                        border: "0",
                        padding: "",
                        layoutKind: "left-to-right",
                        parent: this.appRoot
                    });
                    if (this.wmMinifiedDialogPanel) {
                        this.appRoot.moveControl(parentPanel, this.wmMinifiedDialogPanel.getIndexInParent());
                    }
                    this._bottomSplitter = new wm.Splitter({
                        _classes: {
                            domNode: ["docksplitter"]
                        },
                        owner: this,
                        parent: this.appRoot
                    });
                    this.appRoot.moveControl(this._bottomSplitter, parentPanel.getIndexInParent());
                    this._bottomSplitter.findLayout();
                }
                break;
            case "l":
                if (this._leftDock) {
                    parentPanel = this._leftDock;
                } else {
                    created = true;
                    parentPanel = this._leftDock = new wm.Panel({
                        owner: this,
                        name: "_leftDock",
                        width: "150px",
                        height: "100%",
                        border: "0",
                        padding: "",
                        layoutKind: "top-to-bottom",
                        parent: this._leftToRightDockingPanel
                    });
                    this._leftToRightDockingPanel.moveControl(parentPanel, 0);
                    this._leftSplitter = new wm.Splitter({
                        _classes: {
                            domNode: ["docksplitter"]
                        },
                        owner: this,
                        parent: this._leftToRightDockingPanel
                    });
                    this._leftToRightDockingPanel.moveControl(this._leftSplitter, 1);
                    this._leftSplitter.findLayout();
                }
                break;
            case "r":
                if (this._rightDock) {
                    parentPanel = this._rightDock;
                } else {
                    created = true;
                    this._rightSplitter = new wm.Splitter({
                        _classes: {
                            domNode: ["docksplitter"]
                        },
                        owner: this,
                        parent: this._leftToRightDockingPanel
                    });
                    parentPanel = this._rightDock = new wm.Panel({
                        owner: this,
                        name: "_rightDock",
                        width: "150px",
                        height: "100%",
                        border: "0",
                        padding: "",
                        layoutKind: "top-to-bottom",
                        parent: this._leftToRightDockingPanel
                    });

                    this._rightSplitter.findLayout();

                }
                break;
        }
        inDialog.setParent(parentPanel);
        switch (inEdge) {
            case "t":
            case "b":
                if (inDialog.minHeight > parentPanel.bounds.h) parentPanel.setHeight(inDialog.minHeight + "px");
                inDialog.setWidth("100%");
                break;
            case "l":
            case "r":
                if (inDialog.minWidth > parentPanel.bounds.w) parentPanel.setWidth(inDialog.minWidth + "px");
                inDialog.setHeight("100%");
                break;
        }
        if (created) {
            this.appRoot.reflow();
        } else if (!parentPanel.showing) {
            parentPanel.show();
            if (parentPanel == this._topDock) this._topSplitter.show();
            else if (parentPanel == this._bottomDock) this._bottomSplitter.show();
            else if (parentPanel == this._rightDock) this._rightSplitter.show();
            else if (parentPanel == this._leftDock) this._leftSplitter.show();

        } else {
            parentPanel.reflow();
        }
    },
    removeDockedDialog: function(inDialog) {
        var parent = inDialog.parent;
        inDialog.setParent(null);
        if (parent.c$.length == 0) {
            parent.hide();
            if (parent == this._topDock) this._topSplitter.hide();
            else if (parent == this._bottomDock) this._bottomSplitter.hide();
            else if (parent == this._rightDock) this._rightSplitter.hide();
            else if (parent == this._leftDock) this._leftSplitter.hide();
        }
    },
    getDeviceSize: function() {
        return this.appRoot ? this.appRoot.deviceSize : "1000";
    },

    addHistory: function(state, noBack) {
        if (this.history && !this._handlingBack) {
            try {
                if (!noBack) this.history.push({
                    id: state.id,
                    options: state.options
                });

                var currentState = {};
                this._handlingBack = true;
                this._generateStateUrl(currentState);
                delete this._handlingBack;

                /* Using state.title, a user who views their history can see MyPage#SomeHint in their history instead of just 20 "MyPage" repeated without differentiation */

                if (window.history.pushState) window.history.pushState(null, "" /*state.title*/ , wm.isEmpty(currentState) ? "#" : "#" + dojo.toJson(currentState));

                /* No longer updating the title; this is great for populating the back history, but as we don't support jumping around the back history,
         * more misleading than helpful.
        if (state.title) {
            var title = dojo.query("title")[0];
            if (title) {
            var titleHtml = title.innerHTML.replace(/\#.*$/,"");
            title.innerHTML = titleHtml +  "#" + state.title;
            }
        }
        */


            } catch (e) {}
        }
    },
    _generateStateUrl: function() {},
    generateStateUrl: function(currentState) {
    },
    _onBack: function(inEvent) {
        /* onBack is called as a result of loading the page as well as from hitting the back button */
        if (this._initializingBack) {
            delete this._initializingBack;
            return;
        }
        var state = this.history.pop();
        try {
            if (state) {
                var id = state.id;
                // TODO: comp.destroy() should strip out component from history
                // so nothing points to destroyed components
                var c = this.getValueById(id);
                if (c instanceof wm.Component && c.handleBack) {
                    try {
                        this._handlingBack = true;
                        if (!c.handleBack(state.options)) this._onBack();
                    } catch (e) {}
                    delete this._handlingBack;
                } else if (this.history.length) {
                    this._onBack();
                }
            }
        } catch (e) {}

    }
});

wm.Application.themePrototypeData = {};
wm.Application.themeData = {};



}

if(!dojo._hasResource["wm.base.components.Property"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.components.Property"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide("wm.base.components.Property");

dojo.declare("wm.Property", wm.Component, {
	property: "",
	bindTarget: true,
	bindSource: true,
	isEvent: false,
	readonly: false,
    type: "",
    group: "",
    order: 100,
	init: function() {
		this.inherited(arguments);
	    if (this._isDesignLoaded && this.owner === studio.page) {
		this.designTimeInit();
	    }
	}
});

}

if(!dojo._hasResource["wm.base.components.ImageList"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.components.ImageList"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide("wm.base.components.ImageList");


dojo.declare("wm.ImageList", wm.Component, {
	width: 32,
	height: 32,
	colCount: 100,
        iconCount: 100, // needed so we can generate a UI presenting all of these icons
	url: "",
    postInit: function() {
	this.inherited(arguments);
	if (this.iconCount < this.colCount) this.iconCount = this.colCount;
	this.createStyleSheet();
    },

    createStyleSheet: function() {
	var id = this.getImageClass();
	var style = dojo.byId(id);
	if (!style) {
	    style = this.domNode = document.createElement("style");
	    style.id = id;
	    style.type = "text/css";
	    document.getElementsByTagName("head")[0].appendChild(style);	
	}

	var url = this.url;
	if (this.url.indexOf("lib/") == 0) 
	    url = dojo.moduleUrl("lib").path.replace(/lib\/$/, "") + url;
	else if(this.isDesignLoaded() && this.owner != studio) {
	    url = "/" + studio.project.getProjectPath() + "/" + url;
	}


	var text = "";
	for (var i = 0; i < this.iconCount; i++) {
	    if (text) text += ",";
	    text += "." + id + "_" + i;
	}
	text += "{background-image: url(" + url + ") !important;background-repeat:no-repeat !important;width:"+this.width + "px;height: " + this.height + "px;}\n";
	for (var i = 0; i < this.iconCount; i++) {
	    var col = i % this.colCount;
	    var row = Math.floor(i / this.colCount);
	    text += "." + id + "_" + i + " {background-position: -" + this.width*col + "px -" + (this.height * row) + "px !important;}\n";
	}

	setCss(style, text);
    },
    destroy: function() {
        dojo.destroy(this.domNode);
        this.inherited(arguments);
    },
    getImageClass: function(inIndex) {
        var id = "";
        if (this.owner instanceof wm.Application) {
            id += "app";
        } else if (this.isDesignLoaded() && this.owner == studio.page) {
            id += studio.project.pageName; // pageName: "Main"
        } else if (this.owner instanceof wm.Page) {
            id += this.owner.declaredClass; // name: "main", declaredClass: "Main"; don't use name
        } else {
            id += this.owner.getRuntimeId().replace(/\./g, "_");
        }
        id += "_" + this.name;
        if (inIndex == undefined) return id;
        else return id + "_" + inIndex;
    },
	getImageHtml: function(inIndex) {
	    var col = inIndex % this.colCount;
	    var row = Math.floor(inIndex / this.colCount);
	    var url = this.url;
	    if (this.url.indexOf("lib/") == 0) {
	       url = dojo.moduleUrl("lib").path.replace(/lib\/$/, "") + url;
	    } else if (this.isDesignLoaded() && this.owner != studio) {
	        if (url.match(/^resources/)) {
	           // loading from / studio.project.getProjectPath() is bad because on openning the project, we load these images
	           // before the app has deployed.  Where we are sure its in the resources folder, use this shortcut instead.
	           url = "projects/" + studio.project.projectName + "/" + url;
	        } else {
    	        url = "/" + studio.project.getProjectPath() + "/" + url;
    	    }
	    }
	    return '<image src="' + wm.theme.getImagesPath() + 'blank.gif"' + ' width="' + this.width + '"' + ' height="' + this.height + '"' + ' style="' + 'vertical-align: middle; ' + 'background:url(' + url + ') no-repeat ' + (-this.width * col) + 'px ' + (-this.height * row) + 'px;"' + '>';
	}
});

}

if(!dojo._hasResource["wm.base.components.Binding"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.components.Binding"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide("wm.base.components.Binding");



dojo.declare("wm.Wire", wm.Component, {
	expression: "",
	source: "",
	targetProperty: "",
	targetId: "",
	destroy: function() {
		this.disconnectWire();
		this.inherited(arguments);
	},
	/*
	init: function() {
		this.inherited(arguments);
		this.target = this.targetId ? this.getRoot().getValueById(this.targetId) : this.owner.owner;
		if (!this.target) {
			console.info("wm.Wire.init(): bad target: " + this.targetId + " (" + this.owner.owner.name + ")");
			this.bad = true;
			return;
		}
		// make sure binding is fully added to owner before updating values.
		if (this.owner)
			this.owner._addWire(this);
		this.connectWire();
	},
	*/
	setExpression: function(inExpression) {
		this.expression = inExpression || "";
		this.connectWire();
	},
	setSource: function(inSource) {
		this.source = inSource;
		this.connectWire();
	},
	setTargetProperty: function(inTargetProperty) {
		this.targetProperty = inTargetProperty;
		this.connectWire();
	},
	getFullTarget: function() {
		return this.target.getId() + "." + this.targetProperty;
	},
	// FIXME: if one of our source is the target's targetProperty, then will generate an infinite loop
	// this should never happen unless the user sets up an expression.
	canSetValue: function() {
		if (this.expression) {
			var sources = wm.expression.getSources(this.expression), ft = this.getFullTarget();
			for (var i=0, s; (s=sources[i]); i++)
				if (s == ft) {
					wm.logging && console.debug("Wire:", ft, "cannot be set because the target is an expression source");
					return false;
				}
		}
		return true;
	},
    debugBindingEvent: function(inValue) {
        try { /* Ignore expressions that are just literals; they provide lots of initialization "events" but no interaction events */
            if (app.debugDialog && !this.isAncestor(app.debugDialog) && !this.owner._inRefresh && (!this.expression || this.expression.match(/\$/))) {
                var firingId = "";
                if (this.source && !this.expression) {
                    var source = this.source;
                    wm.disableLazyLoad = true;
                    var sourceObj = this.getValueById(source);
                    wm.disableLazyLoad = false;
                    while (source && sourceObj instanceof wm.Component == false) {
                        if (source.indexOf(".") != -1) {
                            source = source.substring(0, source.lastIndexOf("."));
                            sourceObj = this.getValueById(source);
                        } else {
                            break;
                        }
                    }
                    if (sourceObj) {
                        firingId = sourceObj.getRuntimeId();
                    } else {
                        firingId = this.source + " not found";
                    }
                } else if (this.expression) {
                    firingId = "expression";
                }
                if (inValue instanceof wm.Component) {
                    inValue = inValue.getRuntimeId();
                } else if (typeof inValue == "string") {
                    inValue = '"' + inValue + '"';
                } else {
                    inValue = String(inValue);
                }

                this.debugId = app.debugDialog.newLogEvent({
                    eventType: "binding",
                    sourceDescription: this.owner._loading ? "Binding initialized" : (this.expression ? "Bind expression has changed" : this.source + " has changed"),
                    resultDescription: this.target.getRuntimeId() + ".setValue(\"" + this.targetProperty + "\", " + inValue + ")",
                    eventName: this.expression ? "Bind expression has changed" : this.source + " has changed",
                    affectedId: this.target.getRuntimeId(),
                    firingId: firingId,
                    boundProperty: this.targetProperty,
                    boundValue: inValue instanceof wm.Component ? "${" + inValue.getRuntimeId() + "}" : (typeof inValue == "object" && inValue !== null && inValue.length) ? "[ARRAY]" : inValue,
                    boundSource: this.source,
                    boundExpression: this.expression
                });
            }
        } catch (e) {}
    },
    endDebugBindingEvent: function() {
        if (this.debugId) {
            app.debugDialog.endLogEvent(this.debugId);
            delete this.debugId;
        }
    },
	_sourceValueChanged: function(inValue) {
		if (wm.bindingsDisabled)
			return;

	    var r = this.getRoot();
	    inValue = this.expression ? wm.expression.getValue(this.expression, r,r) : inValue;
	        if (this.canSetValue()) {
		    // ignore expressions that don't reference any variables; presume these to be
		    // literals or otherwise uninteresting to log
		    // ignore if we are in refresh; this is not called by values changing,
		    // but rather by components insuring everyone knows their state
		    this.debugBindingEvent(inValue);

		    this.target.setValue(this.targetProperty, inValue);
		    this.endDebugBindingEvent();
		}
	},
	sourceValueChanged: function(inValue, inV2) {
		wm.logging && console.info("==> (sourceValueChanged) ", this.getFullTarget(), " <= ", this.source, "(" + inValue + ")");
		this._sourceValueChanged(inValue);
		//wm.logging && console.groupEnd();
	},
	sourceTopUpdated: function(inSource, inId) {
		wm.logging && console.info("==> (sourceTopUpdated) ", this.getFullTarget(), " <= ", inSource);
		//if (wm.bindingsDisabled)
		//	return;
		//wm.logging && console.info("==> (top) ", this.source, "=>", this.getFullTarget(), " Wire.sourceTopUpdated");
		//if (this.expression || this.source.indexOf(inSource)==0) {
			this.refreshValue();
		//}
	},
	sourceRootUpdated: function() {
		// root updated is a special binding situation where we just want to check the value of the source
		// to give it a chance to create itself (this is currently necessary for Variable lazy loading)
	    // MK: 2/24/2011: I'm not seeing this called in a simple lazy loading project.  If this is in fact
	    // called, it should handle this.expression as well as this.source, but its likely obsolete
		wm.logging && console.info("==> (sourceRootUpdated)", this.source);
	        if (this.source)
		    this.getValueById(this.source);
	},
	refreshValue: function() {
		//wm.logging && console.info("==> (refresh) ", this.source, "=>", this.getFullTarget(), " Wire.refreshValue");
	    /* If we're in design mode, and the source is on a page that isn't loaded, we may find ourselves
	     * doing nasty stuff like calling set_dataSet(null) which actually clears the binding
	     * instead of transmitting binding data
	     */
	    try {
	    if (this._isDesignLoaded && this.source && this.source.indexOf("[") == 0 && this.getValueById(this.source) === null)
		return;
	    this._sourceValueChanged(this.source ? this.getValueById(this.source) : "");
	    } catch(e) {}

		//wm.logging && console.groupEnd();
	},
	disconnectWire: function() {
		//wm.logging && console.debug("Wire: ", this.target.getId() + "." + this.targetProperty, "[disconnected from]", this.source);
		this._disconnect();
		this._unsubscribe();
	},
    _watch: function(inSource, inRid) {
        wm.logging && console.info("Wire._watch: ", this.target.getId() + "." + this.targetProperty, "watching", inSource);
        // Rule 1: listen to "changed" on our source
        if(inSource.match(/^\[.*\]\./)) {
            var pre = "";
            inSource = inSource.replace(/^\[(.*?)\]/, "$1");
        } else {
            var pre = inSource.indexOf("app.") == 0 ? "" : inRid;
        }
        if (inSource.indexOf(".owner.") != -1 || inSource.indexOf("owner.") == 0) {
            var source = this.getValueById(inSource);
            var sourceTrimmed = false;
            if (!source) {
                source = this.getValueById(inSource.substring(0,inSource.lastIndexOf(".")));
                sourceTrimmed = true;
            }
            if (source) inSource = source.getRuntimeId() + (sourceTrimmed ? inSource.substring(inSource.lastIndexOf(".")) : "");
            pre = "";
        }
        var topic = pre + inSource + "-changed";
        this.subscribe(topic, this, "sourceValueChanged");
        wm.logging && console.info("***", " subscribed to [", topic, "]");

        topic = pre + inSource + "-ownerChanged";
        this.subscribe(topic, this, "refreshValue");
        wm.logging && console.info("***", " subscribed to [", topic, "]");
        /*
        var p = inSource.split("."), top = p.shift();
        if (top == "app" && p.length)
            top += "." + p.shift();
        topic = pre + top + "-ownerChanged"
        */
        // Rule 2: listen to "ownerChanged" on source's owner
        // (should be only for Variable sources, which we can't actually identify right now)
        var oid = inSource.split(".");
        oid.pop();
        oid = oid.join(".");
        if(oid && oid != "app") {
            topic = pre + oid + "-ownerChanged";
            this.subscribe(topic, this, "sourceTopUpdated");
            wm.logging && console.info("***", " subscribed to [", topic, "]");

            //
            // Rule 3: listen to "rootChanged" on source's owner root
            // (again, should be only for Variable sources, to make sure objects exist for lazy loading...)
            var p = inSource.split("."),
                rootId = p.shift();
            if(rootId == "app" && p.length) rootId += "." + p.shift();
            if(rootId != oid) {
                topic = pre + rootId + "-rootChanged"
                this.subscribe(topic, this, "sourceRootUpdated")
                wm.logging && console.info("Wire._watch: ", this.source, " subscribed to ", topic);
            }
            //
        }
    },

	connectWire: function() {
		this.disconnectWire();
		this.target = this.target || (this.targetId ? this.getRoot().getValueById(this.targetId) : this.owner.owner);
		if (!this.target) {
			console.info("wm.Wire.init(): bad target: " + this.targetId + " (" + this.owner.owner.name + ")");
			this.bad = true;
			return;
		}
		if (this.targetProperty && (this.source || this.expression)) {
			this.subscribe("wmwidget-idchanged", this, "wireChanged");
			// Figure out runtimeId from context. Key: referenced object must be a child of target's root.
			var rid = this.getRootId();
			if (this.expression) {
				dojo.forEach(wm.expression.getSources(this.expression), dojo.hitch(this, function(s) {
					this._watch(s, rid);
				}));
			} else {
				this._watch(this.source, rid);
			}
			//if (this.targetProperty == "dataStoreName")
			//	console.info("Wire: ", this.target.getId() + "." + this.targetProperty, "[connected to]", this.source, "via", rid + this.source + '-changed');
			this.refreshValue();
		}
	},
	changeExpressionId: function(inOldId, inNewId) {
		var
			e = this.expression;
			o = "\\${" + inOldId.replace(new RegExp("\\.", "g"), "\\.");
			n = "${" + inNewId,
			r = (e.match(o + "[\\.|}]"));
		e = e.replace(new RegExp(o + "\\.", "g"), n + ".");
		e = e.replace(new RegExp(o + "}", "g"), n + "}");
		this.expression = e;
		return r;
	},
	// check if a wire needs to be updated and redo it if necessary.
	// to match, the checkId should start
	isPartialId: function(inId, inIdPart) {
		return (inId.indexOf(inIdPart) == 0) && (inIdPart.length == inId.length || inId.charAt(inIdPart.length) == ".");
	},
	// for id checking, convert id to rtId if it's not app level
	isPartialRootId: function(inId, inChangeRtId) {
		if (!inId)
			return;
		inId = inId.match("^app\.") ? inId : this.getRootId() + inId;
		return this.isPartialId(inId, inChangeRtId);
	},
	getWireId: function() {
		return (this.targetId ? this.targetId + "." : "") + this.targetProperty;
	},
	wireChanged: function(inOldId, inNewId, inOldRtId, inNewRtId) {
		var changed, wireId = this.getWireId();
		// expression
		if (this.expression)
			changed = this.changeExpressionId(inOldId, inNewId);
		// source
		if (this.isPartialRootId(this.source, inOldRtId)) {
			changed = true;
			this.source = inNewId + this.source.slice(inOldId.length);
		}
		// targetProperty
		if (this.isPartialRootId(this.targetProperty, inOldRtId)) {
			changed = true;
			this.targetProperty = inNewId + this.targetProperty.slice(inOldId.length);
		}
		// targetId
		if (this.isPartialRootId(this.targetId, inOldRtId)){
			changed = true;
			this.targetId = inNewId + this.targetId.slice(inOldId.length);
		}
		if (changed) {
			this.connectWire();
			if (this.owner && this.owner.wires) {
				delete this.owner.wires[wireId];
				this.owner.wires[this.getWireId()] = this;
			}
		}
	}
});

wm.Object.extendSchema(wm.Wire, {
	expression: {},
	source: {},
	targetProperty: {},
	targetId: {}
});

dojo.declare("wm.Binding", wm.Component, {
	constructor: function(inProps) {
		this.wires = {};
	},
	destroy: function() {
		this.removeWires();
		this.inherited(arguments);
	},
	loaded: function() {
		for (var i in this.components) {
			var c = this.components[i];
			this.wires[c.getWireId()] = c;
			c.connectWire();
		}
		this.inherited(arguments);
	},
	refresh: function() {
	    this._inRefresh = true;
		wm.forEachProperty(this.wires, function(w) { w.refreshValue(); });
	    this._inRefresh = false;
	},
	addWire: function(inTargetId, inTargetProperty, inSource, inExpression) {
		var id = (inTargetId ? inTargetId + "." : "") + inTargetProperty;
		this.removeWire(id);
		var props = {
			// FIXME: remove need for unique name here.
			name: this.getUniqueName("wire"),
			owner: this,
			targetId: inTargetId,
			targetProperty: inTargetProperty,
			source: inSource,
			expression: inExpression
		};
		var wire = this.wires[id] = new wm.Wire(props);
		wire.connectWire();
	        return wire;
	},
	// for greater control, optionally removal only occurs if source and/or expression match arguments
	removeWire: function(inWireId, inSource, inExpression) {
		var wire = this.wires[inWireId];
		if (wire) {
			var
				s = inSource == undefined || inSource == wire.source,
				e = inExpression == undefined || inExpression == wire.expression;
			if (s && e) {
				wire.destroy();
				delete this.wires[inWireId];
			}
		}
	},
	findWiresByProps: function(inProps) {
		var match = function(w) {
			for (var i in inProps)
				if (inProps[i] != w[i])
					return;
			return true;
		};
		return this.findWires(match);
	},
	findWires: function(inMatchFunc) {
		var f = [];
		if (inMatchFunc)
			wm.forEachProperty(this.wires, function(w) {
				if (inMatchFunc(w))
					f.push(w);
			});
		return f;
	},
	removeWireByProps: function(inProps) {
		var wires = this.findWiresByProps(inProps);
		this.removeWiresList(wires);
	},
	removeWireByProp: function(inPropName) {
	    var result = false;
	    wm.forEachProperty(this.wires, dojo.hitch(this, function(w) {
		    if (w.targetProperty == inPropName) {
			delete this.wires[inPropName];
			w.destroy();
			result = true;
		    }
	    }));
	    return result;
	},
	removeWireList: function(inWires) {
		dojo.forEach(inWires, dojo.hitch(this, function(w) {
			this.removeWire(w.getWireId());
		}));
	},
	removeWires: function() {
		wm.forEachProperty(this.wires, function(w) { w.destroy(); });
		this.wires = {};
	},
	write: function(inIndent) {
		return !wm.isEmpty(this.wires) ? this.inherited(arguments): null;
	}
});

}

if(!dojo._hasResource["wm.base.components.TypeDefinition"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.components.TypeDefinition"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide("wm.base.components.TypeDefinition");


dojo.declare("wm.TypeDefinitionField", wm.Component, {
    fieldType: "String", // options are "string/String", "Date", "Boolean", "any", "Number", as well as any more complex types.  Note that String/Number are not the same as StringType and NumberType; they are literals not objects.
    isObject: false, // boolean
    isList: false, // boolean
    fieldName: "",

    toTypeObj: function() {
        return {type: this.fieldType, isObject: this.isObject, isList: this.isList};
    }

});

dojo.declare("wm.TypeDefinition", wm.Component, {
    internal: false,
    collection: "Fields",
    fields: null,
    // not init; must wait for page loader to load all subcomponents (typedefinitionfields) which postInit waits for
    postInit: function() {
        delete this.fields;
        this.doAddType();
    },
    doRemoveType: function() {
        if (!this.internal) wm.typeManager.removeType(this.name);
        if (this._isDesignLoaded && studio.application && !studio.application._isDestroying) {
            studio.typesChanged();
        }
    },
    doAddType: function() {
        this.fieldsAsTypes = {};
        for (var i in this.$) {
            this.fieldsAsTypes[this.$[i].fieldName] = this.$[i].toTypeObj();
        }
        wm.typeManager.addType(this.name, {
            internal: this.internal,
            fields: this.fieldsAsTypes
        });
        //dojo.publish("TypeChange-" + this.name);
        if (this._isDesignLoaded && studio.application && !studio.application._isDestroying) {
            studio.typesChanged();
            studio.refreshComponentTree();
        }
    },
    destroy: function() {
        wm.typeManager.removeType(this.name);
        this._isDestroying = true;
        this.inherited(arguments);
    }
});


}

if(!dojo._hasResource["wm.base.components.Security"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.components.Security"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide("wm.base.components.Security");


wm.disableUserPrincipalCookie = false;

wm.login = function(args, loginSuccessCallback, loginFailedCallback, properties, projectName) {
    if (properties === undefined || properties == null) {
	properties = {
	    j_username : args[0],
	    j_password : args[1],
        hash:args[2]
	    };
    }

    var deferred = new dojo.Deferred();

    var url = (projectName ? "/" + projectName + "/" : "") + "j_spring_security_check";
    if (wm.xhrPath) url = wm.xhrPath + url;
    var def= dojo.xhrPost({
	url: url,
	content : properties,
	handleAs: "json"});

    var onError = function(inError) {
	if (loginFailedCallback) {
	    loginFailedCallback(inError.toString());
	}
	deferred.errback(inError);
    };

    def.addErrback(onError);

    var onSuccess = function(inUrl) {
        if (app && app._loginDialog && app._loginDialog.showing) app._loginDialog.hide();

        /* Fire any custom onSuccess handlers BEFORE we do a navigation that will unload the developer's components */
        deferred.callback(inUrl);

        var pathname = location.protocol + "//" + location.host + location.pathname + location.search; // sometimes using search helps and sometimes it breaks this test; still working out what is going on
        if (dojo.cookie.isSupported() && !wm.disableUserPrincipalCookie) {
            var p = {
                username: properties.j_username,
                roles: wm.getUserRoles(true)
            };
            wm.setUserPrincipal(p);
        } else {
            wm.roles = wm.getUserRoles(true);
        }
        dojo.publish("wmRbacUpdate");
        if (window["PhoneGap"] && wm.serverTimeOffset === undefined) {
            app.getServerTimeOffset();
        }
        if (loginSuccessCallback) {
            loginSuccessCallback(inUrl);
        } else if (window["PhoneGap"]) {
            app.loadPage(app.pageContainer._initialPageName); // this is where tabletMain/phoneMain/main pageName are stored for now

            // Typically this tests to see if we're on login.html and being directed to index.html
        } else if (pathname != inUrl) {
            location.href = inUrl

            // If the page name is login, but app.main is not login, then we're on the real project,
            // not the special project used for logging in.  If we're on the real project, a wm page nav is all that is needed
        } else if (app._page.name == "login" && app.main != "login") {
            app.loadPage(app.main);
        }
    };

    def.addCallback(function(response, ioArgs) {
	if (response.url) {
	    onSuccess(response.url);
	} else if (response.error) {
	    onError(new Error(response.error));
	}
    });

    return deferred;
}

wm.getUserPrincipal = function() {
	return wm.disableUserPrincipalCookie ? {} :
		dojo.fromJson(dojo.cookie("wmUserPrincipal")) || {};
}

wm.setUserPrincipal = function(userPrincipal) {
	dojo.cookie("wmUserPrincipal", dojo.toJson(userPrincipal));
}

wm.clearUserPrincipal = function() {
	dojo.cookie("wmUserPrincipal", null, {expires: -1});
}

wm.getUserRoles = function(force) {
    if (!force) {
    	if (!wm.disableUserPrincipalCookie) {
    	    if (wm.getUserPrincipal().roles) {
    		return wm.getUserPrincipal().roles;
    	    }
    	} else if (wm.roles) {
    	    return wm.roles;
    	}
    }
	var s = wm.securityService || (wm.securityService =
		new wm.JsonRpcService({name: "securityService", sync: true}));
	try {
		if (s.ready) {
			s.request("getUserRoles", null);
			if (s.result) {
				return s.result;
			}
		}
	} catch(x) {}
}

wm.logoutSuccess = function() {
    if (dojo.cookie.isSupported() && !wm.disableUserPrincipalCookie) {
	wm.clearUserPrincipal();
    } else {
	wm.roles = [];
    }
    dojo.publish("wmRbacUpdate");
}

wm.logout = function() {
	var s = wm.securityService || (wm.securityService =
		new wm.JsonRpcService({name: "securityService", sync: true, errorLevel: 2}));
	try {
		if (s.ready) {
			s.request("logout", null);
			window.location.reload();
		}
	} catch(x) {}
}


}

if(!dojo._hasResource["wm.base.widget.layout.Layout"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.widget.layout.Layout"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide("wm.base.widget.layout.Layout");

// bc only
wm.inLayout = function(inNode) {
	if (!inNode)
		return false;
	var s = inNode.style;
	return s &&
		s.zIndex >=0 && s.zIndex <= 1
		&& s.display != 'none'
		&& s.visibility != 'hidden'
		&& inNode.tagName != 'SCRIPT'
		&& inNode.nodeType == 1;
}

dojo.declare("wm.layout.Base", null, {
	inFlow: function(inControl) {
		return inControl.showing && (inControl.inFlow !== false) &&
		      (inControl instanceof wm.Dialog && inControl.docked || inControl._forceShowing || wm.inLayout(inControl.domNode)); //bc only
	},
	flow: function(inContainer) {
	},
	suggest: function(inContainer, inControl, ioInfo) {
	},
	suggestSize: function(inContainer, inControl, ioInfo) {
	},
	insert: function(inTarget, inControl, inInfo) {
	}
});

dojo.mixin(wm.layout, {
	registry: {},
	cache: {},
	register: function(inName, inClass) {
		this.registry[inName] = inClass;
	},
	addCache: function(inName, inObj) {
		this.cache[inName] = inObj;
	},
	listLayouts: function() {
		var list = [];
		for (var n in this.registry) {
			list.push(n);
		}
		return list;
	}
});

}

if(!dojo._hasResource["wm.base.widget.layout.Box"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.widget.layout.Box"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide("wm.base.widget.layout.Box");

dojo.declare("wm.layout.Box", wm.layout.Base, {

    /* Call flow on each container whose contents we want to layout.
     * flow figures out the proper parameters to put into the call to _flow, and then after everything is flowed, we call renderControls
     * to update css to the sizes calculated in flow.
     */
	flow: function(inContainer,reflowTest) {
		if (this.direction == 'h') 
			this._flow(inContainer, "l", "t", "w", "h", inContainer.horizontalAlign, inContainer.verticalAlign, reflowTest);
		else
			this._flow(inContainer, "t", "l", "h", "w", inContainer.verticalAlign, inContainer.horizontalAlign, reflowTest);
		if (!reflowTest)
			inContainer.renderControls();
            
            if (inContainer._autoSizeList) {
                var c;
                while(c = inContainer._autoSizeList.pop()) {
                    c.doAutoSize(1,1);
                }
            }

	},

    /* Private method for calculating the width/height of each widget within a container; then calls flow on each subcontainer.
     * Parameters:
     *    inContainer: the container to layout
     *    inFlowOrd: "l" or "t" (left or top).
     *               inContainer.bounds[inFlowOrd] will give us the start point for our calculations along the axis of flow
     *    inFitOrd:  "l" or "t" (left or top),
     *               inContainer.bounds[inFlowOrd] will give us the start point for our calculations along the axis of "fit" (opposite of axis of flow)
     *    inFlowAxis: "w" or "h" (width or height),
     *               indicates if we are flowing the widgets based on their width or height; this determines if we are trying to find values for bounds.w or bounds.h
     *               so that all of the children fit inside of the parent.
     *    inFitAxis: "w" or "h" (width or height),
     *               indicates if we are fitting the widgets based on their width or height; this determines if we are trying to find values for bounds.w or bounds.h
     *               for each widget that may stretch across the flow of the container
     *    inFlowAlign: left, center, right, top, middle, bottom
     *               If there is extra space left over, then ajust how widgets are aligned within the flow of the container.  Does not work if % sized widgets are used
     *    inFitAlign:  left, center, right, top, middle, bottom
     *               Determines how to vertically align a column of widgets or horizontally align row of widgets within a container. Works fine for % sized widgets.
     *    reflowTest: Finds sizes for each widget without recursively calling flow on subcontainers; does not update bounds of widgets, just tests to see how much 
     *                space is needed. TODO: Maybe we don't need this anymore?  Used to see if we should turn on/off autoScroll before we layout a container.
     */  
	_flow: function(inContainer, inFlowOrd, inFitOrd, inFlowAxis, inFitAxis, inFlowAlign, inFitAlign, reflowTest) {
            if (inContainer.fitToContentHeight) {
                if (inContainer.layoutKind == "top-to-bottom")
                    inFlowAlign = "top";
            }
            if (inContainer.fitToContentWidth) {
                if (inContainer.layoutKind == "left-to-right")
                    inFlowAlign = "left";
            }

            /* Step 1: If any of the widgets inside of this container are autosizing, then now is the time for them to figure out their sizes, 
             *         before we lay out them and their siblings.  NOTE: if they size themselves based on the bounds of their siblings,
             *         they may not get accurate information at this point; autoSizing should be done with disregard for siblings! 
             *         Note also that a widget that autosizes based on the size of the parent may find the paren't available size changing
             *         if the parent adds/removes scrollbars from its content area.  But we autoSize widgets before adding scrollbars so that
             *         a widget may resize itself BEYOND the size of the parent and force it to add scrollbars.
             */
	    this.handleAutoSizingWidgets(inContainer);

            /* Step 2: If the container is autoScrolling, figure out if scrollbars will be needed, and update them if needed.  We need to know if scrollbars
             *         are on or not as they affect our bounds.
             */
            if (inContainer.autoScroll) {
                this.handleAutoScrollBars(inContainer);               
            }

            /* Step 3: Get the container's bounds; must be done after autoScroll modifies the bounds */
	    var b = inContainer.getContentBounds();
	    var originalB = dojo.clone(b);
	    if (inContainer.autoScroll) {
		if (inContainer._preferredWidth > b.w) {
		    b.w = inContainer._preferredWidth;
		}
		if (inContainer._preferredHeight > b.h) {
		    b.h = inContainer._preferredHeight;
		}
	    }
            /* Step 4: flowEx gives us two points of information:
             *         flowEx.free:  Find out how much free space is available for for % sized widgets.  If the number is negative, 
             *                       then hopefully scrollbars are enabled or widgets will not all be visible.  
             *         flowEx.ratio: This ratio can be multiplied against each c._percEx to get the desired width or height.  It accounts for two things:
             *                       1. how much free space is available in the container, 2. If the sum of the container widget's % sizes is over 100%, 
             *                       this is a modifier on each widget's % to normalize the total back to 100%.
             */
	    var flowEx = this.calcFlexRatio(inContainer.c$, inFlowAxis, b[inFlowAxis]);

            
            /* Step 5: Typically, we start laying out widgets at inContainer.bounds[inFlowOrd].  But if alignment is used, we may start somewhere else.  
             *         Find our starting point.
             *         NOTE: contentAlign only makes sense if there are no % children. 
             *         TODO: Invalid assumption; a 50% widget can still be aligned as its not taking up the full 100% of the container.  
             *               Back in wm 4.x when flex size was used, containers were always filled.
             */
	    var roundedSizeOffset = b[inFlowAxis]; // after we're done, value should be 0 if everything works nicely, between -1 and 1 if we have some rounding errors to fix
	    var lastPercentSizedWidget = null;
	    if (flowEx.free) {
                var free = flowEx.free;
	        for (var i=0, c; c=inContainer.c$[i]; i++) {
		    if (this.inFlow(c)) {                
			if (c._percEx[inFlowAxis]) {
                            //var size = c._percEx[inFlowAxis] ? (flowEx.ratio * c._percEx[inFlowAxis]) : 0;
			    var unroundedSize = flowEx.ratio * c._percEx[inFlowAxis];
			    var size = Math.round(unroundedSize);
			    lastPercentSizedWidget = c;
			    roundedSizeOffset -= size;
			    var minName = inFlowAxis == "w" ? "minWidth" : wm.isMobile ? "minMobileHeight" : "minHeight";
			    var min = c[minName];
                            if (size < min) 
				size = min;
                            free -= size;
			} else {
			    roundedSizeOffset -= c.bounds.w;
			}
		    }
                }
		switch (inFlowAlign) {
		case "bottom":
		case "right":
		    b[inFlowOrd] += free;
		    break;
		case "middle":
		case "center":
		    b[inFlowOrd] += free / 2;
		    if (b[inFlowOrd] < 0) b[inFlowOrd] = 0;
		    break;
		}
	    }
	    var fitOrd = b[inFitOrd];
	    var fitBound = b[inFitAxis];

            /* Step 6: We need the maximum size against the flow if we are doing a fitToContent against the flow; this will be the new width/height of inContainer,
             *         and will be used for all % calculations of width or height of the container's widgets.
             *         TODO: if autoScroll is on, then we've already called getPreferredFitToContentHeight AND Width; we should cache the results of the prior call
             * /
	    if (inContainer.fitToContentHeight  && inContainer.layoutKind == "left-to-right" ||
		inContainer.fitToContentWidth && inContainer.layoutKind == "top-to-bottom") 
            {
		fitBound = (inContainer.layoutKind == "left-to-right") ? inContainer.getPreferredFitToContentHeight() : inContainer.getPreferredFitToContentWidth();
                b[inFitAxis] = fitBound;
            }
            */
            /* Step 7: Iterate over each widget in this container, calculate its size and call setBounds on it. */
	    var maxFit = 0;
	    var sizeSum = 0;	    
	    for (var i=0, c; c=inContainer.c$[i]; i++) {
		if (this.inFlow(c)) {

                    /* Step 7a: Calculate the bounds in flow of axis.
                     * If its % sized: bounds.w or bounds.h is now the %size * our ratio multiplier that builds in amount of free space and normalizes % to total of 100%
                     *                 for all children.  
                     */
		    var tmpSize = c._percEx[inFlowAxis] ? Math.round(flowEx.ratio * c._percEx[inFlowAxis]) : NaN;

		    /* For the first percent size widget found, adjust its size to compensate for any rounding errors, else a panels widgets may be 1px off
		     * in stretching the full width, and that pixel may look rather odd 
		     */
		    if (c._percEx[inFlowAxis] && !isNaN(tmpSize)) {
			if (lastPercentSizedWidget == c && Math.abs(roundedSizeOffset) <= 1) {
			    tmpSize += roundedSizeOffset;
			}
		    }

		    b[inFlowAxis] = tmpSize;
		    
		    if (wm.isMobile && isNaN(b.w) ){
			b.w = parseInt(c.width);
		    }
		    var minName = inFlowAxis == "w" ? "minWidth" : wm.isMobile ? "minMobileHeight" : "minHeight";
                    if (b[inFlowAxis] < c[minName])
                        b[inFlowAxis] = c[minName];

                    /* Step 7b: Calculate the bounds against the flow, and update the bounds and set cFitSize
                     * If its % sized: then set bounds and cFitSize to a size calculated from the parent's size * this widget's % size
                     * If its px sized: cFitSize is the control's bounds size, and then delete the bounds value; its fixed size so we won't be setting it.  
                     */
		    var cFitSize;
		    if (c._percEx[inFitAxis]) {
			    cFitSize = b[inFitAxis] = Math.min(100, c._percEx[inFitAxis]) * fitBound * 0.01;
		    } else {
                        cFitSize = c.bounds[inFitAxis];
			if (inFitAxis == "w" && c.width && parseInt(c.width) > cFitSize) {
			    cFitSize = parseInt(c.width);
			}
			delete b[inFitAxis];
                    }

                    /* Step 7c: Find the left edge or top edge of the widget.  Typically goes at 0px (or if there's padding/border/margin, 
                     *          at inContainer.getContentBounds()[inFitOrd]).  But if alignement against the flow is specified, then we'll need to modify that
                     *          start value.  End result is that b["l" or "t"] has been updated.
                     */
		    b[inFitOrd] = fitOrd;  // bounds["l" or "t"] = the "l" or "t" inContainer.


                    /* Step 7d: Verify that sizes have not been reduced below user-set or widget-preferred minimums
                     * TODO: This may be the third time in this _flow that we've called getMinHeight/WidthProp; 
                     * definitely need to cache the result for the duration of this call
                     */
		    if (c._percEx.h) {
			var minHeight = c.getMinHeightProp();
			if (minHeight > b.h) {
			    b.h = minHeight;
			    if (inFitAxis == "h")
				cFitSize = b.h;
			}
			
		    }
		    if (c._percEx.w) {
			var minWidth  = c.getMinWidthProp();
			if (minWidth > b.w) {
			    b.w = minWidth;			    
			    if (inFitAxis == "w")
				cFitSize = b.w;
			}
		    }


		    switch (inFitAlign) {
		    case "justified": // no longer supported
            		if (djConfig.isDebug && !wm.isInstanceType(inContainer, wm.Editor) && inContainer.isDesignedComponent() && inFitAxis == "w" && !wm.isInstanceType(inContainer, wm.Layers) && !wm.isInstanceType(inContainer.owner, wm.Layers))
                	dojo.deprecated("justified", inContainer.owner.toString() + ":" + inContainer.toString() + "'s " + ((inFitAxis == "w") ? "horizontalAlign" : "verticalAlign") + " is set to 'justified', which may yield unexpected behaviors; please change this alignment in the property editor");
			b[inFitAxis] = fitBound;
			break;
		    case "center":
		    case "middle":
			if (fitBound > cFitSize) {
			    b[inFitOrd] = (fitOrd + fitBound - cFitSize) / 2; 
			} else {
			    b[inFitOrd] = fitOrd;
			}
			if (b[inFitOrd] < 0) b[inFitOrd] = 0;
			break;
		    case "bottom":
		    case "right":
			b[inFitOrd] = Math.max(0,fitOrd + fitBound - cFitSize);  
			break;
		    }

		    if (wm.isMobile && (b.w > originalB.w || isNaN(b.w) && c.bounds.w > originalB.w)) {
			b.w = originalB.w;
		    }


                    /* Step 7e:  Update the bounds for the control; any bounds that were deleted or set to NaN will be left as is */
 		    c.setBounds(b.l, b.t, b.w, b.h);
                    c._renderEngineBoundsSet = true;

                    /* Step 7f: If the widget has a flow method (typically means its a wm.Container), call flow on it */
		    if (c.flow) {
			    c.flow();
		    }

                    /* Step 7g: The next widget's left or top will start after the edge of the widget just placed; so add the width to b["t" or "l"].
                       TODO: Couldn't we just set this to c.bounds["r" or "b"]?
                       */
		    b[inFlowOrd] += Math.max(0, c.bounds[inFlowAxis]);
		    maxFit = Math.max(maxFit, c.bounds[inFitAxis]);
		    wm.flowees++;
		}
            }


/*
	    if (inContainer._touchScroll && (!wm.ListViewer || inContainer instanceof wm.ListViewer == false)) {
		var touchScrollChanged = false;
		if (inFlowAxis == "h") {
		    var scrollRequiredHeight = b.t;
		    var scrollRequiredWidth = maxFit;
		} else {
		    var scrollRequiredHeight = maxFit;
		    var scrollRequiredWidth = b.l;
		}
		if (
		    scrollRequiredHeight + "px" != inContainer._touchScroll.scrollers.inner.style.height) {
		    inContainer._touchScroll.scrollers.inner.style.height = scrollRequiredHeight + "px";
		    touchScrollChanged = true;
		}
		if (scrollRequiredWidth + "px" != inContainer._touchScroll.scrollers.inner.style.width) {
		    inContainer._touchScroll.scrollers.inner.style.width = scrollRequiredWidth + "px";
		    touchScrollChanged = true;
		}
		if (touchScrollChanged)
		    inContainer._touchScroll.setupScroller();
	    }
	    */

		/* Start of Frankie's new code
		if (inContainer.autoScroll && reflowTest) {
		    if (flowEx.free < 0) {
			if (inContainer.parent) {
			    inContainer.parent._xneedReflow = true;
			}
			inContainer._xneedReflow = true;
			inContainer[(inFlowAxis == "h" ? "_xscrollY" : "_xscrollX")] = true;
			inContainer.domNode.style["overflow" + ((inFlowAxis == "h") ? "Y" : "X")] = "auto";
		    } else {
			if (inContainer.domNode.style["overflow" + ((inFlowAxis == "h") ? "Y" : "X")] == "auto") {
			    inContainer.domNode.style["overflow" + ((inFlowAxis == "h") ? "Y" : "X")] = "hidden";
			    inContainer.domNode[(inFlowAxis == "h") ? "scrollTop" : "scrollLeft"] = 0;
			}
			inContainer[(inFlowAxis == "h" ? "_xscrollY" : "_xscrollX")] = false;
		    }
		    if (cFitSizeMax > fitBound) {
			if (inContainer.parent) {
			    inContainer.parent._xneedReflow = true;
			}
			inContainer._xneedReflow = true;
			inContainer[(inFitAxis == "h" ? "_xscrollY" : "_xscrollX")] = true;
			inContainer.domNode.style["overflow" + ((inFitAxis == "h") ? "Y" : "X")] = "auto";
		    } else {
			if (inContainer.domNode.style["overflow" + ((inFitAxis == "h") ? "Y" : "X")] == "auto") {
			    inContainer.domNode.style["overflow" + ((inFitAxis == "h") ? "Y" : "X")] = "hidden";
			    inContainer.domNode[(inFitAxis == "h") ? "scrollTop" : "scrollLeft"] = 0;
			}
			inContainer[(inFitAxis == "h" ? "_xscrollY" : "_xscrollX")] = false;
		    }
		}
		 End of Frankie's new code */


                /* Step 8: if we have a fitToContent container, resize it to fit its children's width and height.
                *          Never resize a container to less than 30px high and 50px wide as a fitToContent container could disappear entirely when removing its last
                *          control, and be imposible to select or even see.
                * /
                if (inContainer.fitToContent) {
		    var bx = {};
		    if (/ *flowEx.ratio == 0 && * /(inContainer.fitToContentWidth && inFlowAxis == "w" || inContainer.fitToContentHeight && inFlowAxis == "h")) 
                        
			bx[inFlowAxis] = Math.max(b[inFlowOrd],(inFlowAxis == "h") ? 30 : 50); // Containers with fitToContent set should never be resized below 30px high and 50px wide		    
		    if (inContainer.fitToContentWidth && inFlowAxis == "h" || inContainer.fitToContentHeight && inFlowAxis == "w") 
		        bx[inFitAxis] = Math.max(fitBound, (inFlowAxis == "h") ? 30 : 50);
		    inContainer.setContentBounds(bx);
                    inContainer.calcFitToContent();
                    inContainer.renderBounds();
		}
                */

	},
    
    handleAutoSizingWidgets: function(inContainer) {
	if (!inContainer.isAncestorHiddenLayer() && inContainer.showing && (!wm.isInstanceType(inContainer, wm.Layer) || inContainer.active)) {
            var hasAutoHeight;
            var hasAutoWidth;
	    for (var i = 0; i < inContainer.c$.length; i++) {			
		var c = inContainer.c$[i];
		if (c.showing) {

                    if (c._needsAutoSize && (c.autoSizeWidth || c.autoSizeHeight)) {
                        var topParent = (c.owner instanceof wm.Page) ? c.owner.root : c.owner;
                        if (!topParent._autoSizeList)
                            topParent._autoSizeList = [];
                        if (dojo.indexOf(topParent._autoSizeList, c) == -1)
                            topParent._autoSizeList.push(c);
/*
		        var cupdatingwas = c._cupdating;
		        c._cupdating = true;				
                        c.doAutoSize(false,false);
		        c._cupdating = cupdatingwas;
                        if (c.autoSizeWidth) hasAutoWidth = true;
                        if (c.autoSizeHeight) hasAutoHeight = true;
                        */
                    } else  if (c.fitToContent) {
                        if (c.fitToContentHeight) 
                            c.bounds.h = c.getPreferredFitToContentHeight();
                        if (c.fitToContentWidth)
                            c.bounds.w = c.getPreferredFitToContentWidth();
                        c.calcFitToContent();
                        if (c.fitToContentWidth) hasAutoWidth = true;
                        if (c.fitToContentHeight) hasAutoHeight = true;
                    }
		}
	    }
	}
    },

    /* Note: we must turn overflow between auto/hidden instead of leaving it on auto because chrome browser, once the scrollbars appear,
     * won't ever go away even if scrolling is no longer needed */
    handleAutoScrollBars: function(inContainer) {
        /* Vertical scrollbars */
        if (inContainer.fitToContentHeight) {
            inContainer._xscrollY = false;
            scrollY = "hidden";
        } else {
	    //var requiredHeight = (inContainer instanceof wm.Layout) ? inContainer.bounds.h : inContainer.getPreferredFitToContentHeight();
	    var requiredHeight = inContainer._preferredHeight = inContainer.getPreferredFitToContentHeight();
            var needsScrollY = requiredHeight > inContainer.bounds.h;
            var scrollY = (needsScrollY) ? "auto" : "hidden";
            inContainer._xscrollY = (scrollY=="auto");
        }
	/*if (inContainer._touchScroll) {
	    ;
	} else*/
	if (!wm.isFakeMobile && inContainer.domNode.style.overflowY != scrollY) {
	    inContainer.domNode.style.overflowY = scrollY;
            inContainer.domNode.scrollTop = 0;
        }


        /* Horizontal scrollbars */
        if (inContainer.fitToContentWidth) {
            inContainer._xscrollX = false;
            scrollX = "hidden";
        } else {
	    var requiredWidth = inContainer._preferredWidth = inContainer.getPreferredFitToContentWidth();
            var needsScrollX = requiredWidth > inContainer.bounds.w;
            var scrollX = (needsScrollX) ? "auto" : "hidden";
        }
        inContainer._xscrollX = (scrollX=="auto");
	/*if (inContainer._touchScroll) {
	    ;
	} else*/ if (!wm.isFakeMobile && inContainer.domNode.style.overflowX != scrollX) {
	    inContainer.domNode.style.overflowX = scrollX;
            inContainer.domNode.scrollLeft = 0;
        }
    },
	calcFlexRatio: function(inC$, inAxis, inExtent) {
		var flex = 0;
		var free = inExtent;
		var minSizeSum = 0;
	        var minname = "getMin" + ((inAxis == "h") ? "Height" : "Width") + "Prop";
	    var count = 0;
	    for (var i=0, c; c=inC$[i]; i++) {
		if (this.inFlow(c)) {
		    count++;
		}
	    }

		for (var i=0, c; c=inC$[i]; i++) {
			if (this.inFlow(c)) {

				if (c._percEx[inAxis]) {
				    var minSize = c[minname]();
				    var percentSize = (Number(c._percEx[inAxis]) || 0)/100 * inExtent;
				    if (count == 1) {
					flex = 100;
				        minSizeSum += minSize;
				    } else if (minSize < percentSize) {
					flex += Number(c._percEx[inAxis]) || 0;

				        minSizeSum += minSize;
				    } else {
					free -= Math.max(c.bounds[inAxis],c[minname]());
				    }
				} else {
				    free -= c.bounds[inAxis];
				}
			}
		}

		// If this number is less than 0, then treat all minSized widgets as fixed size and factor in the minSize into the amount of free space
		if (free - minSizeSum < 0) free -= minSizeSum; 
		if (flex && flex < 100)
			flex = 100;
	    var ratio;
	    if (flex && free > 0)
		ratio = free/flex;
	    else
		ratio = 0;
		return {
			free: free,
			ratio: ratio
		};
	},
        // TODO: This, and perhaps calcFlexRatio should probably use not just minHeight/minWidth, but getMinWidthProp/getMinHeightProp
        getMaxFreeSpace: function(inC$, inAxis, inExtent) {
                var free = inExtent;
                var minSizeSum = 0;
                var minname = "min" + ((inAxis == "h") ? "Height" : "Width");
                for (var i=0, c; c=inC$[i]; i++) {
                        if (this.inFlow(c)) {
                                if (c._percEx[inAxis]) {
                                        if (c[minname]) minSizeSum += c[minname];
                                } else
                                        free -= c.bounds[inAxis];
                        }
                }

                // If this number is less than 0, then treat all minSized widgets as fixed size and factor in the minSize into the amount of free space
                if (free - minSizeSum < 0) free -= minSizeSum;
                return free;
        }

});

dojo.declare("wm.layout.HBox", wm.layout.Box, {
	direction: "h",
	suggest: function(inContainer, inControl, ioRect) {
		var x = 0;
		for (var i=0, c; c=inContainer.c$[i]; i++) {
			if (this.inFlow(c)) {
				if (ioRect.l < c.bounds.l + c.bounds.w / 2) {
					x = c.bounds.l - 1;
					break;
				}
				x = c.bounds.r;
			    ioRect.control = c;
			}
		}
	    if (!ioRect.control)
		ioRect.control = inContainer;

	        var containercoords = dojo.coords(inContainer.domNode);
	        var coords = dojo.coords(ioRect.control.domNode);
	    var styleBounds = inContainer.getStyleBounds();
	    if (ioRect.control == inContainer) {
	        ioRect.l = coords.x;
	    } else {
	        ioRect.l = coords.x + coords.w;
	    }
		ioRect.t = containercoords.y;

		ioRect.h = styleBounds.h;
		ioRect.i = i;
	}
});

dojo.declare("wm.layout.VBox", wm.layout.Box, {
	direction: "v",
	suggest: function(inContainer, inControl, ioRect) {

		var y = 0;
		for (var i=0, c; c=inContainer.c$[i]; i++) {
			if (this.inFlow(c)) {
				if (ioRect.t < c.bounds.t + c.bounds.h / 2) {
					y = c.bounds.t - 1;
					break;
				}
				y = c.bounds.b;
			    ioRect.control = c;
			}
		}
	    if (!ioRect.control) 
		ioRect.control = inContainer;

	        var containercoords = dojo.coords(inContainer.domNode);
	        var coords = dojo.coords(ioRect.control.domNode);
	    var styleBounds = inContainer.getStyleBounds();
		ioRect.l = containercoords.x;
	    if (ioRect.control == inContainer) {
	        ioRect.t = coords.y;
	    } else {
	        ioRect.t = coords.y + coords.h;
	    }

		ioRect.w = styleBounds.w;
		ioRect.i = i;

	}
});

wm.layout.register("left-to-right", wm.layout.HBox);
wm.layout.register("top-to-bottom", wm.layout.VBox);
wm.layout.addCache("left-to-right", new wm.layout.HBox());
wm.layout.addCache("top-to-bottom", new wm.layout.VBox());



/* NOTES:
 * autoScroll is not allowed in a fluid layout:
 *    scrollX: a fluid layout's width determines when its children wrap, therefore, scrolling left-to-right is not allowed
 *    scrollY: a fluid layout's height must be fluid and fit its children
 *    To scroll a fluid region you must make the parent container autoScrolling
 */
/*
dojo.declare("wm.layout.Fluid", wm.layout.Base, {
    flow: function(inContainer,reflowTest) {
	if (inContainer._inFluidReflow) return;
	inContainer._inFluidReflow = true;
	try {
	    wm.layout.Box.prototype.handleAutoSizingWidgets(inContainer);
            
	    var b = inContainer.getContentBounds();


	    var minWidths = {};
	    for (var i = 0; i < inContainer.c$.length; i++) {
		var c = inContainer.c$[i];
		if (!this.inFlow(c)) continue;		
		minWidths[c.getRuntimeId()] = c.getMinWidthProp();
	    }

	    / * PASS 1: figure out which widgets will go on which row * /
	    var rows = [[]];
	    var currentRow = rows[0];
	    var currentWidth = 0;
	    var maxWidth = b.w;
	    var requiredHeight = 0;
	    var currentRowHeight = 0;
	    for (var i = 0; i < inContainer.c$.length; i++) {
		var c = inContainer.c$[i];
		if (!this.inFlow(c)) continue;
		if (!c.bounds.w) c.updateBounds();
		var requestedWidth;
		if  (!c._percEx.w) {
		    requestedWidth = c.bounds.w;
		} else {
		    requestedWidth =  maxWidth/100*c._percEx.w;
		    if (requestedWidth < minWidths[c.getRuntimeId()])
			requestedWidth = minWidths[c.getRuntimeId()];
		}
		//var minWidth = (!c._percEx.w) ? c.bounds.w : minWidths[c.getRuntimeId()];
		/ * If there are no items in this row, then add the next item no matter what its size is;
		 * if this one widget is wider than the container's width it will be adjusted later 
		 * /
		if (currentRow.length == 0) {
		    currentRow.push(c);
		    currentWidth = requestedWidth;
		    currentRowHeight = c.bounds.h;
		}

		/ * If there's no more room, its time to move on to the next row * /
		else if (currentWidth + requestedWidth > maxWidth) {
		    currentRow = [c];
		    rows.push(currentRow);
		    currentWidth = requestedWidth;
		    requiredHeight += currentRowHeight;
		    currentRowHeight = c.bounds.h;
		}

		else {
		    currentRow.push(c);
		    currentWidth += requestedWidth;
		    currentRowHeight = Math.max(c.bounds.h, currentRowHeight);
		}
	    }
	    requiredHeight += currentRowHeight;
	    if (reflowTest) return requiredHeight;
	    / * Now iterate over each row, and layout the widgets for each row * /
	    var top = inContainer.padBorderMargin.t;
	    for (var rowId = 0; rowId < rows.length; rowId++) {
		top += this.renderRow(rows[rowId],b.l,maxWidth,top,minWidths);
	    }
	    if (inContainer.bounds.h != top) {
		if (top === inContainer.padBorderMargin.t) top = 15;
		top += inContainer.padBorderMargin.b;
		//inContainer.setHeight(top + "px"); // will trigger a reflowParent, and result in a second pass which we will block
		inContainer.height = top + "px";
	    }
	} catch(e) {
	} finally {
	    inContainer._inFluidReflow = false;
	}	
    },
    renderRow: function(row,left,maxWidth, top,minWidths) {
	var maxHeight = 0;

	/ * Step 1: normalize the % based widths * /
	var totalPercent = 0;
	var availableWidth = maxWidth;
	for (var i = 0; i < row.length; i++) {
	    var c = row[i];
	    if (c._percEx.w) {
		totalPercent += c._percEx.w;
	    } else {
		availableWidth -= c.bounds.w;
	    }
	}

	var ratio = 100/totalPercent;

	/ * Step 2: find the widgets whose minWidth is greater than the width allocated via their percent size, and
	 * remove them from the percent calculation
	 * /
	var ignorePercent = {};
	for (var i = 0; i < row.length; i++) {
	    var c = row[i];
	    var b = c.bounds;
	    if (ratio * availableWidth * c._percEx.w/100 < minWidths[c.getRuntimeId()]) {
		ignorePercent[i] = true;
	    }
	}

	/ * Step 3: Take a second pass at calculating the ratio * /
	if (!wm.isEmpty(ignorePercent)) {
	     totalPercent = 0;
	     availableWidth = maxWidth;
	    for (var i = 0; i < row.length; i++) {
		var c = row[i];
		if (c._percEx.w && !ignorePercent[i]) {
		    totalPercent += c._percEx.w;
		} else {
		    availableWidth -= Math.max(minWidths[c.getRuntimeId()],c.bounds.w);
		}
	    }

	    ratio = 100/totalPercent;
	}

	for (var i = 0; i < row.length; i++) {
	    var c = row[i];
	    var b = c.bounds;
	    b.t = top;
	    b.l = left;
	    if (c._percEx.w && !ignorePercent[i]) {
		b.w = ratio * availableWidth * c._percEx.w/100;
		if (b.w < c.minWidth) {
		    b.w = c.minWidth;
		}
	    } else if (b.w > maxWidth) {
		b.w = maxWidth;
	    } else if (b.w < minWidths[c.getRuntimeId()]) {
		b.w = minWidths[c.getRuntimeId()];
	    } else {
		b.w = b.w; // no change
	    }
	    if (!wm.isMobile && b.h < c.minHeight) {
		b.h = c.minHeight;
	    } else if (wm.isMobile && b.h < c.minMobileHeight) {
		b.h = c.minMobileHeight;
	    }
	    c.setBounds(b);
	    c.renderBounds();
	    if (c.flow) c.flow();
	    if (b.h > maxHeight) {
		maxHeight = b.h;
	    }	    
	    left += b.w;
	}
	for (var i = 0; i < row.length; i++) {
	    var c = row[i];
	    if (c._percEx.h) {
		c.bounds.h = maxHeight;
		c.renderBounds();
	    }
	}
	return maxHeight;
    },
    suggest: function(inContainer, inControl, ioRect) {

	var y = 0;
	for (var i=0, c; c=inContainer.c$[i]; i++) {
	    if (this.inFlow(c)) {
		if (ioRect.t < c.bounds.t + c.bounds.h / 2) {
		    y = c.bounds.t - 1;
		    break;
		}
		y = c.bounds.b;
		ioRect.control = c;
	    }
	}
	if (!ioRect.control) 
	    ioRect.control = inContainer;

	var containercoords = dojo.coords(inContainer.domNode);
	var coords = dojo.coords(ioRect.control.domNode);
	var styleBounds = inContainer.getStyleBounds();
	ioRect.l = containercoords.x;
	if (ioRect.control == inContainer) {
	    ioRect.t = coords.y;
	} else {
	    ioRect.t = coords.y + coords.h;
	}

	ioRect.w = styleBounds.w;
	ioRect.i = i;

    }
});

wm.layout.register("fluid", wm.layout.Fluid);
wm.layout.addCache("fluid", new wm.layout.Fluid());
*/

}

if(!dojo._hasResource["wm.base.widget.AppRoot"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.widget.AppRoot"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide("wm.base.widget.AppRoot");
dojo.declare("wm.AppRoot", wm.Container, {
    // useful properties
    classNames: 'wmapproot',
    width: "",
    height: "",
        deviceSize: "",
    create: function() {
        this.inherited(arguments);
        this.deviceSize = wm.deviceSize || this.calcDeviceSize(window.innerWidth || document.documentElement.clientWidth);
        app.valueChanged("deviceSize",this.deviceSize); // bindable event
    },
    build: function() {
        this.domNode = this.owner.domNode = dojo.byId(this.owner.domNode) || document.body;
        this.domNode.style.cssText += this.style + "overflow: hidden; position: relative;";
        dojo.attr(this.domNode, "role", "application");
    },
    init: function() {
        var domId = this.domNode.id;
        this.inherited(arguments);
        this.domNode.id = domId; /* using onorientationchange is unreliable for android browser; may need to re-review this */
        /* The Android browser shipped by google with 2.x devices can not find the width and height of the screen when the onorientationchange event fires, and
         * the result is a big gap in the margin of the page.  While a delay could be used, on a test device the delay was significant and unpredictable.
         *
         * WARNING: onresize may not be provided to android devices within phonegap applications.
         */
        this._isOldAndroidBrowser = (navigator.vendor || "").match(/Google/i) && navigator.userAgent.match(/android/i);
        if (!this._isOldAndroidBrowser && "onorientationchange" in window) {
            window.addEventListener("orientationchange", dojo.hitch(this, "resize"));
        } else {
            this.subscribe("window-resize", this, "resize");
        }

    },

    getRuntimeId: function() {return "approot";},

    /* Assumes that wavemaker app is the only thing on the page; some of these calculations fail if there is other html outside of the wavemakerNode */
    _onOrientationChange: function() {

        this._inResize = true;

        /* for iphone, screen.height is height including area taken by location bar; and innerHeight is area between location bar and bottom bar;
         */

        var width = Math.min(screen.width, window.innerWidth);
        var height = Math.min(screen.height, window.innerHeight);

        var max = Math.max(width, height);
        var min = Math.min(width, height);
        switch (window.orientation) {
        case 90:
        case -90:
        case 270:
            this.setBounds(null, null, max, min);
            if (app.appTitleBar) app.appTitleBar.hide();
            break;
        default:
            this.setBounds(null, null, min, max);
            if (app.appTitleBar) app.appTitleBar.show();
        }
        app.valueChanged("deviceSize", this.deviceSize); // bindable event
        dojo.publish("deviceSizeRecalc");
        this.reflow();
        this._inResize = false;
    },
    resize: function() {
        this._inResize = true;
        if (!wm.deviceSize) {// set from URL
        var deviceSize = this.deviceSize;
        this.updateBounds();
        this.deviceSize = this.calcDeviceSize(this.bounds.w);
        if (deviceSize != this.deviceSize) {
            app.valueChanged("deviceSize",this.deviceSize); // bindable event
            dojo.publish("deviceSizeRecalc");
        }
        }

        this.reflow();


        if (this._isOldAndroidBrowser && app.wmMinifiedDialogPanel) {
        app.wmMinifiedDialogPanel.hide();
        wm.onidle(app.wmMinifiedDialogPanel, "show");
        }
        this._inResize = false;
    },
    updateBounds: function() {
        this._percEx = {w:100, h: 100};
        var pn = this.domNode.parentNode;
        var width,height;

        if (window["PhoneGap"]) {
        height = Math.min(screen.height, window.innerHeight);
        pn.style.height = height + "px";
        width = Math.min(screen.width, window.innerWidth || 20000); // this is correct for Android 2.x devices, untested for other platforms
        } else if (wm.isIOS) {

        if (window.orientation == 90 || window.orientation == -90) {
            var min = Math.min(window.innerWidth, window.innerHeight);
            var max = Math.max(window.innerWidth, window.innerHeight);
            width = max;
            height = min;
        } else {
            height = Math.max(window.innerHeight, window.innerWidth); // don't assume width and height have updated since the last orientation change, just figure out width and height based on window.orientation = 0
            width = Math.min(window.innerHeight, window.innerWidth);
        }
        //pn.style.height = (height + 100) + "px"; // without that extra height, setting scrollTop will fail
        this.domNode.style.position = "relative";
        } else if (wm.device == "phone") {

        } else if (wm.isMobile) {
        pn.style.height = "100%";
        }

        if (wm.isMobile) {
        if (!width)
            width = Math.min(screen.width, window.innerWidth || 20000, pn.offsetWidth);
        if (!height)
            height = Math.min(screen.height, window.innerHeight || 20000, pn.offsetHeight || 1000);
        } else {
        width = pn.offsetWidth;
        height = pn.offsetHeight;
        }
        this.setBounds(0, 0, width, height);
    },
    forceRerenderComponents: function(wIn) {
    wm.forEachWidget(wIn, function(w) {
        w.invalidCss = true;
        w.renderCss();
    });
    },
    reflow: function() {
        if (this._cupdating)
        return;
        if (!this._inResize) {
        this.updateBounds();
        }
        this.renderBounds();

        // find out what the zoom level is
        if (window["getComputedStyle"]) {
        try {
            this.domNode.style.borderRight = "solid 1px transparent";
            var actualBorder = Number(window.getComputedStyle(this.domNode).getPropertyValue("border-right-width").replace(/px/,""));
            var oldZoomLevel = app._currentZoomLevel;
            app._currentZoomLevel = 1/actualBorder;
            if (app._currentZoomLevel == 1) app._currentZoomLevel = 0; // causes zoom level to be ignored if we have 1-1 relationship between real px and requested px
            if (oldZoomLevel && oldZoomLevel != app._currentZoomLevel) {
            this.forceRerenderComponents(this);
            var self = this;
            wm.forEachProperty(app.$, function(c) {
                if (c instanceof wm.Dialog) {
                self.forceRerenderComponents(c);
                }
            });
            wm.forEachProperty(wm.Page.byName, function(pageList) {
                dojo.forEach(pageList, function(page) {
                wm.forEachProperty(page.$, function(c) {
                    if (c instanceof wm.Dialog) {
                    self.forceRerenderComponents(c);
                    }
                });
                });
            });
            }

            this.domNode.style.borderRight = "solid 0px transparent";
            dojo.publish("BrowserZoomed");
        } catch(e) {}
        }
        this.inherited(arguments);
/*
        if (wm.isMobile) {
        // get rid of the location bar on any mobile browser that is in landscape mode
        // in an attempt to get a usable amount of height
        //document.body.scrollTop = (this.bounds.w > this.bounds.h) ? 1 : 0;
        }
        */
    },
    calcDeviceSize: function(width) {
    if (width >= 1800) {
        return "1800";
    } else if (width >= 1400) {
        return "1400";
    } else if (width >= 1150) {
        return "1150";
    } else if (width >= 900) {
        return "900";
    } else if (width >= 650) {
        return "650";
    } else if (width >= 450) {
        return "450";
    } else if (width >= 300) {
        return "300";
    } else {
        return "200";
    }
    }
});

}

if(!dojo._hasResource["wm.base.widget.Formatters"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.widget.Formatters"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide("wm.base.widget.Formatters");

// FIXME: need formatter registry
wm.formatters = [
    "Number",
    "Date",
    "Time",
    "DateTime",
    "Currency",
    "Array",
    //"Link",
    //"RegularExpression",
    //"Evaluation",
    //"Image",
    "Percent"
];

wm.getFormatter = function(inName) {
	var c = inName;
	if (c.slice(0, 5) != "wm")
		c = "wm." + c + "Formatter";
	return dojo.getObject(c) || wm.DataFormatter;
}

dojo.declare("wm.DataFormatter", wm.Component, {
	getColProps: function() {
		return {
			formatter: this.format
		}
	},
	format: function(inDatum) {
		return (inDatum !== undefined) ? inDatum : '&nbsp;';
	},
	valueChanged: function(inProp, inValue) {
		this.inherited(arguments);
		if (inProp)
			wm.fire(this.owner, "formatChanged");
	}
});

dojo.declare("wm.NumberFormatter", wm.DataFormatter, {
	digits: 0,
	locale: "",
	round: false,
	noFormat: false,
	// NB: called in 'cell' context
	format: function(inDatum) {
		return (inDatum === undefined) ? '-' : (this.wmNoFormat ? inDatum : dojo.number.format(inDatum, this.getFormatProps()));
	},
	getFormatProps: function() {
		return {
			places: Number(this.digits),
			locale: this.locale,
			round: this.round ? 0 : -1
		}
	},
	getColProps: function() {
		return {
			formatter: this.format,
			getFormatProps: dojo.hitch(this, "getFormatProps"),
			wmNoFormat: this.noFormat
		}
	}
});

dojo.declare("wm.CurrencyFormatter", wm.NumberFormatter, {
	digits: 2,
	currency: "",
	format: function(inDatum) {
		return (inDatum == undefined) ? '-' : dojo.currency.format(inDatum, this.getFormatProps());
	},
	getFormatProps: function() {
		var p = this.inherited(arguments);
	        p.currency = this.currency == "$" ? "USD" : this.currency || (this._isDesignLoaded ? studio.application.currencyLocale : app.currencyLocale) || "USD";
		return p;
	}
});

dojo.declare("wm.ArrayFormatter", wm.DataFormatter, {
	separator: ",",
	joinField: "dataValue",

	// NB: called in 'cell' context
	format: function(inDatum) {
		var str = "";
		if (inDatum) {
			if (inDatum instanceof wm.Variable) {
				inDatum.forEach(dojo.hitch(this, function(item) {
					if (str) str += this.separator + " ";
					str += item.getValue(this.joinField);
				}));
			} else {
				dojo.forEach(inDatum, function(item) {
					if (str) str += this.separator + " ";
					if (item instanceof wm.Variable) str += item.getValue(this.joinField);
					else str += item[this.joinField];
				}, this);
			}
		}
		return str;
	}
});

dojo.declare("wm.DateTimeFormatter", wm.DataFormatter, {
	useLocalTime: true,
	formatLength: "medium", // long, short, medium or full
	_selector: "",
	datePattern: "", // "M/d/yy",
	timePattern: "", // "h:m:s a",
	locale: "",
	// NB: called in 'cell' context
	format: function(inDatum) {
		var opts = {
			selector: this._selector,
			formatLength: this.formatLength,
			datePattern: this.datePattern,
			timePattern: this.timePattern,
			locale: this.locale
		}
		var d = new Date(inDatum);
		if (!this.useLocalTime) {
		    /* See WM-4490 to understand this calculation */
            var adjustSixHours = this._selector == "date"  ? 360 : 0;
            d.setHours(0, 60*d.getHours() + d.getMinutes() + 60*wm.timezoneOffset + adjustSixHours);
        }
		if (isNaN(d.getTime()))
			d = new Date(Number(inDatum));
		return (inDatum == undefined) || isNaN(d.getTime()) ? '-' : dojo.date.locale.format(d, opts);
	},
	getColProps: function() {
		return {
			_selector: this._selector,
			formatLength: this.formatLength,
			datePattern: this.datePattern,
			timePattern: this.timePattern,
			locale: this.locale,
			formatter: this.format
		}
	}
});

dojo.declare("wm.DateFormatter", wm.DateTimeFormatter, {
	_selector: "date",
	useLocalTime: false
});

dojo.declare("wm.TimeFormatter", wm.DateTimeFormatter, {
	_selector: "time"
});


dojo.declare("wm.PercentFormatter", wm.NumberFormatter, {
        divideBy100: false,
	getFormatProps: function() {
	   var p = this.inherited(arguments);
	   p.type = "percent";
	   return p;
	},
	format: function(inDatum) {
	inDatum = Number(inDatum);
	if (this.divideBy100) inDatum = inDatum/100;
	return this.inherited(arguments,[inDatum]);
	}
});

// design only...

wm.Object.extendSchema(wm.DataFormatter, {
    name: { ignore: 1 },
    diagnostics: {ignore:1}
});

wm.Object.extendSchema(wm.DateTimeFormatter, {
    formatLength: {options: ["short","medium","long","full"]}/*,
    useLocalTime: { ignore: 1 }*/
});

wm.Object.extendSchema(wm.DateFormatter, {
	timePattern: { ignore: 1 },
	useLocalTime: { ignore: 0 }
});

wm.Object.extendSchema(wm.TimeFormatter, {
	datePattern: { ignore: 1 }
});

}

if(!dojo._hasResource["dijit._base.focus"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.focus"] = true;
dojo.provide("dijit._base.focus");





// summary:
//		These functions are used to query or set the focus and selection.
//
//		Also, they trace when widgets become activated/deactivated,
//		so that the widget can fire _onFocus/_onBlur events.
//		"Active" here means something similar to "focused", but
//		"focus" isn't quite the right word because we keep track of
//		a whole stack of "active" widgets.  Example: ComboButton --> Menu -->
//		MenuItem.  The onBlur event for ComboButton doesn't fire due to focusing
//		on the Menu or a MenuItem, since they are considered part of the
//		ComboButton widget.  It only happens when focus is shifted
//		somewhere completely different.

dojo.mixin(dijit, {
	// _curFocus: DomNode
	//		Currently focused item on screen
	_curFocus: null,

	// _prevFocus: DomNode
	//		Previously focused item on screen
	_prevFocus: null,

	isCollapsed: function(){
		// summary:
		//		Returns true if there is no text selected
		return dijit.getBookmark().isCollapsed;
	},

	getBookmark: function(){
		// summary:
		//		Retrieves a bookmark that can be used with moveToBookmark to return to the same range
		var bm, rg, tg, sel = dojo.doc.selection, cf = dijit._curFocus;

		if(dojo.global.getSelection){
			//W3C Range API for selections.
			sel = dojo.global.getSelection();
			if(sel){
				if(sel.isCollapsed){
					tg = cf? cf.tagName : "";
					if(tg){
						//Create a fake rangelike item to restore selections.
						tg = tg.toLowerCase();
						if(tg == "textarea" ||
								(tg == "input" && (!cf.type || cf.type.toLowerCase() == "text"))){
							sel = {
								start: cf.selectionStart,
								end: cf.selectionEnd,
								node: cf,
								pRange: true
							};
							return {isCollapsed: (sel.end <= sel.start), mark: sel}; //Object.
						}
					}
					bm = {isCollapsed:true};
					if(sel.rangeCount){
						bm.mark = sel.getRangeAt(0).cloneRange();
					}
				}else{
					rg = sel.getRangeAt(0);
					bm = {isCollapsed: false, mark: rg.cloneRange()};
				}
			}
		}else if(sel){
			// If the current focus was a input of some sort and no selection, don't bother saving
			// a native bookmark.  This is because it causes issues with dialog/page selection restore.
			// So, we need to create psuedo bookmarks to work with.
			tg = cf ? cf.tagName : "";
			tg = tg.toLowerCase();
			if(cf && tg && (tg == "button" || tg == "textarea" || tg == "input")){
				if(sel.type && sel.type.toLowerCase() == "none"){
					return {
						isCollapsed: true,
						mark: null
					}
				}else{
					rg = sel.createRange();
					return {
						isCollapsed: rg.text && rg.text.length?false:true,
						mark: {
							range: rg,
							pRange: true
						}
					};
				}
			}
			bm = {};

			//'IE' way for selections.
			try{
				// createRange() throws exception when dojo in iframe
				//and nothing selected, see #9632
				rg = sel.createRange();
				bm.isCollapsed = !(sel.type == 'Text' ? rg.htmlText.length : rg.length);
			}catch(e){
				bm.isCollapsed = true;
				return bm;
			}
			if(sel.type.toUpperCase() == 'CONTROL'){
				if(rg.length){
					bm.mark=[];
					var i=0,len=rg.length;
					while(i<len){
						bm.mark.push(rg.item(i++));
					}
				}else{
					bm.isCollapsed = true;
					bm.mark = null;
				}
			}else{
				bm.mark = rg.getBookmark();
			}
		}else{
			console.warn("No idea how to store the current selection for this browser!");
		}
		return bm; // Object
	},

	moveToBookmark: function(/*Object*/bookmark){
		// summary:
		//		Moves current selection to a bookmark
		// bookmark:
		//		This should be a returned object from dijit.getBookmark()

		var _doc = dojo.doc,
			mark = bookmark.mark;
		if(mark){
			if(dojo.global.getSelection){
				//W3C Rangi API (FF, WebKit, Opera, etc)
				var sel = dojo.global.getSelection();
				if(sel && sel.removeAllRanges){
					if(mark.pRange){
						var r = mark;
						var n = r.node;
						n.selectionStart = r.start;
						n.selectionEnd = r.end;
					}else{
						sel.removeAllRanges();
						sel.addRange(mark);
					}
				}else{
					console.warn("No idea how to restore selection for this browser!");
				}
			}else if(_doc.selection && mark){
				//'IE' way.
				var rg;
				if(mark.pRange){
					rg = mark.range;
				}else if(dojo.isArray(mark)){
					rg = _doc.body.createControlRange();
					//rg.addElement does not have call/apply method, so can not call it directly
					//rg is not available in "range.addElement(item)", so can't use that either
					dojo.forEach(mark, function(n){
						rg.addElement(n);
					});
				}else{
					rg = _doc.body.createTextRange();
					rg.moveToBookmark(mark);
				}
				rg.select();
			}
		}
	},

	getFocus: function(/*Widget?*/ menu, /*Window?*/ openedForWindow){
		// summary:
		//		Called as getFocus(), this returns an Object showing the current focus
		//		and selected text.
		//
		//		Called as getFocus(widget), where widget is a (widget representing) a button
		//		that was just pressed, it returns where focus was before that button
		//		was pressed.   (Pressing the button may have either shifted focus to the button,
		//		or removed focus altogether.)   In this case the selected text is not returned,
		//		since it can't be accurately determined.
		//
		// menu: dijit._Widget or {domNode: DomNode} structure
		//		The button that was just pressed.  If focus has disappeared or moved
		//		to this button, returns the previous focus.  In this case the bookmark
		//		information is already lost, and null is returned.
		//
		// openedForWindow:
		//		iframe in which menu was opened
		//
		// returns:
		//		A handle to restore focus/selection, to be passed to `dijit.focus`
		var node = !dijit._curFocus || (menu && dojo.isDescendant(dijit._curFocus, menu.domNode)) ? dijit._prevFocus : dijit._curFocus;
		return {
			node: node,
			bookmark: (node == dijit._curFocus) && dojo.withGlobal(openedForWindow || dojo.global, dijit.getBookmark),
			openedForWindow: openedForWindow
		}; // Object
	},

	focus: function(/*Object || DomNode */ handle){
		// summary:
		//		Sets the focused node and the selection according to argument.
		//		To set focus to an iframe's content, pass in the iframe itself.
		// handle:
		//		object returned by get(), or a DomNode

		if(!handle){ return; }

		var node = "node" in handle ? handle.node : handle,		// because handle is either DomNode or a composite object
			bookmark = handle.bookmark,
			openedForWindow = handle.openedForWindow,
			collapsed = bookmark ? bookmark.isCollapsed : false;

		// Set the focus
		// Note that for iframe's we need to use the <iframe> to follow the parentNode chain,
		// but we need to set focus to iframe.contentWindow
		if(node){
			var focusNode = (node.tagName.toLowerCase() == "iframe") ? node.contentWindow : node;
			if(focusNode && focusNode.focus){
				try{
					// Gecko throws sometimes if setting focus is impossible,
					// node not displayed or something like that
					focusNode.focus();
				}catch(e){/*quiet*/}
			}
			dijit._onFocusNode(node);
		}

		// set the selection
		// do not need to restore if current selection is not empty
		// (use keyboard to select a menu item) or if previous selection was collapsed
		// as it may cause focus shift (Esp in IE).
		if(bookmark && dojo.withGlobal(openedForWindow || dojo.global, dijit.isCollapsed) && !collapsed){
			if(openedForWindow){
				openedForWindow.focus();
			}
			try{
				dojo.withGlobal(openedForWindow || dojo.global, dijit.moveToBookmark, null, [bookmark]);
			}catch(e2){
				/*squelch IE internal error, see http://trac.dojotoolkit.org/ticket/1984 */
			}
		}
	},

	// _activeStack: dijit._Widget[]
	//		List of currently active widgets (focused widget and it's ancestors)
	_activeStack: [],

	registerIframe: function(/*DomNode*/ iframe){
		// summary:
		//		Registers listeners on the specified iframe so that any click
		//		or focus event on that iframe (or anything in it) is reported
		//		as a focus/click event on the <iframe> itself.
		// description:
		//		Currently only used by editor.
		// returns:
		//		Handle to pass to unregisterIframe()
		return dijit.registerWin(iframe.contentWindow, iframe);
	},

	unregisterIframe: function(/*Object*/ handle){
		// summary:
		//		Unregisters listeners on the specified iframe created by registerIframe.
		//		After calling be sure to delete or null out the handle itself.
		// handle:
		//		Handle returned by registerIframe()

		dijit.unregisterWin(handle);
	},

	registerWin: function(/*Window?*/targetWindow, /*DomNode?*/ effectiveNode){
		// summary:
		//		Registers listeners on the specified window (either the main
		//		window or an iframe's window) to detect when the user has clicked somewhere
		//		or focused somewhere.
		// description:
		//		Users should call registerIframe() instead of this method.
		// targetWindow:
		//		If specified this is the window associated with the iframe,
		//		i.e. iframe.contentWindow.
		// effectiveNode:
		//		If specified, report any focus events inside targetWindow as
		//		an event on effectiveNode, rather than on evt.target.
		// returns:
		//		Handle to pass to unregisterWin()

		// TODO: make this function private in 2.0; Editor/users should call registerIframe(),

		var mousedownListener = function(evt){
			dijit._justMouseDowned = true;
			setTimeout(function(){ dijit._justMouseDowned = false; }, 0);
			
			// workaround weird IE bug where the click is on an orphaned node
			// (first time clicking a Select/DropDownButton inside a TooltipDialog)
			if(dojo.isIE && evt && evt.srcElement && evt.srcElement.parentNode == null){
				return;
			}

			dijit._onTouchNode(effectiveNode || evt.target || evt.srcElement, "mouse");
		};
		//dojo.connect(targetWindow, "onscroll", ???);

		// Listen for blur and focus events on targetWindow's document.
		// IIRC, I'm using attachEvent() rather than dojo.connect() because focus/blur events don't bubble
		// through dojo.connect(), and also maybe to catch the focus events early, before onfocus handlers
		// fire.
		// Connect to <html> (rather than document) on IE to avoid memory leaks, but document on other browsers because
		// (at least for FF) the focus event doesn't fire on <html> or <body>.
		var doc = dojo.isIE ? targetWindow.document.documentElement : targetWindow.document;
		if(doc){
			if(dojo.isIE){
				targetWindow.document.body.attachEvent('onmousedown', mousedownListener);
				var activateListener = function(evt){
					// IE reports that nodes like <body> have gotten focus, even though they have tabIndex=-1,
					// Should consider those more like a mouse-click than a focus....
					if(evt.srcElement.tagName.toLowerCase() != "#document" &&
						dijit.isTabNavigable(evt.srcElement)){
						dijit._onFocusNode(effectiveNode || evt.srcElement);
					}else{
						dijit._onTouchNode(effectiveNode || evt.srcElement);
					}
				};
				doc.attachEvent('onactivate', activateListener);
				var deactivateListener =  function(evt){
					dijit._onBlurNode(effectiveNode || evt.srcElement);
				};
				doc.attachEvent('ondeactivate', deactivateListener);

				return function(){
					targetWindow.document.detachEvent('onmousedown', mousedownListener);
					doc.detachEvent('onactivate', activateListener);
					doc.detachEvent('ondeactivate', deactivateListener);
					doc = null;	// prevent memory leak (apparent circular reference via closure)
				};
			}else{
				doc.body.addEventListener('mousedown', mousedownListener, true);
				var focusListener = function(evt){
					dijit._onFocusNode(effectiveNode || evt.target);
				};
				doc.addEventListener('focus', focusListener, true);
				var blurListener = function(evt){
					dijit._onBlurNode(effectiveNode || evt.target);
				};
				doc.addEventListener('blur', blurListener, true);

				return function(){
					doc.body.removeEventListener('mousedown', mousedownListener, true);
					doc.removeEventListener('focus', focusListener, true);
					doc.removeEventListener('blur', blurListener, true);
					doc = null;	// prevent memory leak (apparent circular reference via closure)
				};
			}
		}
	},

	unregisterWin: function(/*Handle*/ handle){
		// summary:
		//		Unregisters listeners on the specified window (either the main
		//		window or an iframe's window) according to handle returned from registerWin().
		//		After calling be sure to delete or null out the handle itself.

		// Currently our handle is actually a function
		handle && handle();
	},

	_onBlurNode: function(/*DomNode*/ node){
		// summary:
		// 		Called when focus leaves a node.
		//		Usually ignored, _unless_ it *isn't* follwed by touching another node,
		//		which indicates that we tabbed off the last field on the page,
		//		in which case every widget is marked inactive
		dijit._prevFocus = dijit._curFocus;
		dijit._curFocus = null;

		if(dijit._justMouseDowned){
			// the mouse down caused a new widget to be marked as active; this blur event
			// is coming late, so ignore it.
			return;
		}

		// if the blur event isn't followed by a focus event then mark all widgets as inactive.
		if(dijit._clearActiveWidgetsTimer){
			clearTimeout(dijit._clearActiveWidgetsTimer);
		}
		dijit._clearActiveWidgetsTimer = setTimeout(function(){
			delete dijit._clearActiveWidgetsTimer;
			dijit._setStack([]);
			dijit._prevFocus = null;
		}, 100);
	},

	_onTouchNode: function(/*DomNode*/ node, /*String*/ by){
		// summary:
		//		Callback when node is focused or mouse-downed
		// node:
		//		The node that was touched.
		// by:
		//		"mouse" if the focus/touch was caused by a mouse down event

		// ignore the recent blurNode event
		if(dijit._clearActiveWidgetsTimer){
			clearTimeout(dijit._clearActiveWidgetsTimer);
			delete dijit._clearActiveWidgetsTimer;
		}

		// compute stack of active widgets (ex: ComboButton --> Menu --> MenuItem)
		var newStack=[];
		try{
			while(node){
				var popupParent = dojo.attr(node, "dijitPopupParent");
				if(popupParent){
					node=dijit.byId(popupParent).domNode;
				}else if(node.tagName && node.tagName.toLowerCase() == "body"){
					// is this the root of the document or just the root of an iframe?
					if(node === dojo.body()){
						// node is the root of the main document
						break;
					}
					// otherwise, find the iframe this node refers to (can't access it via parentNode,
					// need to do this trick instead). window.frameElement is supported in IE/FF/Webkit
					node=dojo.window.get(node.ownerDocument).frameElement;
				}else{
					// if this node is the root node of a widget, then add widget id to stack,
					// except ignore clicks on disabled widgets (actually focusing a disabled widget still works,
					// to support MenuItem)
					var id = node.getAttribute && node.getAttribute("widgetId"),
						widget = id && dijit.byId(id);
					if(widget && !(by == "mouse" && widget.get("disabled"))){
						newStack.unshift(id);
					}
					node=node.parentNode;
				}
			}
		}catch(e){ /* squelch */ }

		dijit._setStack(newStack, by);
	},

	_onFocusNode: function(/*DomNode*/ node){
		// summary:
		//		Callback when node is focused

		if(!node){
			return;
		}

		if(node.nodeType == 9){
			// Ignore focus events on the document itself.  This is here so that
			// (for example) clicking the up/down arrows of a spinner
			// (which don't get focus) won't cause that widget to blur. (FF issue)
			return;
		}

		dijit._onTouchNode(node);

		if(node == dijit._curFocus){ return; }
		if(dijit._curFocus){
			dijit._prevFocus = dijit._curFocus;
		}
		dijit._curFocus = node;
		dojo.publish("focusNode", [node]);
	},

	_setStack: function(/*String[]*/ newStack, /*String*/ by){
		// summary:
		//		The stack of active widgets has changed.  Send out appropriate events and records new stack.
		// newStack:
		//		array of widget id's, starting from the top (outermost) widget
		// by:
		//		"mouse" if the focus/touch was caused by a mouse down event

		var oldStack = dijit._activeStack;
		dijit._activeStack = newStack;

		// compare old stack to new stack to see how many elements they have in common
		for(var nCommon=0; nCommon<Math.min(oldStack.length, newStack.length); nCommon++){
			if(oldStack[nCommon] != newStack[nCommon]){
				break;
			}
		}

		var widget;
		// for all elements that have gone out of focus, send blur event
		for(var i=oldStack.length-1; i>=nCommon; i--){
			widget = dijit.byId(oldStack[i]);
			if(widget){
				widget._focused = false;
				widget.set("focused", false);
				widget._hasBeenBlurred = true;
				if(widget._onBlur){
					widget._onBlur(by);
				}
				dojo.publish("widgetBlur", [widget, by]);
			}
		}

		// for all element that have come into focus, send focus event
		for(i=nCommon; i<newStack.length; i++){
			widget = dijit.byId(newStack[i]);
			if(widget){
				widget._focused = true;
				widget.set("focused", true);
				if(widget._onFocus){
					widget._onFocus(by);
				}
				dojo.publish("widgetFocus", [widget, by]);
			}
		}
	}
});

// register top window and all the iframes it contains
dojo.addOnLoad(function(){
	var handle = dijit.registerWin(window);
	if(dojo.isIE){
		dojo.addOnWindowUnload(function(){
			dijit.unregisterWin(handle);
			handle = null;
		})
	}
});

}

if(!dojo._hasResource["dojo.AdapterRegistry"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.AdapterRegistry"] = true;
dojo.provide("dojo.AdapterRegistry");



dojo.AdapterRegistry = function(/*Boolean?*/ returnWrappers){
	//	summary:
	//		A registry to make contextual calling/searching easier.
	//	description:
	//		Objects of this class keep list of arrays in the form [name, check,
	//		wrap, directReturn] that are used to determine what the contextual
	//		result of a set of checked arguments is. All check/wrap functions
	//		in this registry should be of the same arity.
	//	example:
	//	|	// create a new registry
	//	|	var reg = new dojo.AdapterRegistry();
	//	|	reg.register("handleString",
	//	|		dojo.isString,
	//	|		function(str){
	//	|			// do something with the string here
	//	|		}
	//	|	);
	//	|	reg.register("handleArr",
	//	|		dojo.isArray,
	//	|		function(arr){
	//	|			// do something with the array here
	//	|		}
	//	|	);
	//	|
	//	|	// now we can pass reg.match() *either* an array or a string and
	//	|	// the value we pass will get handled by the right function
	//	|	reg.match("someValue"); // will call the first function
	//	|	reg.match(["someValue"]); // will call the second

	this.pairs = [];
	this.returnWrappers = returnWrappers || false; // Boolean
};

dojo.extend(dojo.AdapterRegistry, {
	register: function(/*String*/ name, /*Function*/ check, /*Function*/ wrap, /*Boolean?*/ directReturn, /*Boolean?*/ override){
		//	summary:
		//		register a check function to determine if the wrap function or
		//		object gets selected
		//	name:
		//		a way to identify this matcher.
		//	check:
		//		a function that arguments are passed to from the adapter's
		//		match() function.  The check function should return true if the
		//		given arguments are appropriate for the wrap function.
		//	directReturn:
		//		If directReturn is true, the value passed in for wrap will be
		//		returned instead of being called. Alternately, the
		//		AdapterRegistry can be set globally to "return not call" using
		//		the returnWrappers property. Either way, this behavior allows
		//		the registry to act as a "search" function instead of a
		//		function interception library.
		//	override:
		//		If override is given and true, the check function will be given
		//		highest priority. Otherwise, it will be the lowest priority
		//		adapter.
		this.pairs[((override) ? "unshift" : "push")]([name, check, wrap, directReturn]);
	},

	match: function(/* ... */){
		// summary:
		//		Find an adapter for the given arguments. If no suitable adapter
		//		is found, throws an exception. match() accepts any number of
		//		arguments, all of which are passed to all matching functions
		//		from the registered pairs.
		for(var i = 0; i < this.pairs.length; i++){
			var pair = this.pairs[i];
			if(pair[1].apply(this, arguments)){
				if((pair[3])||(this.returnWrappers)){
					return pair[2];
				}else{
					return pair[2].apply(this, arguments);
				}
			}
		}
		throw new Error("No match found");
	},

	unregister: function(name){
		// summary: Remove a named adapter from the registry

		// FIXME: this is kind of a dumb way to handle this. On a large
		// registry this will be slow-ish and we can use the name as a lookup
		// should we choose to trade memory for speed.
		for(var i = 0; i < this.pairs.length; i++){
			var pair = this.pairs[i];
			if(pair[0] == name){
				this.pairs.splice(i, 1);
				return true;
			}
		}
		return false;
	}
});

}

if(!dojo._hasResource["dijit._base.place"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.place"] = true;
dojo.provide("dijit._base.place");





dijit.getViewport = function(){
	// summary:
	//		Returns the dimensions and scroll position of the viewable area of a browser window

	return dojo.window.getBox();
};

/*=====
dijit.__Position = function(){
	// x: Integer
	//		horizontal coordinate in pixels, relative to document body
	// y: Integer
	//		vertical coordinate in pixels, relative to document body

	thix.x = x;
	this.y = y;
}
=====*/


dijit.placeOnScreen = function(
	/* DomNode */			node,
	/* dijit.__Position */	pos,
	/* String[] */			corners,
	/* dijit.__Position? */	padding){
	// summary:
	//		Positions one of the node's corners at specified position
	//		such that node is fully visible in viewport.
	// description:
	//		NOTE: node is assumed to be absolutely or relatively positioned.
	//	pos:
	//		Object like {x: 10, y: 20}
	//	corners:
	//		Array of Strings representing order to try corners in, like ["TR", "BL"].
	//		Possible values are:
	//			* "BL" - bottom left
	//			* "BR" - bottom right
	//			* "TL" - top left
	//			* "TR" - top right
	//	padding:
	//		set padding to put some buffer around the element you want to position.
	// example:
	//		Try to place node's top right corner at (10,20).
	//		If that makes node go (partially) off screen, then try placing
	//		bottom left corner at (10,20).
	//	|	placeOnScreen(node, {x: 10, y: 20}, ["TR", "BL"])

	var choices = dojo.map(corners, function(corner){
		var c = { corner: corner, pos: {x:pos.x,y:pos.y} };
		if(padding){
			c.pos.x += corner.charAt(1) == 'L' ? padding.x : -padding.x;
			c.pos.y += corner.charAt(0) == 'T' ? padding.y : -padding.y;
		}
		return c;
	});

	return dijit._place(node, choices);
}

dijit._place = function(/*DomNode*/ node, choices, layoutNode, /*Object*/ aroundNodeCoords){
	// summary:
	//		Given a list of spots to put node, put it at the first spot where it fits,
	//		of if it doesn't fit anywhere then the place with the least overflow
	// choices: Array
	//		Array of elements like: {corner: 'TL', pos: {x: 10, y: 20} }
	//		Above example says to put the top-left corner of the node at (10,20)
	// layoutNode: Function(node, aroundNodeCorner, nodeCorner, size)
	//		for things like tooltip, they are displayed differently (and have different dimensions)
	//		based on their orientation relative to the parent.   This adjusts the popup based on orientation.
	//		It also passes in the available size for the popup, which is useful for tooltips to
	//		tell them that their width is limited to a certain amount.   layoutNode() may return a value expressing
	//		how much the popup had to be modified to fit into the available space.   This is used to determine
	//		what the best placement is.
	// aroundNodeCoords: Object
	//		Size of aroundNode, ex: {w: 200, h: 50}

	// get {x: 10, y: 10, w: 100, h:100} type obj representing position of
	// viewport over document
	var view = dojo.window.getBox();

	// This won't work if the node is inside a <div style="position: relative">,
	// so reattach it to dojo.doc.body.   (Otherwise, the positioning will be wrong
	// and also it might get cutoff)
	if(!node.parentNode || String(node.parentNode.tagName).toLowerCase() != "body"){
		dojo.body().appendChild(node);
	}

	var best = null;
	dojo.some(choices, function(choice){
		var corner = choice.corner;
		var pos = choice.pos;
		var overflow = 0;

		// calculate amount of space available given specified position of node
		var spaceAvailable = {
			w: corner.charAt(1) == 'L' ? (view.l + view.w) - pos.x : pos.x - view.l,
			h: corner.charAt(1) == 'T' ? (view.t + view.h) - pos.y : pos.y - view.t
		};

		// configure node to be displayed in given position relative to button
		// (need to do this in order to get an accurate size for the node, because
		// a tooltip's size changes based on position, due to triangle)
		if(layoutNode){
			var res = layoutNode(node, choice.aroundCorner, corner, spaceAvailable, aroundNodeCoords);
			overflow = typeof res == "undefined" ? 0 : res;
		}

		// get node's size
		var style = node.style;
		var oldDisplay = style.display;
		var oldVis = style.visibility;
		style.visibility = "hidden";
		style.display = "";
		var mb = dojo.marginBox(node);
		style.display = oldDisplay;
		style.visibility = oldVis;

		// coordinates and size of node with specified corner placed at pos,
		// and clipped by viewport
		var startX = Math.max(view.l, corner.charAt(1) == 'L' ? pos.x : (pos.x - mb.w)),
			startY = Math.max(view.t, corner.charAt(0) == 'T' ? pos.y : (pos.y - mb.h)),
			endX = Math.min(view.l + view.w, corner.charAt(1) == 'L' ? (startX + mb.w) : pos.x),
			endY = Math.min(view.t + view.h, corner.charAt(0) == 'T' ? (startY + mb.h) : pos.y),
			width = endX - startX,
			height = endY - startY;

		overflow += (mb.w - width) + (mb.h - height);

		if(best == null || overflow < best.overflow){
			best = {
				corner: corner,
				aroundCorner: choice.aroundCorner,
				x: startX,
				y: startY,
				w: width,
				h: height,
				overflow: overflow,
				spaceAvailable: spaceAvailable
			};
		}
		
		return !overflow;
	});

	// In case the best position is not the last one we checked, need to call
	// layoutNode() again.
	if(best.overflow && layoutNode){
		layoutNode(node, best.aroundCorner, best.corner, best.spaceAvailable, aroundNodeCoords);
	}

	// And then position the node.   Do this last, after the layoutNode() above
	// has sized the node, due to browser quirks when the viewport is scrolled
	// (specifically that a Tooltip will shrink to fit as though the window was
	// scrolled to the left).
	//
	// In RTL mode, set style.right rather than style.left so in the common case,
	// window resizes move the popup along with the aroundNode.
	var l = dojo._isBodyLtr(),
		s = node.style;
	s.top = best.y + "px";
	s[l ? "left" : "right"] = (l ? best.x : view.w - best.x - best.w) + "px";
	
	return best;
}

dijit.placeOnScreenAroundNode = function(
	/* DomNode */		node,
	/* DomNode */		aroundNode,
	/* Object */		aroundCorners,
	/* Function? */		layoutNode){

	// summary:
	//		Position node adjacent or kitty-corner to aroundNode
	//		such that it's fully visible in viewport.
	//
	// description:
	//		Place node such that corner of node touches a corner of
	//		aroundNode, and that node is fully visible.
	//
	// aroundCorners:
	//		Ordered list of pairs of corners to try matching up.
	//		Each pair of corners is represented as a key/value in the hash,
	//		where the key corresponds to the aroundNode's corner, and
	//		the value corresponds to the node's corner:
	//
	//	|	{ aroundNodeCorner1: nodeCorner1, aroundNodeCorner2: nodeCorner2, ...}
	//
	//		The following strings are used to represent the four corners:
	//			* "BL" - bottom left
	//			* "BR" - bottom right
	//			* "TL" - top left
	//			* "TR" - top right
	//
	// layoutNode: Function(node, aroundNodeCorner, nodeCorner)
	//		For things like tooltip, they are displayed differently (and have different dimensions)
	//		based on their orientation relative to the parent.   This adjusts the popup based on orientation.
	//
	// example:
	//	|	dijit.placeOnScreenAroundNode(node, aroundNode, {'BL':'TL', 'TR':'BR'});
	//		This will try to position node such that node's top-left corner is at the same position
	//		as the bottom left corner of the aroundNode (ie, put node below
	//		aroundNode, with left edges aligned).  If that fails it will try to put
	// 		the bottom-right corner of node where the top right corner of aroundNode is
	//		(ie, put node above aroundNode, with right edges aligned)
	//

	// get coordinates of aroundNode
	aroundNode = dojo.byId(aroundNode);
	var aroundNodePos = dojo.position(aroundNode, true);

	// place the node around the calculated rectangle
	return dijit._placeOnScreenAroundRect(node,
		aroundNodePos.x, aroundNodePos.y, aroundNodePos.w, aroundNodePos.h,	// rectangle
		aroundCorners, layoutNode);
};

/*=====
dijit.__Rectangle = function(){
	// x: Integer
	//		horizontal offset in pixels, relative to document body
	// y: Integer
	//		vertical offset in pixels, relative to document body
	// width: Integer
	//		width in pixels
	// height: Integer
	//		height in pixels

	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;
}
=====*/


dijit.placeOnScreenAroundRectangle = function(
	/* DomNode */			node,
	/* dijit.__Rectangle */	aroundRect,
	/* Object */			aroundCorners,
	/* Function */			layoutNode){

	// summary:
	//		Like dijit.placeOnScreenAroundNode(), except that the "around"
	//		parameter is an arbitrary rectangle on the screen (x, y, width, height)
	//		instead of a dom node.

	return dijit._placeOnScreenAroundRect(node,
		aroundRect.x, aroundRect.y, aroundRect.width, aroundRect.height,	// rectangle
		aroundCorners, layoutNode);
};

dijit._placeOnScreenAroundRect = function(
	/* DomNode */		node,
	/* Number */		x,
	/* Number */		y,
	/* Number */		width,
	/* Number */		height,
	/* Object */		aroundCorners,
	/* Function */		layoutNode){

	// summary:
	//		Like dijit.placeOnScreenAroundNode(), except it accepts coordinates
	//		of a rectangle to place node adjacent to.

	// TODO: combine with placeOnScreenAroundRectangle()

	// Generate list of possible positions for node
	var choices = [];
	for(var nodeCorner in aroundCorners){
		choices.push( {
			aroundCorner: nodeCorner,
			corner: aroundCorners[nodeCorner],
			pos: {
				x: x + (nodeCorner.charAt(1) == 'L' ? 0 : width),
				y: y + (nodeCorner.charAt(0) == 'T' ? 0 : height)
			}
		});
	}

	return dijit._place(node, choices, layoutNode, {w: width, h: height});
};

dijit.placementRegistry= new dojo.AdapterRegistry();
dijit.placementRegistry.register("node",
	function(n, x){
		return typeof x == "object" &&
			typeof x.offsetWidth != "undefined" && typeof x.offsetHeight != "undefined";
	},
	dijit.placeOnScreenAroundNode);
dijit.placementRegistry.register("rect",
	function(n, x){
		return typeof x == "object" &&
			"x" in x && "y" in x && "width" in x && "height" in x;
	},
	dijit.placeOnScreenAroundRectangle);

dijit.placeOnScreenAroundElement = function(
	/* DomNode */		node,
	/* Object */		aroundElement,
	/* Object */		aroundCorners,
	/* Function */		layoutNode){

	// summary:
	//		Like dijit.placeOnScreenAroundNode(), except it accepts an arbitrary object
	//		for the "around" argument and finds a proper processor to place a node.

	return dijit.placementRegistry.match.apply(dijit.placementRegistry, arguments);
};

dijit.getPopupAroundAlignment = function(/*Array*/ position, /*Boolean*/ leftToRight){
	// summary:
	//		Transforms the passed array of preferred positions into a format suitable for passing as the aroundCorners argument to dijit.placeOnScreenAroundElement.
	//
	// position: String[]
	//		This variable controls the position of the drop down.
	//		It's an array of strings with the following values:
	//
	//			* before: places drop down to the left of the target node/widget, or to the right in
	//			  the case of RTL scripts like Hebrew and Arabic
	//			* after: places drop down to the right of the target node/widget, or to the left in
	//			  the case of RTL scripts like Hebrew and Arabic
	//			* above: drop down goes above target node
	//			* below: drop down goes below target node
	//
	//		The list is positions is tried, in order, until a position is found where the drop down fits
	//		within the viewport.
	//
	// leftToRight: Boolean
	//		Whether the popup will be displaying in leftToRight mode.
	//
	var align = {};
	dojo.forEach(position, function(pos){
		switch(pos){
			case "after":
				align[leftToRight ? "BR" : "BL"] = leftToRight ? "BL" : "BR";
				break;
			case "before":
				align[leftToRight ? "BL" : "BR"] = leftToRight ? "BR" : "BL";
				break;
			case "below-alt":
				leftToRight = !leftToRight;
				// fall through
			case "below":
				// first try to align left borders, next try to align right borders (or reverse for RTL mode)
				align[leftToRight ? "BL" : "BR"] = leftToRight ? "TL" : "TR";
				align[leftToRight ? "BR" : "BL"] = leftToRight ? "TR" : "TL";
				break;
			case "above-alt":
				leftToRight = !leftToRight;
				// fall through
			case "above":
			default:
				// first try to align left borders, next try to align right borders (or reverse for RTL mode)
				align[leftToRight ? "TL" : "TR"] = leftToRight ? "BL" : "BR";
				align[leftToRight ? "TR" : "TL"] = leftToRight ? "BR" : "BL";
				break;
		}
	});
	return align;
};

}

if(!dojo._hasResource["dijit._base.window"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.window"] = true;
dojo.provide("dijit._base.window");




dijit.getDocumentWindow = function(doc){
	return dojo.window.get(doc);
};

}

if(!dojo._hasResource["dijit._base.popup"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.popup"] = true;
dojo.provide("dijit._base.popup");






/*=====
dijit.popup.__OpenArgs = function(){
	// popup: Widget
	//		widget to display
	// parent: Widget
	//		the button etc. that is displaying this popup
	// around: DomNode
	//		DOM node (typically a button); place popup relative to this node.  (Specify this *or* "x" and "y" parameters.)
	// x: Integer
	//		Absolute horizontal position (in pixels) to place node at.  (Specify this *or* "around" parameter.)
	// y: Integer
	//		Absolute vertical position (in pixels) to place node at.  (Specify this *or* "around" parameter.)
	// orient: Object|String
	//		When the around parameter is specified, orient should be an
	//		ordered list of tuples of the form (around-node-corner, popup-node-corner).
	//		dijit.popup.open() tries to position the popup according to each tuple in the list, in order,
	//		until the popup appears fully within the viewport.
	//
	//		The default value is {BL:'TL', TL:'BL'}, which represents a list of two tuples:
	//			1. (BL, TL)
	//			2. (TL, BL)
	//		where BL means "bottom left" and "TL" means "top left".
	//		So by default, it first tries putting the popup below the around node, left-aligning them,
	//		and then tries to put it above the around node, still left-aligning them.   Note that the
	//		default is horizontally reversed when in RTL mode.
	//
	//		When an (x,y) position is specified rather than an around node, orient is either
	//		"R" or "L".  R (for right) means that it tries to put the popup to the right of the mouse,
	//		specifically positioning the popup's top-right corner at the mouse position, and if that doesn't
	//		fit in the viewport, then it tries, in order, the bottom-right corner, the top left corner,
	//		and the top-right corner.
	// onCancel: Function
	//		callback when user has canceled the popup by
	//			1. hitting ESC or
	//			2. by using the popup widget's proprietary cancel mechanism (like a cancel button in a dialog);
	//			   i.e. whenever popupWidget.onCancel() is called, args.onCancel is called
	// onClose: Function
	//		callback whenever this popup is closed
	// onExecute: Function
	//		callback when user "executed" on the popup/sub-popup by selecting a menu choice, etc. (top menu only)
	// padding: dijit.__Position
	//		adding a buffer around the opening position. This is only useful when around is not set.
	this.popup = popup;
	this.parent = parent;
	this.around = around;
	this.x = x;
	this.y = y;
	this.orient = orient;
	this.onCancel = onCancel;
	this.onClose = onClose;
	this.onExecute = onExecute;
	this.padding = padding;
}
=====*/

dijit.popup = {
	// summary:
	//		This singleton is used to show/hide widgets as popups.

	// _stack: dijit._Widget[]
	//		Stack of currently popped up widgets.
	//		(someone opened _stack[0], and then it opened _stack[1], etc.)
	_stack: [],
	
	// _beginZIndex: Number
	//		Z-index of the first popup.   (If first popup opens other
	//		popups they get a higher z-index.)
	_beginZIndex: 1000,

	_idGen: 1,

	_createWrapper: function(/*Widget || DomNode*/ widget){
		// summary:
		//		Initialization for widgets that will be used as popups.
		//		Puts widget inside a wrapper DIV (if not already in one),
		//		and returns pointer to that wrapper DIV.

		var wrapper = widget.declaredClass ? widget._popupWrapper : (widget.parentNode && dojo.hasClass(widget.parentNode, "dijitPopup")),
			node = widget.domNode || widget;

		if(!wrapper){
			// Create wrapper <div> for when this widget [in the future] will be used as a popup.
			// This is done early because of IE bugs where creating/moving DOM nodes causes focus
			// to go wonky, see tests/robot/Toolbar.html to reproduce
			wrapper = dojo.create("div",{
				"class":"dijitPopup",
				style:{ display: "none"},
				role: "presentation"
			}, dojo.body());
			wrapper.appendChild(node);

			var s = node.style;
			s.display = "";
			s.visibility = "";
			s.position = "";
			s.top = "0px";

			if(widget.declaredClass){		// TODO: in 2.0 change signature to always take widget, then remove if()
				widget._popupWrapper = wrapper;
				dojo.connect(widget, "destroy", function(){
					dojo.destroy(wrapper);
					delete widget._popupWrapper;
				});
			}
		}
		
		return wrapper;
	},

	moveOffScreen: function(/*Widget || DomNode*/ widget){
		// summary:
		//		Moves the popup widget off-screen.
		//		Do not use this method to hide popups when not in use, because
		//		that will create an accessibility issue: the offscreen popup is
		//		still in the tabbing order.

		// Create wrapper if not already there
		var wrapper = this._createWrapper(widget);

		dojo.style(wrapper, {
			visibility: "hidden",
			top: "-9999px",		// prevent transient scrollbar causing misalign (#5776), and initial flash in upper left (#10111)
			display: ""
		});
	},

	hide: function(/*dijit._Widget*/ widget){
		// summary:
		//		Hide this popup widget (until it is ready to be shown).
		//		Initialization for widgets that will be used as popups
		//
		// 		Also puts widget inside a wrapper DIV (if not already in one)
		//
		//		If popup widget needs to layout it should
		//		do so when it is made visible, and popup._onShow() is called.

		// Create wrapper if not already there
		var wrapper = this._createWrapper(widget);

		dojo.style(wrapper, "display", "none");
	},
		
	getTopPopup: function(){
		// summary:
		//		Compute the closest ancestor popup that's *not* a child of another popup.
		//		Ex: For a TooltipDialog with a button that spawns a tree of menus, find the popup of the button.
		var stack = this._stack;
		for(var pi=stack.length-1; pi > 0 && stack[pi].parent === stack[pi-1].widget; pi--){
			/* do nothing, just trying to get right value for pi */
		}
		return stack[pi];
	},

	open: function(/*dijit.popup.__OpenArgs*/ args){
		// summary:
		//		Popup the widget at the specified position
		//
		// example:
		//		opening at the mouse position
		//		|		dijit.popup.open({popup: menuWidget, x: evt.pageX, y: evt.pageY});
		//
		// example:
		//		opening the widget as a dropdown
		//		|		dijit.popup.open({parent: this, popup: menuWidget, around: this.domNode, onClose: function(){...}});
		//
		//		Note that whatever widget called dijit.popup.open() should also listen to its own _onBlur callback
		//		(fired from _base/focus.js) to know that focus has moved somewhere else and thus the popup should be closed.

		var stack = this._stack,
			widget = args.popup,
			orient = args.orient || (
				(args.parent ? args.parent.isLeftToRight() : dojo._isBodyLtr()) ?
				{'BL':'TL', 'BR':'TR', 'TL':'BL', 'TR':'BR'} :
				{'BR':'TR', 'BL':'TL', 'TR':'BR', 'TL':'BL'}
			),
			around = args.around,
			id = (args.around && args.around.id) ? (args.around.id+"_dropdown") : ("popup_"+this._idGen++);

		// If we are opening a new popup that isn't a child of a currently opened popup, then
		// close currently opened popup(s).   This should happen automatically when the old popups
		// gets the _onBlur() event, except that the _onBlur() event isn't reliable on IE, see [22198].
		while(stack.length && (!args.parent || !dojo.isDescendant(args.parent.domNode, stack[stack.length-1].widget.domNode))){
			dijit.popup.close(stack[stack.length-1].widget);
		}

		// Get pointer to popup wrapper, and create wrapper if it doesn't exist
		var wrapper = this._createWrapper(widget);


		dojo.attr(wrapper, {
			id: id,
			style: {
				zIndex: this._beginZIndex + stack.length
			},
			"class": "dijitPopup " + (widget.baseClass || widget["class"] || "").split(" ")[0] +"Popup",
			dijitPopupParent: args.parent ? args.parent.id : ""
		});

		if(dojo.isIE || dojo.isMoz){
			if(!widget.bgIframe){
				// setting widget.bgIframe triggers cleanup in _Widget.destroy()
				widget.bgIframe = new dijit.BackgroundIframe(wrapper);
			}
		}

		// position the wrapper node and make it visible
		var best = around ?
			dijit.placeOnScreenAroundElement(wrapper, around, orient, widget.orient ? dojo.hitch(widget, "orient") : null) :
			dijit.placeOnScreen(wrapper, args, orient == 'R' ? ['TR','BR','TL','BL'] : ['TL','BL','TR','BR'], args.padding);

		wrapper.style.display = "";
		wrapper.style.visibility = "visible";
		widget.domNode.style.visibility = "visible";	// counteract effects from _HasDropDown

		var handlers = [];

		// provide default escape and tab key handling
		// (this will work for any widget, not just menu)
		handlers.push(dojo.connect(wrapper, "onkeypress", this, function(evt){
			if(evt.charOrCode == dojo.keys.ESCAPE && args.onCancel){
				dojo.stopEvent(evt);
				args.onCancel();
			}else if(evt.charOrCode === dojo.keys.TAB){
				dojo.stopEvent(evt);
				var topPopup = this.getTopPopup();
				if(topPopup && topPopup.onCancel){
					topPopup.onCancel();
				}
			}
		}));

		// watch for cancel/execute events on the popup and notify the caller
		// (for a menu, "execute" means clicking an item)
		if(widget.onCancel){
			handlers.push(dojo.connect(widget, "onCancel", args.onCancel));
		}

		handlers.push(dojo.connect(widget, widget.onExecute ? "onExecute" : "onChange", this, function(){
			var topPopup = this.getTopPopup();
			if(topPopup && topPopup.onExecute){
				topPopup.onExecute();
			}
		}));

		stack.push({
			widget: widget,
			parent: args.parent,
			onExecute: args.onExecute,
			onCancel: args.onCancel,
 			onClose: args.onClose,
			handlers: handlers
		});

		if(widget.onOpen){
			// TODO: in 2.0 standardize onShow() (used by StackContainer) and onOpen() (used here)
			widget.onOpen(best);
		}

		return best;
	},

	close: function(/*dijit._Widget?*/ popup){
		// summary:
		//		Close specified popup and any popups that it parented.
		//		If no popup is specified, closes all popups.

		var stack = this._stack;

		// Basically work backwards from the top of the stack closing popups
		// until we hit the specified popup, but IIRC there was some issue where closing
		// a popup would cause others to close too.  Thus if we are trying to close B in [A,B,C]
		// closing C might close B indirectly and then the while() condition will run where stack==[A]...
		// so the while condition is constructed defensively.
		while((popup && dojo.some(stack, function(elem){return elem.widget == popup;})) ||
			(!popup && stack.length)){
			var top = stack.pop(),
				widget = top.widget,
				onClose = top.onClose;

			if(widget.onClose){
				// TODO: in 2.0 standardize onHide() (used by StackContainer) and onClose() (used here)
				widget.onClose();
			}
			dojo.forEach(top.handlers, dojo.disconnect);

			// Hide the widget and it's wrapper unless it has already been destroyed in above onClose() etc.
			if(widget && widget.domNode){
				this.hide(widget);
			}
                        
			if(onClose){
				onClose();
			}
		}
	}
};

// TODO: remove dijit._frames, it isn't being used much, since popups never release their
// iframes (see [22236])
dijit._frames = new function(){
	// summary:
	//		cache of iframes

	var queue = [];

	this.pop = function(){
		var iframe;
		if(queue.length){
			iframe = queue.pop();
			iframe.style.display="";
		}else{
			if(dojo.isIE < 9){
				var burl = dojo.config["dojoBlankHtmlUrl"] || (dojo.moduleUrl("dojo", "resources/blank.html")+"") || "javascript:\"\"";
				var html="<iframe src='" + burl + "'"
					+ " style='position: absolute; left: 0px; top: 0px;"
					+ "z-index: -1; filter:Alpha(Opacity=\"0\");'>";
				iframe = dojo.doc.createElement(html);
			}else{
			 	iframe = dojo.create("iframe");
				iframe.src = 'javascript:""';
				iframe.className = "dijitBackgroundIframe";
				dojo.style(iframe, "opacity", 0.1);
			}
			iframe.tabIndex = -1; // Magic to prevent iframe from getting focus on tab keypress - as style didn't work.
			dijit.setWaiRole(iframe,"presentation");
		}
		return iframe;
	};

	this.push = function(iframe){
		iframe.style.display="none";
		queue.push(iframe);
	}
}();


dijit.BackgroundIframe = function(/*DomNode*/ node){
	// summary:
	//		For IE/FF z-index schenanigans. id attribute is required.
	//
	// description:
	//		new dijit.BackgroundIframe(node)
	//			Makes a background iframe as a child of node, that fills
	//			area (and position) of node

	if(!node.id){ throw new Error("no id"); }
	if(dojo.isIE || dojo.isMoz){
		var iframe = (this.iframe = dijit._frames.pop());
		node.appendChild(iframe);
		if(dojo.isIE<7 || dojo.isQuirks){
			this.resize(node);
			this._conn = dojo.connect(node, 'onresize', this, function(){
				this.resize(node);
			});
		}else{
			dojo.style(iframe, {
				width: '100%',
				height: '100%'
			});
		}
	}
};

dojo.extend(dijit.BackgroundIframe, {
	resize: function(node){
		// summary:
		// 		Resize the iframe so it's the same size as node.
		//		Needed on IE6 and IE/quirks because height:100% doesn't work right.
		if(this.iframe){
			dojo.style(this.iframe, {
				width: node.offsetWidth + 'px',
				height: node.offsetHeight + 'px'
			});
		}
	},
	destroy: function(){
		// summary:
		//		destroy the iframe
		if(this._conn){
			dojo.disconnect(this._conn);
			this._conn = null;
		}
		if(this.iframe){
			dijit._frames.push(this.iframe);
			delete this.iframe;
		}
	}
});

}

if(!dojo._hasResource["dijit._base.scroll"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.scroll"] = true;
dojo.provide("dijit._base.scroll");




dijit.scrollIntoView = function(/*DomNode*/ node, /*Object?*/ pos){
	// summary:
	//		Scroll the passed node into view, if it is not already.
	//		Deprecated, use `dojo.window.scrollIntoView` instead.
	
	dojo.window.scrollIntoView(node, pos);
};

}

if(!dojo._hasResource["dojo.uacss"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.uacss"] = true;
dojo.provide("dojo.uacss");



(function(){
	// summary:
	//		Applies pre-set CSS classes to the top-level HTML node, based on:
	// 			- browser (ex: dj_ie)
	//			- browser version (ex: dj_ie6)
	//			- box model (ex: dj_contentBox)
	//			- text direction (ex: dijitRtl)
	//
	//		In addition, browser, browser version, and box model are
	//		combined with an RTL flag when browser text is RTL.  ex: dj_ie-rtl.

	var d = dojo,
		html = d.doc.documentElement,
		ie = d.isIE,
		opera = d.isOpera,
		maj = Math.floor,
		ff = d.isFF,
		boxModel = d.boxModel.replace(/-/,''),

		classes = {
			dj_ie: ie,
			dj_ie6: maj(ie) == 6,
			dj_ie7: maj(ie) == 7,
			dj_ie8: maj(ie) == 8,
			dj_ie9: maj(ie) == 9,
			dj_quirks: d.isQuirks,
			dj_iequirks: ie && d.isQuirks,

			// NOTE: Opera not supported by dijit
			dj_opera: opera,

			dj_khtml: d.isKhtml,

			dj_webkit: d.isWebKit,
			dj_safari: d.isSafari,
			dj_chrome: d.isChrome,

			dj_gecko: d.isMozilla,
			dj_ff3: maj(ff) == 3
		}; // no dojo unsupported browsers

	classes["dj_" + boxModel] = true;

	// apply browser, browser version, and box model class names
	var classStr = "";
	for(var clz in classes){
		if(classes[clz]){
			classStr += clz + " ";
		}
	}
	html.className = d.trim(html.className + " " + classStr);

	// If RTL mode, then add dj_rtl flag plus repeat existing classes with -rtl extension.
	// We can't run the code below until the <body> tag has loaded (so we can check for dir=rtl).
	// Unshift() is to run sniff code before the parser.
	dojo._loaders.unshift(function(){
		if(!dojo._isBodyLtr()){
			var rtlClassStr = "dj_rtl dijitRtl " + classStr.replace(/ /g, "-rtl ")
			html.className = d.trim(html.className + " " + rtlClassStr);
		}
	});
})();

}

if(!dojo._hasResource["dijit._base.sniff"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.sniff"] = true;
dojo.provide("dijit._base.sniff");




// summary:
//		Applies pre-set CSS classes to the top-level HTML node, see
//		`dojo.uacss` for details.
//
//		Simply doing a require on this module will
//		establish this CSS.  Modified version of Morris' CSS hack.

}

if(!dojo._hasResource["dijit._base.typematic"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.typematic"] = true;
dojo.provide("dijit._base.typematic");



dijit.typematic = {
	// summary:
	//		These functions are used to repetitively call a user specified callback
	//		method when a specific key or mouse click over a specific DOM node is
	//		held down for a specific amount of time.
	//		Only 1 such event is allowed to occur on the browser page at 1 time.

	_fireEventAndReload: function(){
		this._timer = null;
		this._callback(++this._count, this._node, this._evt);
		
		// Schedule next event, timer is at most minDelay (default 10ms) to avoid
		// browser overload (particularly avoiding starving DOH robot so it never gets to send a mouseup)
		this._currentTimeout = Math.max(
			this._currentTimeout < 0 ? this._initialDelay :
				(this._subsequentDelay > 1 ? this._subsequentDelay : Math.round(this._currentTimeout * this._subsequentDelay)),
			this._minDelay);
		this._timer = setTimeout(dojo.hitch(this, "_fireEventAndReload"), this._currentTimeout);
	},

	trigger: function(/*Event*/ evt, /*Object*/ _this, /*DOMNode*/ node, /*Function*/ callback, /*Object*/ obj, /*Number*/ subsequentDelay, /*Number*/ initialDelay, /*Number?*/ minDelay){
		// summary:
		//		Start a timed, repeating callback sequence.
		//		If already started, the function call is ignored.
		//		This method is not normally called by the user but can be
		//		when the normal listener code is insufficient.
		// evt:
		//		key or mouse event object to pass to the user callback
		// _this:
		//		pointer to the user's widget space.
		// node:
		//		the DOM node object to pass the the callback function
		// callback:
		//		function to call until the sequence is stopped called with 3 parameters:
		// count:
		//		integer representing number of repeated calls (0..n) with -1 indicating the iteration has stopped
		// node:
		//		the DOM node object passed in
		// evt:
		//		key or mouse event object
		// obj:
		//		user space object used to uniquely identify each typematic sequence
		// subsequentDelay (optional):
		//		if > 1, the number of milliseconds until the 3->n events occur
		//		or else the fractional time multiplier for the next event's delay, default=0.9
		// initialDelay (optional):
		//		the number of milliseconds until the 2nd event occurs, default=500ms
		// minDelay (optional):
		//		the maximum delay in milliseconds for event to fire, default=10ms
		if(obj != this._obj){
			this.stop();
			this._initialDelay = initialDelay || 500;
			this._subsequentDelay = subsequentDelay || 0.90;
			this._minDelay = minDelay || 10;
			this._obj = obj;
			this._evt = evt;
			this._node = node;
			this._currentTimeout = -1;
			this._count = -1;
			this._callback = dojo.hitch(_this, callback);
			this._fireEventAndReload();
			this._evt = dojo.mixin({faux: true}, evt);
		}
	},

	stop: function(){
		// summary:
		//		Stop an ongoing timed, repeating callback sequence.
		if(this._timer){
			clearTimeout(this._timer);
			this._timer = null;
		}
		if(this._obj){
			this._callback(-1, this._node, this._evt);
			this._obj = null;
		}
	},

	addKeyListener: function(/*DOMNode*/ node, /*Object*/ keyObject, /*Object*/ _this, /*Function*/ callback, /*Number*/ subsequentDelay, /*Number*/ initialDelay, /*Number?*/ minDelay){
		// summary:
		//		Start listening for a specific typematic key.
		//		See also the trigger method for other parameters.
		// keyObject:
		//		an object defining the key to listen for:
		// 		charOrCode:
		//			the printable character (string) or keyCode (number) to listen for.
		// 		keyCode:
		//			(deprecated - use charOrCode) the keyCode (number) to listen for (implies charCode = 0).
		// 		charCode:
		//			(deprecated - use charOrCode) the charCode (number) to listen for.
		// 		ctrlKey:
		//			desired ctrl key state to initiate the callback sequence:
		//			- pressed (true)
		//			- released (false)
		//			- either (unspecified)
		// 		altKey:
		//			same as ctrlKey but for the alt key
		// 		shiftKey:
		//			same as ctrlKey but for the shift key
		// returns:
		//		an array of dojo.connect handles
		if(keyObject.keyCode){
			keyObject.charOrCode = keyObject.keyCode;
			dojo.deprecated("keyCode attribute parameter for dijit.typematic.addKeyListener is deprecated. Use charOrCode instead.", "", "2.0");
		}else if(keyObject.charCode){
			keyObject.charOrCode = String.fromCharCode(keyObject.charCode);
			dojo.deprecated("charCode attribute parameter for dijit.typematic.addKeyListener is deprecated. Use charOrCode instead.", "", "2.0");
		}
		return [
			dojo.connect(node, "onkeypress", this, function(evt){
				if(evt.charOrCode == keyObject.charOrCode &&
				(keyObject.ctrlKey === undefined || keyObject.ctrlKey == evt.ctrlKey) &&
				(keyObject.altKey === undefined || keyObject.altKey == evt.altKey) &&
				(keyObject.metaKey === undefined || keyObject.metaKey == (evt.metaKey || false)) && // IE doesn't even set metaKey
				(keyObject.shiftKey === undefined || keyObject.shiftKey == evt.shiftKey)){
					dojo.stopEvent(evt);
					dijit.typematic.trigger(evt, _this, node, callback, keyObject, subsequentDelay, initialDelay, minDelay);
				}else if(dijit.typematic._obj == keyObject){
					dijit.typematic.stop();
				}
			}),
			dojo.connect(node, "onkeyup", this, function(evt){
				if(dijit.typematic._obj == keyObject){
					dijit.typematic.stop();
				}
			})
		];
	},

	addMouseListener: function(/*DOMNode*/ node, /*Object*/ _this, /*Function*/ callback, /*Number*/ subsequentDelay, /*Number*/ initialDelay, /*Number?*/ minDelay){
		// summary:
		//		Start listening for a typematic mouse click.
		//		See the trigger method for other parameters.
		// returns:
		//		an array of dojo.connect handles
		var dc = dojo.connect;
		return [
			dc(node, "mousedown", this, function(evt){
				dojo.stopEvent(evt);
				dijit.typematic.trigger(evt, _this, node, callback, node, subsequentDelay, initialDelay, minDelay);
			}),
			dc(node, "mouseup", this, function(evt){
				dojo.stopEvent(evt);
				dijit.typematic.stop();
			}),
			dc(node, "mouseout", this, function(evt){
				dojo.stopEvent(evt);
				dijit.typematic.stop();
			}),
			dc(node, "mousemove", this, function(evt){
				evt.preventDefault();
			}),
			dc(node, "dblclick", this, function(evt){
				dojo.stopEvent(evt);
				if(dojo.isIE){
					dijit.typematic.trigger(evt, _this, node, callback, node, subsequentDelay, initialDelay, minDelay);
					setTimeout(dojo.hitch(this, dijit.typematic.stop), 50);
				}
			})
		];
	},

	addListener: function(/*Node*/ mouseNode, /*Node*/ keyNode, /*Object*/ keyObject, /*Object*/ _this, /*Function*/ callback, /*Number*/ subsequentDelay, /*Number*/ initialDelay, /*Number?*/ minDelay){
		// summary:
		//		Start listening for a specific typematic key and mouseclick.
		//		This is a thin wrapper to addKeyListener and addMouseListener.
		//		See the addMouseListener and addKeyListener methods for other parameters.
		// mouseNode:
		//		the DOM node object to listen on for mouse events.
		// keyNode:
		//		the DOM node object to listen on for key events.
		// returns:
		//		an array of dojo.connect handles
		return this.addKeyListener(keyNode, keyObject, _this, callback, subsequentDelay, initialDelay, minDelay).concat(
			this.addMouseListener(mouseNode, _this, callback, subsequentDelay, initialDelay, minDelay));
	}
};

}

if(!dojo._hasResource["dijit._base.wai"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.wai"] = true;
dojo.provide("dijit._base.wai");



dijit.wai = {
	onload: function(){
		// summary:
		//		Detects if we are in high-contrast mode or not

		// This must be a named function and not an anonymous
		// function, so that the widget parsing code can make sure it
		// registers its onload function after this function.
		// DO NOT USE "this" within this function.

		// create div for testing if high contrast mode is on or images are turned off
		var div = dojo.create("div",{
			id: "a11yTestNode",
			style:{
				cssText:'border: 1px solid;'
					+ 'border-color:red green;'
					+ 'position: absolute;'
					+ 'height: 5px;'
					+ 'top: -999px;'
					+ 'background-image: url("' + (dojo.config.blankGif || dojo.moduleUrl("dojo", "resources/blank.gif")) + '");'
			}
		}, dojo.body());

		// test it
		var cs = dojo.getComputedStyle(div);
		if(cs){
			var bkImg = cs.backgroundImage;
			var needsA11y = (cs.borderTopColor == cs.borderRightColor) || (bkImg != null && (bkImg == "none" || bkImg == "url(invalid-url:)" ));
			dojo[needsA11y ? "addClass" : "removeClass"](dojo.body(), "dijit_a11y");
			if(dojo.isIE){
				div.outerHTML = "";		// prevent mixed-content warning, see http://support.microsoft.com/kb/925014
			}else{
				dojo.body().removeChild(div);
			}
		}
	}
};

// Test if computer is in high contrast mode.
// Make sure the a11y test runs first, before widgets are instantiated.
if(dojo.isIE || dojo.isMoz){	// NOTE: checking in Safari messes things up
	dojo._loaders.unshift(dijit.wai.onload);
}

dojo.mixin(dijit, {
	hasWaiRole: function(/*Element*/ elem, /*String?*/ role){
		// summary:
		//		Determines if an element has a particular role.
		// returns:
		//		True if elem has the specific role attribute and false if not.
		// 		For backwards compatibility if role parameter not provided,
		// 		returns true if has a role
		var waiRole = this.getWaiRole(elem);
		return role ? (waiRole.indexOf(role) > -1) : (waiRole.length > 0);
	},

	getWaiRole: function(/*Element*/ elem){
		// summary:
		//		Gets the role for an element (which should be a wai role).
		// returns:
		//		The role of elem or an empty string if elem
		//		does not have a role.
		 return dojo.trim((dojo.attr(elem, "role") || "").replace("wairole:",""));
	},

	setWaiRole: function(/*Element*/ elem, /*String*/ role){
		// summary:
		//		Sets the role on an element.
		// description:
		//		Replace existing role attribute with new role.

			dojo.attr(elem, "role", role);
	},

	removeWaiRole: function(/*Element*/ elem, /*String*/ role){
		// summary:
		//		Removes the specified role from an element.
		// 		Removes role attribute if no specific role provided (for backwards compat.)

		var roleValue = dojo.attr(elem, "role");
		if(!roleValue){ return; }
		if(role){
			var t = dojo.trim((" " + roleValue + " ").replace(" " + role + " ", " "));
			dojo.attr(elem, "role", t);
		}else{
			elem.removeAttribute("role");
		}
	},

	hasWaiState: function(/*Element*/ elem, /*String*/ state){
		// summary:
		//		Determines if an element has a given state.
		// description:
		//		Checks for an attribute called "aria-"+state.
		// returns:
		//		true if elem has a value for the given state and
		//		false if it does not.

		return elem.hasAttribute ? elem.hasAttribute("aria-"+state) : !!elem.getAttribute("aria-"+state);
	},

	getWaiState: function(/*Element*/ elem, /*String*/ state){
		// summary:
		//		Gets the value of a state on an element.
		// description:
		//		Checks for an attribute called "aria-"+state.
		// returns:
		//		The value of the requested state on elem
		//		or an empty string if elem has no value for state.

		return elem.getAttribute("aria-"+state) || "";
	},

	setWaiState: function(/*Element*/ elem, /*String*/ state, /*String*/ value){
		// summary:
		//		Sets a state on an element.
		// description:
		//		Sets an attribute called "aria-"+state.

		elem.setAttribute("aria-"+state, value);
	},

	removeWaiState: function(/*Element*/ elem, /*String*/ state){
		// summary:
		//		Removes a state from an element.
		// description:
		//		Sets an attribute called "aria-"+state.

		elem.removeAttribute("aria-"+state);
	}
});

}

if(!dojo._hasResource["dijit._base"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base"] = true;
dojo.provide("dijit._base");












}

if(!dojo._hasResource["dijit._Widget"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._Widget"] = true;
dojo.provide("dijit._Widget");






////////////////// DEFERRED CONNECTS ///////////////////

// This code is to assist deferring dojo.connect() calls in widgets (connecting to events on the widgets'
// DOM nodes) until someone actually needs to monitor that event.
dojo.connect(dojo, "_connect",
	function(/*dijit._Widget*/ widget, /*String*/ event){
		if(widget && dojo.isFunction(widget._onConnect)){
			widget._onConnect(event);
		}
	});

dijit._connectOnUseEventHandler = function(/*Event*/ event){};

////////////////// ONDIJITCLICK SUPPORT ///////////////////

// Keep track of where the last keydown event was, to help avoid generating
// spurious ondijitclick events when:
// 1. focus is on a <button> or <a>
// 2. user presses then releases the ENTER key
// 3. onclick handler fires and shifts focus to another node, with an ondijitclick handler
// 4. onkeyup event fires, causing the ondijitclick handler to fire
dijit._lastKeyDownNode = null;
if(dojo.isIE){
	(function(){
		var keydownCallback = function(evt){
			dijit._lastKeyDownNode = evt.srcElement;
		};
		dojo.doc.attachEvent('onkeydown', keydownCallback);
		dojo.addOnWindowUnload(function(){
			dojo.doc.detachEvent('onkeydown', keydownCallback);
		});
	})();
}else{
	dojo.doc.addEventListener('keydown', function(evt){
		dijit._lastKeyDownNode = evt.target;
	}, true);
}

(function(){

dojo.declare("dijit._Widget", dijit._WidgetBase, {
	// summary:
	//		Base class for all Dijit widgets.
	//
	//		Extends _WidgetBase, adding support for:
	//			- deferred connections
	//				A call like dojo.connect(myWidget, "onMouseMove", func)
	//				will essentially do a dojo.connect(myWidget.domNode, "onMouseMove", func)
	//			- ondijitclick
	//				Support new dojoAttachEvent="ondijitclick: ..." that is triggered by a mouse click or a SPACE/ENTER keypress
	//			- focus related functions
	//				In particular, the onFocus()/onBlur() callbacks.   Driven internally by
	//				dijit/_base/focus.js.
	//			- deprecated methods
	//			- onShow(), onHide(), onClose()
	//
	//		Also, by loading code in dijit/_base, turns on:
	//			- browser sniffing (putting browser id like .dj_ie on <html> node)
	//			- high contrast mode sniffing (add .dijit_a11y class to <body> if machine is in high contrast mode)
	

	////////////////// DEFERRED CONNECTS ///////////////////

	// _deferredConnects: [protected] Object
	//		attributeMap addendum for event handlers that should be connected only on first use
	_deferredConnects: {
		onClick: "",
		onDblClick: "",
		onKeyDown: "",
		onKeyPress: "",
		onKeyUp: "",
		onMouseMove: "",
		onMouseDown: "",
		onMouseOut: "",
		onMouseOver: "",
		onMouseLeave: "",
		onMouseEnter: "",
		onMouseUp: ""
	},

	onClick: dijit._connectOnUseEventHandler,
	/*=====
	onClick: function(event){
		// summary:
		//		Connect to this function to receive notifications of mouse click events.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onDblClick: dijit._connectOnUseEventHandler,
	/*=====
	onDblClick: function(event){
		// summary:
		//		Connect to this function to receive notifications of mouse double click events.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onKeyDown: dijit._connectOnUseEventHandler,
	/*=====
	onKeyDown: function(event){
		// summary:
		//		Connect to this function to receive notifications of keys being pressed down.
		// event:
		//		key Event
		// tags:
		//		callback
	},
	=====*/
	onKeyPress: dijit._connectOnUseEventHandler,
	/*=====
	onKeyPress: function(event){
		// summary:
		//		Connect to this function to receive notifications of printable keys being typed.
		// event:
		//		key Event
		// tags:
		//		callback
	},
	=====*/
	onKeyUp: dijit._connectOnUseEventHandler,
	/*=====
	onKeyUp: function(event){
		// summary:
		//		Connect to this function to receive notifications of keys being released.
		// event:
		//		key Event
		// tags:
		//		callback
	},
	=====*/
	onMouseDown: dijit._connectOnUseEventHandler,
	/*=====
	onMouseDown: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse button is pressed down.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseMove: dijit._connectOnUseEventHandler,
	/*=====
	onMouseMove: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves over nodes contained within this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseOut: dijit._connectOnUseEventHandler,
	/*=====
	onMouseOut: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves off of nodes contained within this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseOver: dijit._connectOnUseEventHandler,
	/*=====
	onMouseOver: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves onto nodes contained within this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseLeave: dijit._connectOnUseEventHandler,
	/*=====
	onMouseLeave: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves off of this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseEnter: dijit._connectOnUseEventHandler,
	/*=====
	onMouseEnter: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves onto this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseUp: dijit._connectOnUseEventHandler,
	/*=====
	onMouseUp: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse button is released.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/

	create: function(/*Object?*/params, /*DomNode|String?*/srcNodeRef){
		// To avoid double-connects, remove entries from _deferredConnects
		// that have been setup manually by a subclass (ex, by dojoAttachEvent).
		// If a subclass has redefined a callback (ex: onClick) then assume it's being
		// connected to manually.
		this._deferredConnects = dojo.clone(this._deferredConnects);
		for(var attr in this.attributeMap){
			delete this._deferredConnects[attr]; // can't be in both attributeMap and _deferredConnects
		}
		for(attr in this._deferredConnects){
			if(this[attr] !== dijit._connectOnUseEventHandler){
				delete this._deferredConnects[attr];	// redefined, probably dojoAttachEvent exists
			}
		}

		this.inherited(arguments);

		if(this.domNode){
			// If the developer has specified a handler as a widget parameter
			// (ex: new Button({onClick: ...})
			// then naturally need to connect from DOM node to that handler immediately,
			for(attr in this.params){
				this._onConnect(attr);
			}
		}
	},

	_onConnect: function(/*String*/ event){
		// summary:
		//		Called when someone connects to one of my handlers.
		//		"Turn on" that handler if it isn't active yet.
		//
		//		This is also called for every single initialization parameter
		//		so need to do nothing for parameters like "id".
		// tags:
		//		private
		if(event in this._deferredConnects){
			var mapNode = this[this._deferredConnects[event] || 'domNode'];
			this.connect(mapNode, event.toLowerCase(), event);
			delete this._deferredConnects[event];
		}
	},

	////////////////// FOCUS RELATED ///////////////////
	// _onFocus() and _onBlur() are called by the focus manager

	// focused: [readonly] Boolean
	//		This widget or a widget it contains has focus, or is "active" because
	//		it was recently clicked.
	focused: false,

	isFocusable: function(){
		// summary:
		//		Return true if this widget can currently be focused
		//		and false if not
		return this.focus && (dojo.style(this.domNode, "display") != "none");
	},

	onFocus: function(){
		// summary:
		//		Called when the widget becomes "active" because
		//		it or a widget inside of it either has focus, or has recently
		//		been clicked.
		// tags:
		//		callback
	},

	onBlur: function(){
		// summary:
		//		Called when the widget stops being "active" because
		//		focus moved to something outside of it, or the user
		//		clicked somewhere outside of it, or the widget was
		//		hidden.
		// tags:
		//		callback
	},

	_onFocus: function(e){
		// summary:
		//		This is where widgets do processing for when they are active,
		//		such as changing CSS classes.  See onFocus() for more details.
		// tags:
		//		protected
		this.onFocus();
	},

	_onBlur: function(){
		// summary:
		//		This is where widgets do processing for when they stop being active,
		//		such as changing CSS classes.  See onBlur() for more details.
		// tags:
		//		protected
		this.onBlur();
	},

	////////////////// DEPRECATED METHODS ///////////////////

	setAttribute: function(/*String*/ attr, /*anything*/ value){
		// summary:
		//		Deprecated.  Use set() instead.
		// tags:
		//		deprecated
		dojo.deprecated(this.declaredClass+"::setAttribute(attr, value) is deprecated. Use set() instead.", "", "2.0");
		this.set(attr, value);
	},

	attr: function(/*String|Object*/name, /*Object?*/value){
		// summary:
		//		Set or get properties on a widget instance.
		//	name:
		//		The property to get or set. If an object is passed here and not
		//		a string, its keys are used as names of attributes to be set
		//		and the value of the object as values to set in the widget.
		//	value:
		//		Optional. If provided, attr() operates as a setter. If omitted,
		//		the current value of the named property is returned.
		// description:
		//		This method is deprecated, use get() or set() directly.

		// Print deprecation warning but only once per calling function
		if(dojo.config.isDebug){
			var alreadyCalledHash = arguments.callee._ach || (arguments.callee._ach = {}),
				caller = (arguments.callee.caller || "unknown caller").toString();
			if(!alreadyCalledHash[caller]){
				dojo.deprecated(this.declaredClass + "::attr() is deprecated. Use get() or set() instead, called from " +
				caller, "", "2.0");
				alreadyCalledHash[caller] = true;
			}
		}

		var args = arguments.length;
		if(args >= 2 || typeof name === "object"){ // setter
			return this.set.apply(this, arguments);
		}else{ // getter
			return this.get(name);
		}
	},
	
	////////////////// ONDIJITCLICK SUPPORT ///////////////////

	// nodesWithKeyClick: [private] String[]
	//		List of nodes that correctly handle click events via native browser support,
	//		and don't need dijit's help
	nodesWithKeyClick: ["input", "button"],

	connect: function(
			/*Object|null*/ obj,
			/*String|Function*/ event,
			/*String|Function*/ method){
		// summary:
		//		Connects specified obj/event to specified method of this object
		//		and registers for disconnect() on widget destroy.
		// description:
		//		Provide widget-specific analog to dojo.connect, except with the
		//		implicit use of this widget as the target object.
		//		This version of connect also provides a special "ondijitclick"
		//		event which triggers on a click or space or enter keyup.
		//		Events connected with `this.connect` are disconnected upon
		//		destruction.
		// returns:
		//		A handle that can be passed to `disconnect` in order to disconnect before
		//		the widget is destroyed.
		// example:
		//	|	var btn = new dijit.form.Button();
		//	|	// when foo.bar() is called, call the listener we're going to
		//	|	// provide in the scope of btn
		//	|	btn.connect(foo, "bar", function(){
		//	|		console.debug(this.toString());
		//	|	});
		// tags:
		//		protected

		var d = dojo,
			dc = d._connect,
			handles = this.inherited(arguments, [obj, event == "ondijitclick" ? "onclick" : event, method]);

		if(event == "ondijitclick"){
			// add key based click activation for unsupported nodes.
			// do all processing onkey up to prevent spurious clicks
			// for details see comments at top of this file where _lastKeyDownNode is defined
			if(d.indexOf(this.nodesWithKeyClick, obj.nodeName.toLowerCase()) == -1){ // is NOT input or button
				var m = d.hitch(this, method);
				handles.push(
					dc(obj, "onkeydown", this, function(e){
						//console.log(this.id + ": onkeydown, e.target = ", e.target, ", lastKeyDownNode was ", dijit._lastKeyDownNode, ", equality is ", (e.target === dijit._lastKeyDownNode));
						if((e.keyCode == d.keys.ENTER || e.keyCode == d.keys.SPACE) &&
							!e.ctrlKey && !e.shiftKey && !e.altKey && !e.metaKey){
							// needed on IE for when focus changes between keydown and keyup - otherwise dropdown menus do not work
							dijit._lastKeyDownNode = e.target;
							
							// Stop event to prevent scrolling on space key in IE.
							// But don't do this for _HasDropDown because it surpresses the onkeypress
							// event needed to open the drop down when the user presses the SPACE key.
							if(!("openDropDown" in this && obj == this._buttonNode)){
								e.preventDefault();
							}
						}
			 		}),
					dc(obj, "onkeyup", this, function(e){
						//console.log(this.id + ": onkeyup, e.target = ", e.target, ", lastKeyDownNode was ", dijit._lastKeyDownNode, ", equality is ", (e.target === dijit._lastKeyDownNode));
						if( (e.keyCode == d.keys.ENTER || e.keyCode == d.keys.SPACE) &&
							e.target == dijit._lastKeyDownNode &&	// === breaks greasemonkey
							!e.ctrlKey && !e.shiftKey && !e.altKey && !e.metaKey){
								//need reset here or have problems in FF when focus returns to trigger element after closing popup/alert
								dijit._lastKeyDownNode = null;
								return m(e);
						}
					})
				);
			}
		}

		return handles;		// _Widget.Handle
	},

	////////////////// MISCELLANEOUS METHODS ///////////////////

	_onShow: function(){
		// summary:
		//		Internal method called when this widget is made visible.
		//		See `onShow` for details.
		this.onShow();
	},

	onShow: function(){
		// summary:
		//		Called when this widget becomes the selected pane in a
		//		`dijit.layout.TabContainer`, `dijit.layout.StackContainer`,
		//		`dijit.layout.AccordionContainer`, etc.
		//
		//		Also called to indicate display of a `dijit.Dialog`, `dijit.TooltipDialog`, or `dijit.TitlePane`.
		// tags:
		//		callback
	},

	onHide: function(){
		// summary:
			//		Called when another widget becomes the selected pane in a
			//		`dijit.layout.TabContainer`, `dijit.layout.StackContainer`,
			//		`dijit.layout.AccordionContainer`, etc.
			//
			//		Also called to indicate hide of a `dijit.Dialog`, `dijit.TooltipDialog`, or `dijit.TitlePane`.
			// tags:
			//		callback
	},

	onClose: function(){
		// summary:
		//		Called when this widget is being displayed as a popup (ex: a Calendar popped
		//		up from a DateTextBox), and it is hidden.
		//		This is called from the dijit.popup code, and should not be called directly.
		//
		//		Also used as a parameter for children of `dijit.layout.StackContainer` or subclasses.
		//		Callback if a user tries to close the child.   Child will be closed if this function returns true.
		// tags:
		//		extension

		return true;		// Boolean
	}
});

})();

}

if(!dojo._hasResource["dojo.cache"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.cache"] = true;
dojo.provide("dojo.cache");



/*=====
dojo.cache = {
	// summary:
	// 		A way to cache string content that is fetchable via `dojo.moduleUrl`.
};
=====*/

	var cache = {};
	dojo.cache = function(/*String||Object*/module, /*String*/url, /*String||Object?*/value){
		// summary:
		// 		A getter and setter for storing the string content associated with the
		// 		module and url arguments.
		// description:
		// 		module and url are used to call `dojo.moduleUrl()` to generate a module URL.
		// 		If value is specified, the cache value for the moduleUrl will be set to
		// 		that value. Otherwise, dojo.cache will fetch the moduleUrl and store it
		// 		in its internal cache and return that cached value for the URL. To clear
		// 		a cache value pass null for value. Since XMLHttpRequest (XHR) is used to fetch the
		// 		the URL contents, only modules on the same domain of the page can use this capability.
		// 		The build system can inline the cache values though, to allow for xdomain hosting.
		// module: String||Object
		// 		If a String, the module name to use for the base part of the URL, similar to module argument
		// 		to `dojo.moduleUrl`. If an Object, something that has a .toString() method that
		// 		generates a valid path for the cache item. For example, a dojo._Url object.
		// url: String
		// 		The rest of the path to append to the path derived from the module argument. If
		// 		module is an object, then this second argument should be the "value" argument instead.
		// value: String||Object?
		// 		If a String, the value to use in the cache for the module/url combination.
		// 		If an Object, it can have two properties: value and sanitize. The value property
		// 		should be the value to use in the cache, and sanitize can be set to true or false,
		// 		to indicate if XML declarations should be removed from the value and if the HTML
		// 		inside a body tag in the value should be extracted as the real value. The value argument
		// 		or the value property on the value argument are usually only used by the build system
		// 		as it inlines cache content.
		//	example:
		//		To ask dojo.cache to fetch content and store it in the cache (the dojo["cache"] style
		// 		of call is used to avoid an issue with the build system erroneously trying to intern
		// 		this example. To get the build system to intern your dojo.cache calls, use the
		// 		"dojo.cache" style of call):
		// 		|	//If template.html contains "<h1>Hello</h1>" that will be
		// 		|	//the value for the text variable.
		//		|	var text = dojo["cache"]("my.module", "template.html");
		//	example:
		//		To ask dojo.cache to fetch content and store it in the cache, and sanitize the input
		// 		 (the dojo["cache"] style of call is used to avoid an issue with the build system
		// 		erroneously trying to intern this example. To get the build system to intern your
		// 		dojo.cache calls, use the "dojo.cache" style of call):
		// 		|	//If template.html contains "<html><body><h1>Hello</h1></body></html>", the
		// 		|	//text variable will contain just "<h1>Hello</h1>".
		//		|	var text = dojo["cache"]("my.module", "template.html", {sanitize: true});
		//	example:
		//		Same example as previous, but demostrates how an object can be passed in as
		//		the first argument, then the value argument can then be the second argument.
		// 		|	//If template.html contains "<html><body><h1>Hello</h1></body></html>", the
		// 		|	//text variable will contain just "<h1>Hello</h1>".
		//		|	var text = dojo["cache"](new dojo._Url("my/module/template.html"), {sanitize: true});

		//Module could be a string, or an object that has a toString() method
		//that will return a useful path. If it is an object, then the "url" argument
		//will actually be the value argument.
		if(typeof module == "string"){
			var pathObj = dojo.moduleUrl(module, url);
		}else{
			pathObj = module;
			value = url;
		}
		var key = pathObj.toString();

		var val = value;
		if(value != undefined && !dojo.isString(value)){
			val = ("value" in value ? value.value : undefined);
		}

		var sanitize = value && value.sanitize ? true : false;

		if(typeof val == "string"){
			//We have a string, set cache value
			val = cache[key] = sanitize ? dojo.cache._sanitize(val) : val;
		}else if(val === null){
			//Remove cached value
			delete cache[key];
		}else{
			//Allow cache values to be empty strings. If key property does
			//not exist, fetch it.
			if(!(key in cache)){
				val = dojo._getText(key);
				cache[key] = sanitize ? dojo.cache._sanitize(val) : val;
			}
			val = cache[key];
		}
		return val; //String
	};

	dojo.cache._sanitize = function(/*String*/val){
		// summary:
		//		Strips <?xml ...?> declarations so that external SVG and XML
		// 		documents can be added to a document without worry. Also, if the string
		//		is an HTML document, only the part inside the body tag is returned.
		// description:
		// 		Copied from dijit._Templated._sanitizeTemplateString.
		if(val){
			val = val.replace(/^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im, "");
			var matches = val.match(/<body[^>]*>\s*([\s\S]+)\s*<\/body>/im);
			if(matches){
				val = matches[1];
			}
		}else{
			val = "";
		}
		return val; //String
	};

}

if(!dojo._hasResource["dijit._Templated"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._Templated"] = true;
dojo.provide("dijit._Templated");







dojo.declare("dijit._Templated",
	null,
	{
		// summary:
		//		Mixin for widgets that are instantiated from a template

		// templateString: [protected] String
		//		A string that represents the widget template. Pre-empts the
		//		templatePath. In builds that have their strings "interned", the
		//		templatePath is converted to an inline templateString, thereby
		//		preventing a synchronous network call.
		//
		//		Use in conjunction with dojo.cache() to load from a file.
		templateString: null,

		// templatePath: [protected deprecated] String
		//		Path to template (HTML file) for this widget relative to dojo.baseUrl.
		//		Deprecated: use templateString with dojo.cache() instead.
		templatePath: null,

		// widgetsInTemplate: [protected] Boolean
		//		Should we parse the template to find widgets that might be
		//		declared in markup inside it?  False by default.
		widgetsInTemplate: false,

		// skipNodeCache: [protected] Boolean
		//		If using a cached widget template node poses issues for a
		//		particular widget class, it can set this property to ensure
		//		that its template is always re-built from a string
		_skipNodeCache: false,

		// _earlyTemplatedStartup: Boolean
		//		A fallback to preserve the 1.0 - 1.3 behavior of children in
		//		templates having their startup called before the parent widget
		//		fires postCreate. Defaults to 'false', causing child widgets to
		//		have their .startup() called immediately before a parent widget
		//		.startup(), but always after the parent .postCreate(). Set to
		//		'true' to re-enable to previous, arguably broken, behavior.
		_earlyTemplatedStartup: false,

/*=====
		// _attachPoints: [private] String[]
		//		List of widget attribute names associated with dojoAttachPoint=... in the
		//		template, ex: ["containerNode", "labelNode"]
 		_attachPoints: [],
 =====*/

/*=====
		// _attachEvents: [private] Handle[]
		//		List of connections associated with dojoAttachEvent=... in the
		//		template
 		_attachEvents: [],
 =====*/

		constructor: function(){
			this._attachPoints = [];
			this._attachEvents = [];
		},

		_stringRepl: function(tmpl){
			// summary:
			//		Does substitution of ${foo} type properties in template string
			// tags:
			//		private
			var className = this.declaredClass, _this = this;
			// Cache contains a string because we need to do property replacement
			// do the property replacement
			return dojo.string.substitute(tmpl, this, function(value, key){
				if(key.charAt(0) == '!'){ value = dojo.getObject(key.substr(1), false, _this); }
				if(typeof value == "undefined"){ throw new Error(className+" template:"+key); } // a debugging aide
				if(value == null){ return ""; }

				// Substitution keys beginning with ! will skip the transform step,
				// in case a user wishes to insert unescaped markup, e.g. ${!foo}
				return key.charAt(0) == "!" ? value :
					// Safer substitution, see heading "Attribute values" in
					// http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.3.2
					value.toString().replace(/"/g,"&quot;"); //TODO: add &amp? use encodeXML method?
			}, this);
		},

		buildRendering: function(){
			// summary:
			//		Construct the UI for this widget from a template, setting this.domNode.
			// tags:
			//		protected

			// Lookup cached version of template, and download to cache if it
			// isn't there already.  Returns either a DomNode or a string, depending on
			// whether or not the template contains ${foo} replacement parameters.
			var cached = dijit._Templated.getCachedTemplate(this.templatePath, this.templateString, this._skipNodeCache);

			var node;
			if(dojo.isString(cached)){
				node = dojo._toDom(this._stringRepl(cached));
				if(node.nodeType != 1){
					// Flag common problems such as templates with multiple top level nodes (nodeType == 11)
					throw new Error("Invalid template: " + cached);
				}
			}else{
				// if it's a node, all we have to do is clone it
				node = cached.cloneNode(true);
			}

			this.domNode = node;

			// Call down to _Widget.buildRendering() to get base classes assigned
			// TODO: change the baseClass assignment to attributeMap
			this.inherited(arguments);

			// recurse through the node, looking for, and attaching to, our
			// attachment points and events, which should be defined on the template node.
			this._attachTemplateNodes(node);

			if(this.widgetsInTemplate){
				// Store widgets that we need to start at a later point in time
				var cw = (this._startupWidgets = dojo.parser.parse(node, {
					noStart: !this._earlyTemplatedStartup,
					template: true,
					inherited: {dir: this.dir, lang: this.lang},
					propsThis: this,	// so data-dojo-props of widgets in the template can reference "this" to refer to me
					scope: "dojo"	// even in multi-version mode templates use dojoType/data-dojo-type
				}));

				this._supportingWidgets = dijit.findWidgets(node);

				this._attachTemplateNodes(cw, function(n,p){
					return n[p];
				});
			}

			this._fillContent(this.srcNodeRef);
		},

		_fillContent: function(/*DomNode*/ source){
			// summary:
			//		Relocate source contents to templated container node.
			//		this.containerNode must be able to receive children, or exceptions will be thrown.
			// tags:
			//		protected
			var dest = this.containerNode;
			if(source && dest){
				while(source.hasChildNodes()){
					dest.appendChild(source.firstChild);
				}
			}
		},

		_attachTemplateNodes: function(rootNode, getAttrFunc){
			// summary:
			//		Iterate through the template and attach functions and nodes accordingly.
			//		Alternately, if rootNode is an array of widgets, then will process dojoAttachPoint
			//		etc. for those widgets.
			// description:
			//		Map widget properties and functions to the handlers specified in
			//		the dom node and it's descendants. This function iterates over all
			//		nodes and looks for these properties:
			//			* dojoAttachPoint
			//			* dojoAttachEvent
			//			* waiRole
			//			* waiState
			// rootNode: DomNode|Array[Widgets]
			//		the node to search for properties. All children will be searched.
			// getAttrFunc: Function?
			//		a function which will be used to obtain property for a given
			//		DomNode/Widget
			// tags:
			//		private

			getAttrFunc = getAttrFunc || function(n,p){ return n.getAttribute(p); };

			var nodes = dojo.isArray(rootNode) ? rootNode : (rootNode.all || rootNode.getElementsByTagName("*"));
			var x = dojo.isArray(rootNode) ? 0 : -1;
			for(; x<nodes.length; x++){
				var baseNode = (x == -1) ? rootNode : nodes[x];
				if(this.widgetsInTemplate && (getAttrFunc(baseNode, "dojoType") || getAttrFunc(baseNode, "data-dojo-type"))){
					continue;
				}
				// Process dojoAttachPoint
				var attachPoint = getAttrFunc(baseNode, "dojoAttachPoint") || getAttrFunc(baseNode, "data-dojo-attach-point");
				if(attachPoint){
					var point, points = attachPoint.split(/\s*,\s*/);
					while((point = points.shift())){
						if(dojo.isArray(this[point])){
							this[point].push(baseNode);
						}else{
							this[point]=baseNode;
						}
						this._attachPoints.push(point);
					}
				}

				// Process dojoAttachEvent
				var attachEvent = getAttrFunc(baseNode, "dojoAttachEvent") || getAttrFunc(baseNode, "data-dojo-attach-event");;
				if(attachEvent){
					// NOTE: we want to support attributes that have the form
					// "domEvent: nativeEvent; ..."
					var event, events = attachEvent.split(/\s*,\s*/);
					var trim = dojo.trim;
					while((event = events.shift())){
						if(event){
							var thisFunc = null;
							if(event.indexOf(":") != -1){
								// oh, if only JS had tuple assignment
								var funcNameArr = event.split(":");
								event = trim(funcNameArr[0]);
								thisFunc = trim(funcNameArr[1]);
							}else{
								event = trim(event);
							}
							if(!thisFunc){
								thisFunc = event;
							}
							this._attachEvents.push(this.connect(baseNode, event, thisFunc));
						}
					}
				}

				// waiRole, waiState
				// TODO: remove this in 2.0, templates are now using role=... and aria-XXX=... attributes directicly
				var role = getAttrFunc(baseNode, "waiRole");
				if(role){
					dijit.setWaiRole(baseNode, role);
				}
				var values = getAttrFunc(baseNode, "waiState");
				if(values){
					dojo.forEach(values.split(/\s*,\s*/), function(stateValue){
						if(stateValue.indexOf('-') != -1){
							var pair = stateValue.split('-');
							dijit.setWaiState(baseNode, pair[0], pair[1]);
						}
					});
				}
			}
		},

		startup: function(){
			dojo.forEach(this._startupWidgets, function(w){
				if(w && !w._started && w.startup){
					w.startup();
				}
			});
			this.inherited(arguments);
		},

		destroyRendering: function(){
			// Delete all attach points to prevent IE6 memory leaks.
			dojo.forEach(this._attachPoints, function(point){
				delete this[point];
			}, this);
			this._attachPoints = [];

			// And same for event handlers
			dojo.forEach(this._attachEvents, this.disconnect, this);
			this._attachEvents = [];
			
			this.inherited(arguments);
		}
	}
);

// key is either templatePath or templateString; object is either string or DOM tree
dijit._Templated._templateCache = {};

dijit._Templated.getCachedTemplate = function(templatePath, templateString, alwaysUseString){
	// summary:
	//		Static method to get a template based on the templatePath or
	//		templateString key
	// templatePath: String||dojo.uri.Uri
	//		The URL to get the template from.
	// templateString: String?
	//		a string to use in lieu of fetching the template from a URL. Takes precedence
	//		over templatePath
	// returns: Mixed
	//		Either string (if there are ${} variables that need to be replaced) or just
	//		a DOM tree (if the node can be cloned directly)

	// is it already cached?
	var tmplts = dijit._Templated._templateCache;
	var key = templateString || templatePath;
	var cached = tmplts[key];
	if(cached){
		try{
			// if the cached value is an innerHTML string (no ownerDocument) or a DOM tree created within the current document, then use the current cached value
			if(!cached.ownerDocument || cached.ownerDocument == dojo.doc){
				// string or node of the same document
				return cached;
			}
		}catch(e){ /* squelch */ } // IE can throw an exception if cached.ownerDocument was reloaded
		dojo.destroy(cached);
	}

	// If necessary, load template string from template path
	if(!templateString){
		templateString = dojo.cache(templatePath, {sanitize: true});
	}
	templateString = dojo.string.trim(templateString);

	if(alwaysUseString || templateString.match(/\$\{([^\}]+)\}/g)){
		// there are variables in the template so all we can do is cache the string
		return (tmplts[key] = templateString); //String
	}else{
		// there are no variables in the template so we can cache the DOM tree
		var node = dojo._toDom(templateString);
		if(node.nodeType != 1){
			throw new Error("Invalid template: " + templateString);
		}
		return (tmplts[key] = node); //Node
	}
};

if(dojo.isIE){
	dojo.addOnWindowUnload(function(){
		var cache = dijit._Templated._templateCache;
		for(var key in cache){
			var value = cache[key];
			if(typeof value == "object"){ // value is either a string or a DOM node template
				dojo.destroy(value);
			}
			delete cache[key];
		}
	});
}

// These arguments can be specified for widgets which are used in templates.
// Since any widget can be specified as sub widgets in template, mix it
// into the base widget class.  (This is a hack, but it's effective.)
dojo.extend(dijit._Widget,{
	dojoAttachEvent: "",
	dojoAttachPoint: "",
	waiRole: "",
	waiState:""
});

}

if(!dojo._hasResource["dijit._CssStateMixin"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._CssStateMixin"] = true;
dojo.provide("dijit._CssStateMixin");



dojo.declare("dijit._CssStateMixin", [], {
	// summary:
	//		Mixin for widgets to set CSS classes on the widget DOM nodes depending on hover/mouse press/focus
	//		state changes, and also higher-level state changes such becoming disabled or selected.
	//
	// description:
	//		By mixing this class into your widget, and setting the this.baseClass attribute, it will automatically
	//		maintain CSS classes on the widget root node (this.domNode) depending on hover,
	//		active, focus, etc. state.   Ex: with a baseClass of dijitButton, it will apply the classes
	//		dijitButtonHovered and dijitButtonActive, as the user moves the mouse over the widget and clicks it.
	//
	//		It also sets CSS like dijitButtonDisabled based on widget semantic state.
	//
	//		By setting the cssStateNodes attribute, a widget can also track events on subnodes (like buttons
	//		within the widget).

	// cssStateNodes: [protected] Object
	//		List of sub-nodes within the widget that need CSS classes applied on mouse hover/press and focus
	//.
	//		Each entry in the hash is a an attachpoint names (like "upArrowButton") mapped to a CSS class names
	//		(like "dijitUpArrowButton"). Example:
	//	|		{
	//	|			"upArrowButton": "dijitUpArrowButton",
	//	|			"downArrowButton": "dijitDownArrowButton"
	//	|		}
	//		The above will set the CSS class dijitUpArrowButton to the this.upArrowButton DOMNode when it
	//		is hovered, etc.
	cssStateNodes: {},

	// hovering: [readonly] Boolean
	//		True if cursor is over this widget
	hovering: false,
	
	// active: [readonly] Boolean
	//		True if mouse was pressed while over this widget, and hasn't been released yet
	active: false,

	_applyAttributes: function(){
		// This code would typically be in postCreate(), but putting in _applyAttributes() for
		// performance: so the class changes happen before DOM is inserted into the document.
		// Change back to postCreate() in 2.0.  See #11635.

		this.inherited(arguments);

		// Automatically monitor mouse events (essentially :hover and :active) on this.domNode
		dojo.forEach(["onmouseenter", "onmouseleave", "onmousedown"], function(e){
			this.connect(this.domNode, e, "_cssMouseEvent");
		}, this);
		
		// Monitoring changes to disabled, readonly, etc. state, and update CSS class of root node
		dojo.forEach(["disabled", "readOnly", "checked", "selected", "focused", "state", "hovering", "active"], function(attr){
			this.watch(attr, dojo.hitch(this, "_setStateClass"));
		}, this);

		// Events on sub nodes within the widget
		for(var ap in this.cssStateNodes){
			this._trackMouseState(this[ap], this.cssStateNodes[ap]);
		}
		// Set state initially; there's probably no hover/active/focus state but widget might be
		// disabled/readonly/checked/selected so we want to set CSS classes for those conditions.
		this._setStateClass();
	},

	_cssMouseEvent: function(/*Event*/ event){
		// summary:
		//	Sets hovering and active properties depending on mouse state,
		//	which triggers _setStateClass() to set appropriate CSS classes for this.domNode.

		if(!this.disabled){
			switch(event.type){
				case "mouseenter":
				case "mouseover":	// generated on non-IE browsers even though we connected to mouseenter
					this._set("hovering", true);
					this._set("active", this._mouseDown);
					break;

				case "mouseleave":
				case "mouseout":	// generated on non-IE browsers even though we connected to mouseleave
					this._set("hovering", false);
					this._set("active", false);
					break;

				case "mousedown" :
					this._set("active", true);
					this._mouseDown = true;
					// Set a global event to handle mouseup, so it fires properly
					// even if the cursor leaves this.domNode before the mouse up event.
					// Alternately could set active=false on mouseout.
					var mouseUpConnector = this.connect(dojo.body(), "onmouseup", function(){
						this._mouseDown = false;
						this._set("active", false);
						this.disconnect(mouseUpConnector);
					});
					break;
			}
		}
	},

	_setStateClass: function(){
		// summary:
		//		Update the visual state of the widget by setting the css classes on this.domNode
		//		(or this.stateNode if defined) by combining this.baseClass with
		//		various suffixes that represent the current widget state(s).
		//
		// description:
		//		In the case where a widget has multiple
		//		states, it sets the class based on all possible
		//	 	combinations.  For example, an invalid form widget that is being hovered
		//		will be "dijitInput dijitInputInvalid dijitInputHover dijitInputInvalidHover".
		//
		//		The widget may have one or more of the following states, determined
		//		by this.state, this.checked, this.valid, and this.selected:
		//			- Error - ValidationTextBox sets this.state to "Error" if the current input value is invalid
		//			- Incomplete - ValidationTextBox sets this.state to "Incomplete" if the current input value is not finished yet
		//			- Checked - ex: a checkmark or a ToggleButton in a checked state, will have this.checked==true
		//			- Selected - ex: currently selected tab will have this.selected==true
		//
		//		In addition, it may have one or more of the following states,
		//		based on this.disabled and flags set in _onMouse (this.active, this.hovering) and from focus manager (this.focused):
		//			- Disabled	- if the widget is disabled
		//			- Active		- if the mouse (or space/enter key?) is being pressed down
		//			- Focused		- if the widget has focus
		//			- Hover		- if the mouse is over the widget

		// Compute new set of classes
		var newStateClasses = this.baseClass.split(" ");

		function multiply(modifier){
			newStateClasses = newStateClasses.concat(dojo.map(newStateClasses, function(c){ return c+modifier; }), "dijit"+modifier);
		}

		if(!this.isLeftToRight()){
			// For RTL mode we need to set an addition class like dijitTextBoxRtl.
			multiply("Rtl");
		}

		if(this.checked){
			multiply("Checked");
		}
		if(this.state){
			multiply(this.state);
		}
		if(this.selected){
			multiply("Selected");
		}

		if(this.disabled){
			multiply("Disabled");
		}else if(this.readOnly){
			multiply("ReadOnly");
		}else{
			if(this.active){
				multiply("Active");
			}else if(this.hovering){
				multiply("Hover");
			}
		}

		if(this._focused){
			multiply("Focused");
		}

		// Remove old state classes and add new ones.
		// For performance concerns we only write into domNode.className once.
		var tn = this.stateNode || this.domNode,
			classHash = {};	// set of all classes (state and otherwise) for node

		dojo.forEach(tn.className.split(" "), function(c){ classHash[c] = true; });

		if("_stateClasses" in this){
			dojo.forEach(this._stateClasses, function(c){ delete classHash[c]; });
		}

		dojo.forEach(newStateClasses, function(c){ classHash[c] = true; });

		var newClasses = [];
		for(var c in classHash){
			newClasses.push(c);
		}

    /* Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved. Licensed under the Apache License 2.0 - http://www.apache.org/licenses/LICENSE-2.0 
     * WaveMaker: Added test before setting because this class change causes editors (in chrome) to scroll back to position 0 each class change, so only change
     * when required. 
     */
	    var newClass = newClasses.join(" ");
	    if (tn.className != newClass) {
	        tn.className = newClass;
	    }
/* End changes */
		this._stateClasses = newStateClasses;
	},

	_trackMouseState: function(/*DomNode*/ node, /*String*/ clazz){
		// summary:
		//		Track mouse/focus events on specified node and set CSS class on that node to indicate
		//		current state.   Usually not called directly, but via cssStateNodes attribute.
		// description:
		//		Given class=foo, will set the following CSS class on the node
		//			- fooActive: if the user is currently pressing down the mouse button while over the node
		//			- fooHover: if the user is hovering the mouse over the node, but not pressing down a button
		//			- fooFocus: if the node is focused
		//
		//		Note that it won't set any classes if the widget is disabled.
		// node: DomNode
		//		Should be a sub-node of the widget, not the top node (this.domNode), since the top node
		//		is handled specially and automatically just by mixing in this class.
		// clazz: String
		//		CSS class name (ex: dijitSliderUpArrow).

		// Current state of node (initially false)
		// NB: setting specifically to false because dojo.toggleClass() needs true boolean as third arg
		var hovering=false, active=false, focused=false;

		var self = this,
			cn = dojo.hitch(this, "connect", node);

		function setClass(){
			var disabled = ("disabled" in self && self.disabled) || ("readonly" in self && self.readonly);
			dojo.toggleClass(node, clazz+"Hover", hovering && !active && !disabled);
			dojo.toggleClass(node, clazz+"Active", active && !disabled);
			dojo.toggleClass(node, clazz+"Focused", focused && !disabled);
		}

		// Mouse
		cn("onmouseenter", function(){
			hovering = true;
			setClass();
		});
		cn("onmouseleave", function(){
			hovering = false;
			active = false;
			setClass();
		});
		cn("onmousedown", function(){
			active = true;
			setClass();
		});
		cn("onmouseup", function(){
			active = false;
			setClass();
		});

		// Focus
		cn("onfocus", function(){
			focused = true;
			setClass();
		});
		cn("onblur", function(){
			focused = false;
			setClass();
		});

		// Just in case widget is enabled/disabled while it has focus/hover/active state.
		// Maybe this is overkill.
		this.watch("disabled", setClass);
		this.watch("readOnly", setClass);
	}
});

}

if(!dojo._hasResource["dijit.form._FormWidget"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form._FormWidget"] = true;
dojo.provide("dijit.form._FormWidget");







dojo.declare("dijit.form._FormWidget", [dijit._Widget, dijit._Templated, dijit._CssStateMixin],
	{
	// summary:
	//		Base class for widgets corresponding to native HTML elements such as <checkbox> or <button>,
	//		which can be children of a <form> node or a `dijit.form.Form` widget.
	//
	// description:
	//		Represents a single HTML element.
	//		All these widgets should have these attributes just like native HTML input elements.
	//		You can set them during widget construction or afterwards, via `dijit._Widget.attr`.
	//
	//		They also share some common methods.

	// name: [const] String
	//		Name used when submitting form; same as "name" attribute or plain HTML elements
	name: "",

	// alt: String
	//		Corresponds to the native HTML <input> element's attribute.
	alt: "",

	// value: String
	//		Corresponds to the native HTML <input> element's attribute.
	value: "",

	// type: String
	//		Corresponds to the native HTML <input> element's attribute.
	type: "text",

	// tabIndex: Integer
	//		Order fields are traversed when user hits the tab key
	tabIndex: "0",

	// disabled: Boolean
	//		Should this widget respond to user input?
	//		In markup, this is specified as "disabled='disabled'", or just "disabled".
	disabled: false,

	// intermediateChanges: Boolean
	//		Fires onChange for each value change or only on demand
	intermediateChanges: false,

	// scrollOnFocus: Boolean
	//		On focus, should this widget scroll into view?
	scrollOnFocus: true,

	// These mixins assume that the focus node is an INPUT, as many but not all _FormWidgets are.
	attributeMap: dojo.delegate(dijit._Widget.prototype.attributeMap, {
		value: "focusNode",
		id: "focusNode",
		tabIndex: "focusNode",
		alt: "focusNode",
		title: "focusNode"
	}),

	postMixInProperties: function(){
		// Setup name=foo string to be referenced from the template (but only if a name has been specified)
		// Unfortunately we can't use attributeMap to set the name due to IE limitations, see #8660
		// Regarding escaping, see heading "Attribute values" in
		// http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.3.2
		this.nameAttrSetting = this.name ? ('name="' + this.name.replace(/'/g, "&quot;") + '"') : '';
		this.inherited(arguments);
	},

	postCreate: function(){
		this.inherited(arguments);
		this.connect(this.domNode, "onmousedown", "_onMouseDown");
	},

	_setDisabledAttr: function(/*Boolean*/ value){
		this._set("disabled", value);
		dojo.attr(this.focusNode, 'disabled', value);
		if(this.valueNode){
			dojo.attr(this.valueNode, 'disabled', value);
		}
		dijit.setWaiState(this.focusNode, "disabled", value);

		if(value){
			// reset these, because after the domNode is disabled, we can no longer receive
			// mouse related events, see #4200
			this._set("hovering", false);
			this._set("active", false);

			// clear tab stop(s) on this widget's focusable node(s)  (ComboBox has two focusable nodes)
			var attachPointNames = "tabIndex" in this.attributeMap ? this.attributeMap.tabIndex : "focusNode";
			dojo.forEach(dojo.isArray(attachPointNames) ? attachPointNames : [attachPointNames], function(attachPointName){
				var node = this[attachPointName];
				// complex code because tabIndex=-1 on a <div> doesn't work on FF
				if(dojo.isWebKit || dijit.hasDefaultTabStop(node)){	// see #11064 about webkit bug
					node.setAttribute('tabIndex', "-1");
				}else{
					node.removeAttribute('tabIndex');
				}
			}, this);
		}else{
			if(this.tabIndex != ""){
				this.focusNode.setAttribute('tabIndex', this.tabIndex);
			}
		}
	},

	setDisabled: function(/*Boolean*/ disabled){
		// summary:
		//		Deprecated.  Use set('disabled', ...) instead.
		dojo.deprecated("setDisabled("+disabled+") is deprecated. Use set('disabled',"+disabled+") instead.", "", "2.0");
		this.set('disabled', disabled);
	},

	_onFocus: function(e){
		if(this.scrollOnFocus){
			dojo.window.scrollIntoView(this.domNode);
		}
		this.inherited(arguments);
	},

	isFocusable: function(){
		// summary:
		//		Tells if this widget is focusable or not.  Used internally by dijit.
		// tags:
		//		protected
		return !this.disabled && this.focusNode && (dojo.style(this.domNode, "display") != "none");
	},

	focus: function(){
		// summary:
		//		Put focus on this widget
		if(!this.disabled){
			dijit.focus(this.focusNode);
		}
	},

	compare: function(/*anything*/ val1, /*anything*/ val2){
		// summary:
		//		Compare 2 values (as returned by get('value') for this widget).
		// tags:
		//		protected
		if(typeof val1 == "number" && typeof val2 == "number"){
			return (isNaN(val1) && isNaN(val2)) ? 0 : val1 - val2;
		}else if(val1 > val2){
			return 1;
		}else if(val1 < val2){
			return -1;
		}else{
			return 0;
		}
	},

	onChange: function(newValue){
		// summary:
		//		Callback when this widget's value is changed.
		// tags:
		//		callback
	},

	// _onChangeActive: [private] Boolean
	//		Indicates that changes to the value should call onChange() callback.
	//		This is false during widget initialization, to avoid calling onChange()
	//		when the initial value is set.
	_onChangeActive: false,

	_handleOnChange: function(/*anything*/ newValue, /*Boolean?*/ priorityChange){
		// summary:
		//		Called when the value of the widget is set.  Calls onChange() if appropriate
		// newValue:
		//		the new value
		// priorityChange:
		//		For a slider, for example, dragging the slider is priorityChange==false,
		//		but on mouse up, it's priorityChange==true.  If intermediateChanges==false,
		//		onChange is only called form priorityChange=true events.
		// tags:
		//		private

	        /* Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved. Licensed under the Apache License 2.0 - http://www.apache.org/licenses/LICENSE-2.0 
	         * WaveMaker changed because onChange was firing and causing side-effects when in fact nothing had changed 
		 */
	        if (newValue === this._lastValueReported) return;


		if(this._lastValueReported == undefined && (priorityChange === null || !this._onChangeActive)){
			// this block executes not for a change, but during initialization,
			// and is used to store away the original value (or for ToggleButton, the original checked state)
			this._resetValue = this._lastValueReported = newValue;
		}
		this._pendingOnChange = this._pendingOnChange
			|| (typeof newValue != typeof this._lastValueReported)
			|| (this.compare(newValue, this._lastValueReported) != 0);
		if((this.intermediateChanges || priorityChange || priorityChange === undefined) && this._pendingOnChange){
			this._lastValueReported = newValue;
			this._pendingOnChange = false;
			if(this._onChangeActive){
				if(this._onChangeHandle){
					clearTimeout(this._onChangeHandle);
				}
				// setTimout allows hidden value processing to run and
				// also the onChange handler can safely adjust focus, etc
				this._onChangeHandle = setTimeout(dojo.hitch(this,
					function(){
						this._onChangeHandle = null;
						this.onChange(newValue);
					}), 0); // try to collapse multiple onChange's fired faster than can be processed
			}
		}
	},

	create: function(){
		// Overrides _Widget.create()
		this.inherited(arguments);
		this._onChangeActive = true;
	},

	destroy: function(){
		if(this._onChangeHandle){ // destroy called before last onChange has fired
			clearTimeout(this._onChangeHandle);
			this.onChange(this._lastValueReported);
		}
		this.inherited(arguments);
	},

	setValue: function(/*String*/ value){
		// summary:
		//		Deprecated.  Use set('value', ...) instead.
		dojo.deprecated("dijit.form._FormWidget:setValue("+value+") is deprecated.  Use set('value',"+value+") instead.", "", "2.0");
		this.set('value', value);
	},

	getValue: function(){
		// summary:
		//		Deprecated.  Use get('value') instead.
		dojo.deprecated(this.declaredClass+"::getValue() is deprecated. Use get('value') instead.", "", "2.0");
		return this.get('value');
	},
	
	_onMouseDown: function(e){
		// If user clicks on the button, even if the mouse is released outside of it,
		// this button should get focus (to mimics native browser buttons).
		// This is also needed on chrome because otherwise buttons won't get focus at all,
		// which leads to bizarre focus restore on Dialog close etc.
		if(!e.ctrlKey && dojo.mouseButtons.isLeft(e) && this.isFocusable()){ // !e.ctrlKey to ignore right-click on mac
			// Set a global event to handle mouseup, so it fires properly
			// even if the cursor leaves this.domNode before the mouse up event.
			var mouseUpConnector = this.connect(dojo.body(), "onmouseup", function(){
				if (this.isFocusable()) {
					this.focus();
				}
				this.disconnect(mouseUpConnector);
			});
		}
	}
});

dojo.declare("dijit.form._FormValueWidget", dijit.form._FormWidget,
{
	// summary:
	//		Base class for widgets corresponding to native HTML elements such as <input> or <select> that have user changeable values.
	// description:
	//		Each _FormValueWidget represents a single input value, and has a (possibly hidden) <input> element,
	//		to which it serializes it's input value, so that form submission (either normal submission or via FormBind?)
	//		works as expected.

	// Don't attempt to mixin the 'type', 'name' attributes here programatically -- they must be declared
	// directly in the template as read by the parser in order to function. IE is known to specifically
	// require the 'name' attribute at element creation time.  See #8484, #8660.
	// TODO: unclear what that {value: ""} is for; FormWidget.attributeMap copies value to focusNode,
	// so maybe {value: ""} is so the value *doesn't* get copied to focusNode?
	// Seems like we really want value removed from attributeMap altogether
	// (although there's no easy way to do that now)

	// readOnly: Boolean
	//		Should this widget respond to user input?
	//		In markup, this is specified as "readOnly".
	//		Similar to disabled except readOnly form values are submitted.
	readOnly: false,

	attributeMap: dojo.delegate(dijit.form._FormWidget.prototype.attributeMap, {
		value: "",
		readOnly: "focusNode"
	}),

	_setReadOnlyAttr: function(/*Boolean*/ value){
		dojo.attr(this.focusNode, 'readOnly', value);
		dijit.setWaiState(this.focusNode, "readonly", value);
		this._set("readOnly", value);
	},

	postCreate: function(){
		this.inherited(arguments);

		if(dojo.isIE < 9 || (dojo.isIE && dojo.isQuirks)){ // IE won't stop the event with keypress
			this.connect(this.focusNode || this.domNode, "onkeydown", this._onKeyDown);
		}
		// Update our reset value if it hasn't yet been set (because this.set()
		// is only called when there *is* a value)
		if(this._resetValue === undefined){
			this._lastValueReported = this._resetValue = this.value;
		}
	},

	_setValueAttr: function(/*anything*/ newValue, /*Boolean?*/ priorityChange){
		// summary:
		//		Hook so set('value', value) works.
		// description:
		//		Sets the value of the widget.
		//		If the value has changed, then fire onChange event, unless priorityChange
		//		is specified as null (or false?)
		this._handleOnChange(newValue, priorityChange);
	},

	_handleOnChange: function(/*anything*/ newValue, /*Boolean?*/ priorityChange){
		// summary:
		//		Called when the value of the widget has changed.  Saves the new value in this.value,
		//		and calls onChange() if appropriate.   See _FormWidget._handleOnChange() for details.
		this._set("value", newValue);
		this.inherited(arguments);
	},

	undo: function(){
		// summary:
		//		Restore the value to the last value passed to onChange
		this._setValueAttr(this._lastValueReported, false);
	},

	reset: function(){
		// summary:
		//		Reset the widget's value to what it was at initialization time
		this._hasBeenBlurred = false;
		this._setValueAttr(this._resetValue, true);
	},

	_onKeyDown: function(e){
		if(e.keyCode == dojo.keys.ESCAPE && !(e.ctrlKey || e.altKey || e.metaKey)){
			var te;
			if(dojo.isIE){
				e.preventDefault(); // default behavior needs to be stopped here since keypress is too late
				te = document.createEventObject();
				te.keyCode = dojo.keys.ESCAPE;
				te.shiftKey = e.shiftKey;
				e.srcElement.fireEvent('onkeypress', te);
			}
		}
	},

	_layoutHackIE7: function(){
		// summary:
		//		Work around table sizing bugs on IE7 by forcing redraw

		if(dojo.isIE == 7){ // fix IE7 layout bug when the widget is scrolled out of sight
			var domNode = this.domNode;
			var parent = domNode.parentNode;
			var pingNode = domNode.firstChild || domNode; // target node most unlikely to have a custom filter
			var origFilter = pingNode.style.filter; // save custom filter, most likely nothing
			var _this = this;
			while(parent && parent.clientHeight == 0){ // search for parents that haven't rendered yet
				(function ping(){
					var disconnectHandle = _this.connect(parent, "onscroll",
						function(e){
							_this.disconnect(disconnectHandle); // only call once
							pingNode.style.filter = (new Date()).getMilliseconds(); // set to anything that's unique
							setTimeout(function(){ pingNode.style.filter = origFilter }, 0); // restore custom filter, if any
						}
					);
				})();
				parent = parent.parentNode;
			}
		}
	}
});

}

if(!dojo._hasResource["dijit.form.TextBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.TextBox"] = true;
dojo.provide("dijit.form.TextBox");




dojo.declare(
	"dijit.form.TextBox",
	dijit.form._FormValueWidget,
	{
		// summary:
		//		A base class for textbox form inputs

		// trim: Boolean
		//		Removes leading and trailing whitespace if true.  Default is false.
		trim: false,

		// uppercase: Boolean
		//		Converts all characters to uppercase if true.  Default is false.
		uppercase: false,

		// lowercase: Boolean
		//		Converts all characters to lowercase if true.  Default is false.
		lowercase: false,

		// propercase: Boolean
		//		Converts the first character of each word to uppercase if true.
		propercase: false,

		// maxLength: String
		//		HTML INPUT tag maxLength declaration.
		maxLength: "",

		// selectOnClick: [const] Boolean
		//		If true, all text will be selected when focused with mouse
		selectOnClick: false,

		// placeHolder: String
		//		Defines a hint to help users fill out the input field (as defined in HTML 5).
		//		This should only contain plain text (no html markup).
		placeHolder: "",
		
		templateString: dojo.cache("dijit.form", "templates/TextBox.html", "<div class=\"dijit dijitReset dijitInline dijitLeft\" id=\"widget_${id}\" role=\"presentation\"\r\n\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\r\n\t\t><input class=\"dijitReset dijitInputInner\" dojoAttachPoint='textbox,focusNode' autocomplete=\"off\"\r\n\t\t\t${!nameAttrSetting} type='${type}'\r\n\t/></div\r\n></div>\r\n"),
		_singleNodeTemplate: '<input class="dijit dijitReset dijitLeft dijitInputField" dojoAttachPoint="textbox,focusNode" autocomplete="off" type="${type}" ${!nameAttrSetting} />',

		_buttonInputDisabled: dojo.isIE ? "disabled" : "", // allows IE to disallow focus, but Firefox cannot be disabled for mousedown events

		baseClass: "dijitTextBox",

		attributeMap: dojo.delegate(dijit.form._FormValueWidget.prototype.attributeMap, {
			maxLength: "focusNode"
		}),
		
		postMixInProperties: function(){
			var type = this.type.toLowerCase();
			if(this.templateString && this.templateString.toLowerCase() == "input" || ((type == "hidden" || type == "file") && this.templateString == dijit.form.TextBox.prototype.templateString)){
				this.templateString = this._singleNodeTemplate;
			}
			this.inherited(arguments);
		},

		_setPlaceHolderAttr: function(v){
			this._set("placeHolder", v);
			if(!this._phspan){
				this._attachPoints.push('_phspan');
				/* dijitInputField class gives placeHolder same padding as the input field
				 * parent node already has dijitInputField class but it doesn't affect this <span>
				 * since it's position: absolute.
				 */
				this._phspan = dojo.create('span',{className:'dijitPlaceHolder dijitInputField'},this.textbox,'after');
			}
			this._phspan.innerHTML="";
			this._phspan.appendChild(document.createTextNode(v));
			
			this._updatePlaceHolder();
		},
		
		_updatePlaceHolder: function(){
			if(this._phspan){
				this._phspan.style.display=(this.placeHolder&&!this._focused&&!this.textbox.value)?"":"none";
			}
		},

		_getValueAttr: function(){
			// summary:
			//		Hook so get('value') works as we like.
			// description:
			//		For `dijit.form.TextBox` this basically returns the value of the <input>.
			//
			//		For `dijit.form.MappedTextBox` subclasses, which have both
			//		a "displayed value" and a separate "submit value",
			//		This treats the "displayed value" as the master value, computing the
			//		submit value from it via this.parse().
			return this.parse(this.get('displayedValue'), this.constraints);
		},

		_setValueAttr: function(value, /*Boolean?*/ priorityChange, /*String?*/ formattedValue){
			// summary:
			//		Hook so set('value', ...) works.
			//
			// description:
			//		Sets the value of the widget to "value" which can be of
			//		any type as determined by the widget.
			//
			// value:
			//		The visual element value is also set to a corresponding,
			//		but not necessarily the same, value.
			//
			// formattedValue:
			//		If specified, used to set the visual element value,
			//		otherwise a computed visual value is used.
			//
			// priorityChange:
			//		If true, an onChange event is fired immediately instead of
			//		waiting for the next blur event.

			var filteredValue;
			if(value !== undefined){
				// TODO: this is calling filter() on both the display value and the actual value.
				// I added a comment to the filter() definition about this, but it should be changed.
				filteredValue = this.filter(value);
				if(typeof formattedValue != "string"){
					if(filteredValue !== null && ((typeof filteredValue != "number") || !isNaN(filteredValue))){
						formattedValue = this.filter(this.format(filteredValue, this.constraints));
					}else{ formattedValue = ''; }
				}
			}
			if(formattedValue != null && formattedValue != undefined && ((typeof formattedValue) != "number" || !isNaN(formattedValue)) && this.textbox.value != formattedValue){
				this.textbox.value = formattedValue;
				this._set("displayedValue", this.get("displayedValue"));
			}

			this._updatePlaceHolder();

			this.inherited(arguments, [filteredValue, priorityChange]);
		},

		// displayedValue: String
		//		For subclasses like ComboBox where the displayed value
		//		(ex: Kentucky) and the serialized value (ex: KY) are different,
		//		this represents the displayed value.
		//
		//		Setting 'displayedValue' through set('displayedValue', ...)
		//		updates 'value', and vice-versa.  Otherwise 'value' is updated
		//		from 'displayedValue' periodically, like onBlur etc.
		//
		//		TODO: move declaration to MappedTextBox?
		//		Problem is that ComboBox references displayedValue,
		//		for benefit of FilteringSelect.
		displayedValue: "",

		getDisplayedValue: function(){
			// summary:
			//		Deprecated.  Use get('displayedValue') instead.
			// tags:
			//		deprecated
			dojo.deprecated(this.declaredClass+"::getDisplayedValue() is deprecated. Use set('displayedValue') instead.", "", "2.0");
			return this.get('displayedValue');
		},

		_getDisplayedValueAttr: function(){
			// summary:
			//		Hook so get('displayedValue') works.
			// description:
			//		Returns the displayed value (what the user sees on the screen),
			// 		after filtering (ie, trimming spaces etc.).
			//
			//		For some subclasses of TextBox (like ComboBox), the displayed value
			//		is different from the serialized value that's actually
			//		sent to the server (see dijit.form.ValidationTextBox.serialize)

			// TODO: maybe we should update this.displayedValue on every keystroke so that we don't need
			// this method
			// TODO: this isn't really the displayed value when the user is typing
			return this.filter(this.textbox.value);
		},

		setDisplayedValue: function(/*String*/ value){
			// summary:
			//		Deprecated.  Use set('displayedValue', ...) instead.
			// tags:
			//		deprecated
			dojo.deprecated(this.declaredClass+"::setDisplayedValue() is deprecated. Use set('displayedValue', ...) instead.", "", "2.0");
			this.set('displayedValue', value);
		},

		_setDisplayedValueAttr: function(/*String*/ value){
			// summary:
			//		Hook so set('displayedValue', ...) works.
			// description:
			//		Sets the value of the visual element to the string "value".
			//		The widget value is also set to a corresponding,
			//		but not necessarily the same, value.

			if(value === null || value === undefined){ value = '' }
			else if(typeof value != "string"){ value = String(value) }

			this.textbox.value = value;

			// sets the serialized value to something corresponding to specified displayedValue
			// (if possible), and also updates the textbox.value, for example converting "123"
			// to "123.00"
			this._setValueAttr(this.get('value'), undefined);

			this._set("displayedValue", this.get('displayedValue'));
		},

		format: function(/*String*/ value, /*Object*/ constraints){
			// summary:
			//		Replacable function to convert a value to a properly formatted string.
			// tags:
			//		protected extension
			return ((value == null || value == undefined) ? "" : (value.toString ? value.toString() : value));
		},

		parse: function(/*String*/ value, /*Object*/ constraints){
			// summary:
			//		Replacable function to convert a formatted string to a value
			// tags:
			//		protected extension

			return value;	// String
		},

		_refreshState: function(){
			// summary:
			//		After the user types some characters, etc., this method is
			//		called to check the field for validity etc.  The base method
			//		in `dijit.form.TextBox` does nothing, but subclasses override.
			// tags:
			//		protected
		},

		_onInput: function(e){
			if(e && e.type && /key/i.test(e.type) && e.keyCode){
				switch(e.keyCode){
					case dojo.keys.SHIFT:
					case dojo.keys.ALT:
					case dojo.keys.CTRL:
					case dojo.keys.TAB:
						return;
				}
			}
			if(this.intermediateChanges){
				var _this = this;
				// the setTimeout allows the key to post to the widget input box
				setTimeout(function(){ _this._handleOnChange(_this.get('value'), false); }, 0);
			}
			this._refreshState();

			// In case someone is watch()'ing for changes to displayedValue
			this._set("displayedValue", this.get("displayedValue"));
		},

		postCreate: function(){
			if(dojo.isIE){ // IE INPUT tag fontFamily has to be set directly using STYLE
				// the setTimeout gives IE a chance to render the TextBox and to deal with font inheritance
				setTimeout(dojo.hitch(this, function(){
				var s = dojo.getComputedStyle(this.domNode);
				if(s){
					var ff = s.fontFamily;
					if(ff){
						var inputs = this.domNode.getElementsByTagName("INPUT");
						if(inputs){
							for(var i=0; i < inputs.length; i++){
								inputs[i].style.fontFamily = ff;
							}
						}
					}
				}
				}), 0);
			}

			// setting the value here is needed since value="" in the template causes "undefined"
			// and setting in the DOM (instead of the JS object) helps with form reset actions
			this.textbox.setAttribute("value", this.textbox.value); // DOM and JS values should be the same

			this.inherited(arguments);

			if(dojo.isMoz || dojo.isOpera){
				this.connect(this.textbox, "oninput", "_onInput");
			}else{
				this.connect(this.textbox, "onkeydown", "_onInput");
				this.connect(this.textbox, "onkeyup", "_onInput");
				this.connect(this.textbox, "onpaste", "_onInput");
				this.connect(this.textbox, "oncut", "_onInput");
			}
		},

		_blankValue: '', // if the textbox is blank, what value should be reported
		filter: function(val){
			// summary:
			//		Auto-corrections (such as trimming) that are applied to textbox
			//		value on blur or form submit.
			// description:
			//		For MappedTextBox subclasses, this is called twice
			// 			- once with the display value
			//			- once the value as set/returned by set('value', ...)
			//		and get('value'), ex: a Number for NumberTextBox.
			//
			//		In the latter case it does corrections like converting null to NaN.  In
			//		the former case the NumberTextBox.filter() method calls this.inherited()
			//		to execute standard trimming code in TextBox.filter().
			//
			//		TODO: break this into two methods in 2.0
			//
			// tags:
			//		protected extension
			if(val === null){ return this._blankValue; }
			if(typeof val != "string"){ return val; }
			if(this.trim){
				val = dojo.trim(val);
			}
			if(this.uppercase){
				val = val.toUpperCase();
			}
			if(this.lowercase){
				val = val.toLowerCase();
			}
			if(this.propercase){
				val = val.replace(/[^\s]+/g, function(word){
					return word.substring(0,1).toUpperCase() + word.substring(1);
				});
			}
			return val;
		},

		_setBlurValue: function(){
			this._setValueAttr(this.get('value'), true);
		},

		_onBlur: function(e){
			if(this.disabled){ return; }
			this._setBlurValue();
			this.inherited(arguments);

			if(this._selectOnClickHandle){
				this.disconnect(this._selectOnClickHandle);
			}
			if(this.selectOnClick && dojo.isMoz){
				this.textbox.selectionStart = this.textbox.selectionEnd = undefined; // clear selection so that the next mouse click doesn't reselect
			}
			
			this._updatePlaceHolder();
		},

		_onFocus: function(/*String*/ by){
			if(this.disabled || this.readOnly){ return; }

			// Select all text on focus via click if nothing already selected.
			// Since mouse-up will clear the selection need to defer selection until after mouse-up.
			// Don't do anything on focus by tabbing into the widget since there's no associated mouse-up event.
			if(this.selectOnClick && by == "mouse"){
				this._selectOnClickHandle = this.connect(this.domNode, "onmouseup", function(){
					// Only select all text on first click; otherwise users would have no way to clear
					// the selection.
					this.disconnect(this._selectOnClickHandle);

					// Check if the user selected some text manually (mouse-down, mouse-move, mouse-up)
					// and if not, then select all the text
					var textIsNotSelected;
					if(dojo.isIE){
						var range = dojo.doc.selection.createRange();
						var parent = range.parentElement();
						textIsNotSelected = parent == this.textbox && range.text.length == 0;
					}else{
						textIsNotSelected = this.textbox.selectionStart == this.textbox.selectionEnd;
					}
					if(textIsNotSelected){
						dijit.selectInputText(this.textbox);
					}
				});
			}

			this._updatePlaceHolder();
			
			// call this.inherited() before refreshState(), since this.inherited() will possibly scroll the viewport
			// (to scroll the TextBox into view), which will affect how _refreshState() positions the tooltip
			this.inherited(arguments);

		        /* Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved. Licensed under the Apache License 2.0 - http://www.apache.org/licenses/LICENSE-2.0 
			 * WaveMaker added because messages were failing to be cleared such that calls to 
			 * show message came with the same message and were skipped
			 */
		    this._message = "";


			this._refreshState();
		},

		reset: function(){
			// Overrides dijit._FormWidget.reset().
			// Additionally resets the displayed textbox value to ''
			this.textbox.value = '';
			this.inherited(arguments);
		}
	}
);

dijit.selectInputText = function(/*DomNode*/ element, /*Number?*/ start, /*Number?*/ stop){
	// summary:
	//		Select text in the input element argument, from start (default 0), to stop (default end).

	// TODO: use functions in _editor/selection.js?
	var _window = dojo.global;
	var _document = dojo.doc;
	element = dojo.byId(element);
	if(isNaN(start)){ start = 0; }
	if(isNaN(stop)){ stop = element.value ? element.value.length : 0; }
	dijit.focus(element);
	if(_document["selection"] && dojo.body()["createTextRange"]){ // IE
		if(element.createTextRange){
			var r = element.createTextRange();
			r.collapse(true);
			r.moveStart("character", -99999); // move to 0
			r.moveStart("character", start); // delta from 0 is the correct position
			r.moveEnd("character", stop-start);
			r.select();
		}
	}else if(_window["getSelection"]){
		if(element.setSelectionRange){
			element.setSelectionRange(start, stop);
		}
	}
};

}

if(!dojo._hasResource["dijit.Tooltip"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.Tooltip"] = true;
dojo.provide("dijit.Tooltip");





dojo.declare(
	"dijit._MasterTooltip",
	[dijit._Widget, dijit._Templated],
	{
		// summary:
		//		Internal widget that holds the actual tooltip markup,
		//		which occurs once per page.
		//		Called by Tooltip widgets which are just containers to hold
		//		the markup
		// tags:
		//		protected

		// duration: Integer
		//		Milliseconds to fade in/fade out
		duration: dijit.defaultDuration,

		templateString: dojo.cache("dijit", "templates/Tooltip.html", "<div class=\"dijitTooltip dijitTooltipLeft\" id=\"dojoTooltip\"\r\n\t><div class=\"dijitTooltipContainer dijitTooltipContents\" dojoAttachPoint=\"containerNode\" role='alert'></div\r\n\t><div class=\"dijitTooltipConnector\" dojoAttachPoint=\"connectorNode\"></div\r\n></div>\r\n"),

		postCreate: function(){
			dojo.body().appendChild(this.domNode);

			this.bgIframe = new dijit.BackgroundIframe(this.domNode);

			// Setup fade-in and fade-out functions.
			this.fadeIn = dojo.fadeIn({ node: this.domNode, duration: this.duration, onEnd: dojo.hitch(this, "_onShow") });
			this.fadeOut = dojo.fadeOut({ node: this.domNode, duration: this.duration, onEnd: dojo.hitch(this, "_onHide") });
		},

		show: function(/*String*/ innerHTML, /*DomNode*/ aroundNode, /*String[]?*/ position, /*Boolean*/ rtl){
			// summary:
			//		Display tooltip w/specified contents to right of specified node
			//		(To left if there's no space on the right, or if rtl == true)

			if(this.aroundNode && this.aroundNode === aroundNode){
				return;
			}

			// reset width; it may have been set by orient() on a previous tooltip show()
			this.domNode.width = "auto";

			if(this.fadeOut.status() == "playing"){
				// previous tooltip is being hidden; wait until the hide completes then show new one
				this._onDeck=arguments;
				return;
			}
			this.containerNode.innerHTML=innerHTML;

			var pos = dijit.placeOnScreenAroundElement(this.domNode, aroundNode, dijit.getPopupAroundAlignment((position && position.length) ? position : dijit.Tooltip.defaultPosition, !rtl), dojo.hitch(this, "orient"));

			// show it
			dojo.style(this.domNode, "opacity", 0);
			this.fadeIn.play();
			this.isShowingNow = true;
			this.aroundNode = aroundNode;
		},

		orient: function(/*DomNode*/ node, /*String*/ aroundCorner, /*String*/ tooltipCorner, /*Object*/ spaceAvailable, /*Object*/ aroundNodeCoords){
			// summary:
			//		Private function to set CSS for tooltip node based on which position it's in.
			//		This is called by the dijit popup code.   It will also reduce the tooltip's
			//		width to whatever width is available
			// tags:
			//		protected
			this.connectorNode.style.top = ""; //reset to default
			
			//Adjust the spaceAvailable width, without changing the spaceAvailable object
			var tooltipSpaceAvaliableWidth = spaceAvailable.w - this.connectorNode.offsetWidth;

			node.className = "dijitTooltip " +
				{
					"BL-TL": "dijitTooltipBelow dijitTooltipABLeft",
					"TL-BL": "dijitTooltipAbove dijitTooltipABLeft",
					"BR-TR": "dijitTooltipBelow dijitTooltipABRight",
					"TR-BR": "dijitTooltipAbove dijitTooltipABRight",
					"BR-BL": "dijitTooltipRight",
					"BL-BR": "dijitTooltipLeft"
				}[aroundCorner + "-" + tooltipCorner];
				
			// reduce tooltip's width to the amount of width available, so that it doesn't overflow screen
			this.domNode.style.width = "auto";
			var size = dojo.contentBox(this.domNode);
			
			var width = Math.min((Math.max(tooltipSpaceAvaliableWidth,1)), size.w);
			var widthWasReduced = width < size.w;
			
			this.domNode.style.width = width+"px";
						
			//Adjust width for tooltips that have a really long word or a nowrap setting
			if(widthWasReduced){
				this.containerNode.style.overflow = "auto"; //temp change to overflow to detect if our tooltip needs to be wider to support the content
				var scrollWidth = this.containerNode.scrollWidth;
				this.containerNode.style.overflow = "visible"; //change it back
				if(scrollWidth > width){
					scrollWidth = scrollWidth + dojo.style(this.domNode,"paddingLeft") + dojo.style(this.domNode,"paddingRight");
					this.domNode.style.width = scrollWidth + "px";
				}
			}
			
			// Reposition the tooltip connector.
			if(tooltipCorner.charAt(0) == 'B' && aroundCorner.charAt(0) == 'B'){
				var mb = dojo.marginBox(node);
				var tooltipConnectorHeight = this.connectorNode.offsetHeight;
				if(mb.h > spaceAvailable.h){
					// The tooltip starts at the top of the page and will extend past the aroundNode
					var aroundNodePlacement = spaceAvailable.h - (aroundNodeCoords.h / 2) - (tooltipConnectorHeight / 2);
					this.connectorNode.style.top = aroundNodePlacement + "px";
					this.connectorNode.style.bottom = "";
				}else{
					// Align center of connector with center of aroundNode, except don't let bottom
					// of connector extend below bottom of tooltip content, or top of connector
					// extend past top of tooltip content
					this.connectorNode.style.bottom = Math.min(
						Math.max(aroundNodeCoords.h/2 - tooltipConnectorHeight/2, 0),
						mb.h - tooltipConnectorHeight) + "px";
					this.connectorNode.style.top = "";
				}
			}else{
				// reset the tooltip back to the defaults
				this.connectorNode.style.top = "";
				this.connectorNode.style.bottom = "";
			}
			
			return Math.max(0, size.w - tooltipSpaceAvaliableWidth);
		},

		_onShow: function(){
			// summary:
			//		Called at end of fade-in operation
			// tags:
			//		protected
			if(dojo.isIE){
				// the arrow won't show up on a node w/an opacity filter
				this.domNode.style.filter="";
			}
		},

		hide: function(aroundNode){
			// summary:
			//		Hide the tooltip

			if(this._onDeck && this._onDeck[1] == aroundNode){
				// this hide request is for a show() that hasn't even started yet;
				// just cancel the pending show()
				this._onDeck=null;
			}else if(this.aroundNode === aroundNode){
				// this hide request is for the currently displayed tooltip
				this.fadeIn.stop();
				this.isShowingNow = false;
				this.aroundNode = null;
				this.fadeOut.play();
			}else{
				// just ignore the call, it's for a tooltip that has already been erased
			}
		},

		_onHide: function(){
			// summary:
			//		Called at end of fade-out operation
			// tags:
			//		protected

			this.domNode.style.cssText="";	// to position offscreen again
			this.containerNode.innerHTML="";
			if(this._onDeck){
				// a show request has been queued up; do it now
				this.show.apply(this, this._onDeck);
				this._onDeck=null;
			}
		}

	}
);

dijit.showTooltip = function(/*String*/ innerHTML, /*DomNode*/ aroundNode, /*String[]?*/ position, /*Boolean*/ rtl){
	// summary:
	//		Display tooltip w/specified contents in specified position.
	//		See description of dijit.Tooltip.defaultPosition for details on position parameter.
	//		If position is not specified then dijit.Tooltip.defaultPosition is used.
	if(!dijit._masterTT){ dijit._masterTT = new dijit._MasterTooltip(); }
	return dijit._masterTT.show(innerHTML, aroundNode, position, rtl);
};

dijit.hideTooltip = function(aroundNode){
	// summary:
	//		Hide the tooltip
	if(!dijit._masterTT){ dijit._masterTT = new dijit._MasterTooltip(); }
	return dijit._masterTT.hide(aroundNode);
};

dojo.declare(
	"dijit.Tooltip",
	dijit._Widget,
	{
		// summary:
		//		Pops up a tooltip (a help message) when you hover over a node.

		// label: String
		//		Text to display in the tooltip.
		//		Specified as innerHTML when creating the widget from markup.
		label: "",

		// showDelay: Integer
		//		Number of milliseconds to wait after hovering over/focusing on the object, before
		//		the tooltip is displayed.
		showDelay: 400,

		// connectId: String|String[]
		//		Id of domNode(s) to attach the tooltip to.
		//		When user hovers over specified dom node, the tooltip will appear.
		connectId: [],

		// position: String[]
		//		See description of `dijit.Tooltip.defaultPosition` for details on position parameter.
		position: [],

		_setConnectIdAttr: function(/*String*/ newId){
			// summary:
			//		Connect to node(s) (specified by id)

			// Remove connections to old nodes (if there are any)
			dojo.forEach(this._connections || [], function(nested){
				dojo.forEach(nested, dojo.hitch(this, "disconnect"));
			}, this);

			// Make connections to nodes in newIds.
			var ary = dojo.isArrayLike(newId) ? newId : (newId ? [newId] : []);
			this._connections = dojo.map(ary, function(id){
				var node = dojo.byId(id);
				return node ? [
					this.connect(node, "onmouseenter", "_onTargetMouseEnter"),
					this.connect(node, "onmouseleave", "_onTargetMouseLeave"),
					this.connect(node, "onfocus", "_onTargetFocus"),
					this.connect(node, "onblur", "_onTargetBlur")
				] : [];
			}, this);
	
			this._set("connectId", newId);

			this._connectIds = ary;	// save as array
		},

		addTarget: function(/*DOMNODE || String*/ node){
			// summary:
			//		Attach tooltip to specified node if it's not already connected

			// TODO: remove in 2.0 and just use set("connectId", ...) interface

			var id = node.id || node;
			if(dojo.indexOf(this._connectIds, id) == -1){
				this.set("connectId", this._connectIds.concat(id));
			}
		},

		removeTarget: function(/*DOMNODE || String*/ node){
			// summary:
			//		Detach tooltip from specified node

			// TODO: remove in 2.0 and just use set("connectId", ...) interface
			
			var id = node.id || node,	// map from DOMNode back to plain id string
				idx = dojo.indexOf(this._connectIds, id);
			if(idx >= 0){
				// remove id (modifies original this._connectIds but that's OK in this case)
				this._connectIds.splice(idx, 1);
				this.set("connectId", this._connectIds);
			}
		},

		buildRendering: function(){
			this.inherited(arguments);
			dojo.addClass(this.domNode,"dijitTooltipData");
		},

		startup: function(){
			this.inherited(arguments);

			// If this tooltip was created in a template, or for some other reason the specified connectId[s]
			// didn't exist during the widget's initialization, then connect now.
			var ids = this.connectId;
			dojo.forEach(dojo.isArrayLike(ids) ? ids : [ids], this.addTarget, this);
		},

		_onTargetMouseEnter: function(/*Event*/ e){
			// summary:
			//		Handler for mouseenter event on the target node
			// tags:
			//		private
			this._onHover(e);
		},

		_onTargetMouseLeave: function(/*Event*/ e){
			// summary:
			//		Handler for mouseleave event on the target node
			// tags:
			//		private
			this._onUnHover(e);
		},

		_onTargetFocus: function(/*Event*/ e){
			// summary:
			//		Handler for focus event on the target node
			// tags:
			//		private

			this._focus = true;
			this._onHover(e);
		},

		_onTargetBlur: function(/*Event*/ e){
			// summary:
			//		Handler for blur event on the target node
			// tags:
			//		private

			this._focus = false;
			this._onUnHover(e);
		},

		_onHover: function(/*Event*/ e){
			// summary:
			//		Despite the name of this method, it actually handles both hover and focus
			//		events on the target node, setting a timer to show the tooltip.
			// tags:
			//		private
			if(!this._showTimer){
				var target = e.target;
				this._showTimer = setTimeout(dojo.hitch(this, function(){this.open(target)}), this.showDelay);
			}
		},

		_onUnHover: function(/*Event*/ e){
			// summary:
			//		Despite the name of this method, it actually handles both mouseleave and blur
			//		events on the target node, hiding the tooltip.
			// tags:
			//		private

			// keep a tooltip open if the associated element still has focus (even though the
			// mouse moved away)
			if(this._focus){ return; }

			if(this._showTimer){
				clearTimeout(this._showTimer);
				delete this._showTimer;
			}
			this.close();
		},

		open: function(/*DomNode*/ target){
 			// summary:
			//		Display the tooltip; usually not called directly.
			// tags:
			//		private

			if(this._showTimer){
				clearTimeout(this._showTimer);
				delete this._showTimer;
			}
			dijit.showTooltip(this.label || this.domNode.innerHTML, target, this.position, !this.isLeftToRight());

			this._connectNode = target;
			this.onShow(target, this.position);
		},

		close: function(){
			// summary:
			//		Hide the tooltip or cancel timer for show of tooltip
			// tags:
			//		private

			if(this._connectNode){
				// if tooltip is currently shown
				dijit.hideTooltip(this._connectNode);
				delete this._connectNode;
				this.onHide();
			}
			if(this._showTimer){
				// if tooltip is scheduled to be shown (after a brief delay)
				clearTimeout(this._showTimer);
				delete this._showTimer;
			}
		},

		onShow: function(target, position){
			// summary:
			//		Called when the tooltip is shown
			// tags:
			//		callback
		},

		onHide: function(){
			// summary:
			//		Called when the tooltip is hidden
			// tags:
			//		callback
		},

		uninitialize: function(){
			this.close();
			this.inherited(arguments);
		}
	}
);

// dijit.Tooltip.defaultPosition: String[]
//		This variable controls the position of tooltips, if the position is not specified to
//		the Tooltip widget or *TextBox widget itself.  It's an array of strings with the following values:
//
//			* before: places tooltip to the left of the target node/widget, or to the right in
//			  the case of RTL scripts like Hebrew and Arabic
//			* after: places tooltip to the right of the target node/widget, or to the left in
//			  the case of RTL scripts like Hebrew and Arabic
//			* above: tooltip goes above target node
//			* below: tooltip goes below target node
//
//		The list is positions is tried, in order, until a position is found where the tooltip fits
//		within the viewport.
//
//		Be careful setting this parameter.  A value of "above" may work fine until the user scrolls
//		the screen so that there's no room above the target node.   Nodes with drop downs, like
//		DropDownButton or FilteringSelect, are especially problematic, in that you need to be sure
//		that the drop down and tooltip don't overlap, even when the viewport is scrolled so that there
//		is only room below (or above) the target node, but not both.
dijit.Tooltip.defaultPosition = ["after", "before"];

}

if(!dojo._hasResource["dijit.form.ValidationTextBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.ValidationTextBox"] = true;
dojo.provide("dijit.form.ValidationTextBox");







/*=====
	dijit.form.ValidationTextBox.__Constraints = function(){
		// locale: String
		//		locale used for validation, picks up value from this widget's lang attribute
		// _flags_: anything
		//		various flags passed to regExpGen function
		this.locale = "";
		this._flags_ = "";
	}
=====*/

dojo.declare(
	"dijit.form.ValidationTextBox",
	dijit.form.TextBox,
	{
		// summary:
		//		Base class for textbox widgets with the ability to validate content of various types and provide user feedback.
		// tags:
		//		protected

		templateString: dojo.cache("dijit.form", "templates/ValidationTextBox.html", "<div class=\"dijit dijitReset dijitInlineTable dijitLeft\"\r\n\tid=\"widget_${id}\" role=\"presentation\"\r\n\t><div class='dijitReset dijitValidationContainer'\r\n\t\t><input class=\"dijitReset dijitInputField dijitValidationIcon dijitValidationInner\" value=\"&#935; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\r\n\t/></div\r\n\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\r\n\t\t><input class=\"dijitReset dijitInputInner\" dojoAttachPoint='textbox,focusNode' autocomplete=\"off\"\r\n\t\t\t${!nameAttrSetting} type='${type}'\r\n\t/></div\r\n></div>\r\n"),
		baseClass: "dijitTextBox dijitValidationTextBox",

		// required: Boolean
		//		User is required to enter data into this field.
		required: false,

		// promptMessage: String
		//		If defined, display this hint string immediately on focus to the textbox, if empty.
		//		Also displays if the textbox value is Incomplete (not yet valid but will be with additional input).
		//		Think of this like a tooltip that tells the user what to do, not an error message
		//		that tells the user what they've done wrong.
		//
		//		Message disappears when user starts typing.
		promptMessage: "",

		// invalidMessage: String
		// 		The message to display if value is invalid.
		//		The translated string value is read from the message file by default.
		// 		Set to "" to use the promptMessage instead.
		invalidMessage: "$_unset_$",

		// missingMessage: String
		// 		The message to display if value is empty and the field is required.
		//		The translated string value is read from the message file by default.
		// 		Set to "" to use the invalidMessage instead.
		missingMessage: "$_unset_$",

		// message: String
		//		Currently error/prompt message.
		//		When using the default tooltip implementation, this will only be
		//		displayed when the field is focused.
		message: "",

		// constraints: dijit.form.ValidationTextBox.__Constraints
		//		user-defined object needed to pass parameters to the validator functions
		constraints: {},

		// regExp: [extension protected] String
		//		regular expression string used to validate the input
		//		Do not specify both regExp and regExpGen
		regExp: ".*",

		regExpGen: function(/*dijit.form.ValidationTextBox.__Constraints*/ constraints){
			// summary:
			//		Overridable function used to generate regExp when dependent on constraints.
			//		Do not specify both regExp and regExpGen.
			// tags:
			//		extension protected
			return this.regExp; // String
		},

		// state: [readonly] String
		//		Shows current state (ie, validation result) of input (""=Normal, Incomplete, or Error)
		state: "",

		// tooltipPosition: String[]
		//		See description of `dijit.Tooltip.defaultPosition` for details on this parameter.
		tooltipPosition: [],

		_setValueAttr: function(){
			// summary:
			//		Hook so set('value', ...) works.
			this.inherited(arguments);
			this.validate(this._focused);
		},

		validator: function(/*anything*/ value, /*dijit.form.ValidationTextBox.__Constraints*/ constraints){
			// summary:
			//		Overridable function used to validate the text input against the regular expression.
			// tags:
			//		protected
			/* Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved. Licensed under the Apache License 2.0 - http://www.apache.org/licenses/LICENSE-2.0 
			 * WM-4642: WaveMaker added the regExpOptions.
			 */
			return (new RegExp("^(?:" + this.regExpGen(constraints) + ")"+(this.required?"":"?")+"$", constraints.regExpOptions || "")).test(value) &&
				(!this.required || !this._isEmpty(value)) &&
				(this._isEmpty(value) || this.parse(value, constraints) !== undefined); // Boolean
		},

		_isValidSubset: function(){
			// summary:
			//		Returns true if the value is either already valid or could be made valid by appending characters.
			//		This is used for validation while the user [may be] still typing.
			return this.textbox.value.search(this._partialre) == 0;
		},

		isValid: function(/*Boolean*/ isFocused){
			// summary:
			//		Tests if value is valid.
			//		Can override with your own routine in a subclass.
			// tags:
			//		protected
		    
			//return this.validator(this.textbox.value, this.constraints);

		        /* Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved. Licensed under the Apache License 2.0 - http://www.apache.org/licenses/LICENSE-2.0 
			 * WM-3184: WaveMaker replaced above return statement with the caluclation below that says do not show this as invalid
			 * if its empty and has focus, even if it is invalid
			 */
		    var result = this.validator(this.textbox.value, this.constraints);
		    if (!result && this._isEmpty(this.textbox.value) && this.required && isFocused)
			return true;
		    return result;
		},

		_isEmpty: function(value){
			// summary:
			//		Checks for whitespace
			return (this.trim ? /^\s*$/ : /^$/).test(value); // Boolean
		},

		getErrorMessage: function(/*Boolean*/ isFocused){
			// summary:
			//		Return an error message to show if appropriate
			// tags:
			//		protected
			return (this.required && this._isEmpty(this.textbox.value)) ? this.missingMessage : this.invalidMessage; // String
		},

		getPromptMessage: function(/*Boolean*/ isFocused){
			// summary:
			//		Return a hint message to show when widget is first focused
			// tags:
			//		protected
			return this.promptMessage; // String
		},

		_maskValidSubsetError: true,
		validate: function(/*Boolean*/ isFocused){
			// summary:
			//		Called by oninit, onblur, and onkeypress.
			// description:
			//		Show missing or invalid messages if appropriate, and highlight textbox field.
			// tags:
			//		protected
			var message = "";
			var isValid = this.disabled || this.isValid(isFocused);
			if(isValid){ this._maskValidSubsetError = true; }
			var isEmpty = this._isEmpty(this.textbox.value);
			var isValidSubset = !isValid && isFocused && this._isValidSubset();
			this._set("state", isValid ? "" : (((((!this._hasBeenBlurred || isFocused) && isEmpty) || isValidSubset) && this._maskValidSubsetError) ? "Incomplete" : "Error"));
			dijit.setWaiState(this.focusNode, "invalid", isValid ? "false" : "true");

			if(this.state == "Error"){
				this._maskValidSubsetError = isFocused && isValidSubset; // we want the error to show up after a blur and refocus
				message = this.getErrorMessage(isFocused);
			}else if(this.state == "Incomplete"){
				message = this.getPromptMessage(isFocused); // show the prompt whenever the value is not yet complete
				this._maskValidSubsetError = !this._hasBeenBlurred || isFocused; // no Incomplete warnings while focused
/*			}else if(isEmpty){ */
		        /* Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved. Licensed under the Apache License 2.0 - http://www.apache.org/licenses/LICENSE-2.0 
			 * WaveMaker added because messages onEmpty should only be shown onFocus, not both onFocus 
			 * and again onBlur
			 */
			} else if (isEmpty && isFocused) {
				message = this.getPromptMessage(isFocused); // show the prompt whenever there's no error and no text
			}

		        /* Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved. Licensed under the Apache License 2.0 - http://www.apache.org/licenses/LICENSE-2.0 
			 * WaveMaker added because messages were firing on hidden editors, showing messages that the user could not deal with */
		        if (message && wm.isDomShowing(this.domNode))
			    this.set("message", message);


			return isValid;
		},

		displayMessage: function(/*String*/ message){
			// summary:
			//		Overridable method to display validation errors/hints.
			//		By default uses a tooltip.
			// tags:
			//		extension
			dijit.hideTooltip(this.domNode);
			if(message && this._focused){
				dijit.showTooltip(message, this.domNode, this.tooltipPosition, !this.isLeftToRight());
			}
		},

		_refreshState: function(){
			// Overrides TextBox._refreshState()
			this.validate(this._focused);
			this.inherited(arguments);
		},

		//////////// INITIALIZATION METHODS ///////////////////////////////////////

		constructor: function(){
			this.constraints = {};
		},

		_setConstraintsAttr: function(/*Object*/ constraints){
			if(!constraints.locale && this.lang){
				constraints.locale = this.lang;
			}
			this._set("constraints", constraints);
			this._computePartialRE();
		},

		_computePartialRE: function(){
			var p = this.regExpGen(this.constraints);
			this.regExp = p;
			var partialre = "";
			// parse the regexp and produce a new regexp that matches valid subsets
			// if the regexp is .* then there's no use in matching subsets since everything is valid
			if(p != ".*"){ this.regExp.replace(/\\.|\[\]|\[.*?[^\\]{1}\]|\{.*?\}|\(\?[=:!]|./g,
				function (re){
					switch(re.charAt(0)){
						case '{':
						case '+':
						case '?':
						case '*':
						case '^':
						case '$':
						case '|':
						case '(':
							partialre += re;
							break;
						case ")":
							partialre += "|$)";
							break;
						 default:
							partialre += "(?:"+re+"|$)";
							break;
					}
				}
			);}
			try{ // this is needed for now since the above regexp parsing needs more test verification
				"".search(partialre);
			}catch(e){ // should never be here unless the original RE is bad or the parsing is bad
				partialre = this.regExp;
				console.warn('RegExp error in ' + this.declaredClass + ': ' + this.regExp);
			} // should never be here unless the original RE is bad or the parsing is bad
			this._partialre = "^(?:" + partialre + ")$";
		},

		postMixInProperties: function(){
			this.inherited(arguments);
			this.messages = dojo.i18n.getLocalization("dijit.form", "validate", this.lang);
			if(this.invalidMessage == "$_unset_$"){ this.invalidMessage = this.messages.invalidMessage; }
			if(!this.invalidMessage){ this.invalidMessage = this.promptMessage; }
			if(this.missingMessage == "$_unset_$"){ this.missingMessage = this.messages.missingMessage; }
			if(!this.missingMessage){ this.missingMessage = this.invalidMessage; }
			this._setConstraintsAttr(this.constraints); // this needs to happen now (and later) due to codependency on _set*Attr calls attachPoints
		},

		_setDisabledAttr: function(/*Boolean*/ value){
			this.inherited(arguments);	// call FormValueWidget._setDisabledAttr()
			this._refreshState();
		},

		_setRequiredAttr: function(/*Boolean*/ value){
			this._set("required", value);
			dijit.setWaiState(this.focusNode, "required", value);
			this._refreshState();
		},

		_setMessageAttr: function(/*String*/ message){
			this._set("message", message);
			this.displayMessage(message);
		},

		reset:function(){
			// Overrides dijit.form.TextBox.reset() by also
			// hiding errors about partial matches
			this._maskValidSubsetError = true;
			this.inherited(arguments);
		},

		_onBlur: function(){
			// the message still exists but for back-compat, and to erase the tooltip
			// (if the message is being displayed as a tooltip), call displayMessage('')
			this.displayMessage('');

			this.inherited(arguments);
		}
	}
);

dojo.declare(
	"dijit.form.MappedTextBox",
	dijit.form.ValidationTextBox,
	{
		// summary:
		//		A dijit.form.ValidationTextBox subclass which provides a base class for widgets that have
		//		a visible formatted display value, and a serializable
		//		value in a hidden input field which is actually sent to the server.
		// description:
		//		The visible display may
		//		be locale-dependent and interactive.  The value sent to the server is stored in a hidden
		//		input field which uses the `name` attribute declared by the original widget.  That value sent
		//		to the server is defined by the dijit.form.MappedTextBox.serialize method and is typically
		//		locale-neutral.
		// tags:
		//		protected

		postMixInProperties: function(){
			this.inherited(arguments);

			// we want the name attribute to go to the hidden <input>, not the displayed <input>,
			// so override _FormWidget.postMixInProperties() setting of nameAttrSetting
			this.nameAttrSetting = "";
		},

		serialize: function(/*anything*/ val, /*Object?*/ options){
			// summary:
			//		Overridable function used to convert the get('value') result to a canonical
			//		(non-localized) string.  For example, will print dates in ISO format, and
			//		numbers the same way as they are represented in javascript.
			// tags:
			//		protected extension
			return val.toString ? val.toString() : ""; // String
		},

		toString: function(){
			// summary:
			//		Returns widget as a printable string using the widget's value
			// tags:
			//		protected
			var val = this.filter(this.get('value')); // call filter in case value is nonstring and filter has been customized
			return val != null ? (typeof val == "string" ? val : this.serialize(val, this.constraints)) : ""; // String
		},

		validate: function(){
			// Overrides `dijit.form.TextBox.validate`
			this.valueNode.value = this.toString();
			return this.inherited(arguments);
		},

		buildRendering: function(){
			// Overrides `dijit._Templated.buildRendering`

			this.inherited(arguments);

			// Create a hidden <input> node with the serialized value used for submit
			// (as opposed to the displayed value).
			// Passing in name as markup rather than calling dojo.create() with an attrs argument
			// to make dojo.query(input[name=...]) work on IE. (see #8660)
			this.valueNode = dojo.place("<input type='hidden'" + (this.name ? " name='" + this.name.replace(/'/g, "&quot;") + "'" : "") + "/>", this.textbox, "after");
		},

		reset: function(){
			// Overrides `dijit.form.ValidationTextBox.reset` to
			// reset the hidden textbox value to ''
			this.valueNode.value = '';
			this.inherited(arguments);
		}
	}
);

/*=====
	dijit.form.RangeBoundTextBox.__Constraints = function(){
		// min: Number
		//		Minimum signed value.  Default is -Infinity
		// max: Number
		//		Maximum signed value.  Default is +Infinity
		this.min = min;
		this.max = max;
	}
=====*/

dojo.declare(
	"dijit.form.RangeBoundTextBox",
	dijit.form.MappedTextBox,
	{
		// summary:
		//		Base class for textbox form widgets which defines a range of valid values.

		// rangeMessage: String
		//		The message to display if value is out-of-range
		rangeMessage: "",

		/*=====
		// constraints: dijit.form.RangeBoundTextBox.__Constraints
		constraints: {},
		======*/

		rangeCheck: function(/*Number*/ primitive, /*dijit.form.RangeBoundTextBox.__Constraints*/ constraints){
			// summary:
			//		Overridable function used to validate the range of the numeric input value.
			// tags:
			//		protected
			return	("min" in constraints? (this.compare(primitive,constraints.min) >= 0) : true) &&
				("max" in constraints? (this.compare(primitive,constraints.max) <= 0) : true); // Boolean
		},

		isInRange: function(/*Boolean*/ isFocused){
			// summary:
			//		Tests if the value is in the min/max range specified in constraints
			// tags:
			//		protected
			return this.rangeCheck(this.get('value'), this.constraints);
		},

		_isDefinitelyOutOfRange: function(){
			// summary:
			//		Returns true if the value is out of range and will remain
			//		out of range even if the user types more characters
			var val = this.get('value');
			var isTooLittle = false;
			var isTooMuch = false;
			if("min" in this.constraints){
				var min = this.constraints.min;
				min = this.compare(val, ((typeof min == "number") && min >= 0 && val !=0) ? 0 : min);
				isTooLittle = (typeof min == "number") && min < 0;
			}
			if("max" in this.constraints){
				var max = this.constraints.max;
				max = this.compare(val, ((typeof max != "number") || max > 0) ? max : 0);
				isTooMuch = (typeof max == "number") && max > 0;
			}
			return isTooLittle || isTooMuch;
		},

		_isValidSubset: function(){
			// summary:
			//		Overrides `dijit.form.ValidationTextBox._isValidSubset`.
			//		Returns true if the input is syntactically valid, and either within
			//		range or could be made in range by more typing.
			return this.inherited(arguments) && !this._isDefinitelyOutOfRange();
		},

		isValid: function(/*Boolean*/ isFocused){
			// Overrides dijit.form.ValidationTextBox.isValid to check that the value is also in range.
			return this.inherited(arguments) &&
				((this._isEmpty(this.textbox.value) && !this.required) || this.isInRange(isFocused)); // Boolean
		},

		getErrorMessage: function(/*Boolean*/ isFocused){
			// Overrides dijit.form.ValidationTextBox.getErrorMessage to print "out of range" message if appropriate
			var v = this.get('value');
			if(v !== null && v !== '' && v !== undefined && (typeof v != "number" || !isNaN(v)) && !this.isInRange(isFocused)){ // don't check isInRange w/o a real value
				return this.rangeMessage; // String
			}
			return this.inherited(arguments);
		},

		postMixInProperties: function(){
			this.inherited(arguments);
			if(!this.rangeMessage){
				this.messages = dojo.i18n.getLocalization("dijit.form", "validate", this.lang);
				this.rangeMessage = this.messages.rangeMessage;
			}
		},

		_setConstraintsAttr: function(/*Object*/ constraints){
			this.inherited(arguments);
			if(this.focusNode){ // not set when called from postMixInProperties
				if(this.constraints.min !== undefined){
					dijit.setWaiState(this.focusNode, "valuemin", this.constraints.min);
				}else{
					dijit.removeWaiState(this.focusNode, "valuemin");
				}
				if(this.constraints.max !== undefined){
					dijit.setWaiState(this.focusNode, "valuemax", this.constraints.max);
				}else{
					dijit.removeWaiState(this.focusNode, "valuemax");
				}
			}
		},

		_setValueAttr: function(/*Number*/ value, /*Boolean?*/ priorityChange){
			// summary:
			//		Hook so set('value', ...) works.

			dijit.setWaiState(this.focusNode, "valuenow", value);
			this.inherited(arguments);
		}
	}
);

}

if(!dojo._hasResource["wm.base.widget.Editors.dijit"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.widget.Editors.dijit"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */


dojo.provide("wm.base.widget.Editors.dijit");

// the requires below are not removed or made dojo['require'] because their class methods are changed and should be done initially.



// dojo customization: remove tooltip if destroyed
dijit.form._FormWidget.prototype.destroy = function() {
	try {
		wm.fire(this, "_hideTooltip");
		if(this._onChangeHandle){ // destroy called before last onChange has fired
			clearTimeout(this._onChangeHandle);
		}
		dijit._Widget.prototype.destroy.call(this);
	}
	catch(e){
		// do nothing.
		//console.info('error = ', t);
	}
}

// dojo customization: dijit hack to display invalid error only when box is blurred and show valid when focused.
dijit.form.ValidationTextBox.prototype.validate = function(isFocused){
	var message = "";
	var isValid = this.isValid(isFocused);
	var isEmpty = this._isEmpty(this.textbox.value);
	// CHANGE: state ok if is focused
	this.state = (isFocused || isValid || (!this._hasBeenBlurred && isEmpty)) ? "" : "Error";
	this._setStateClass();
	//this.domNode.firstChild.firstChild.style.display = this.state == "Error" ? "" : "none";
	if (isValid)
	dijit.setWaiState(this.focusNode, "invalid", isValid ? "false" : "true");
	// CHANGE: show prompt message if we're empty and focused
	if(isFocused && isEmpty){
		message = this.getPromptMessage(true);
	}
	// CHANGE: if not focused and in error state, show error message
	if(!isFocused && this._hasBeenBlurred){
		if(!message && this.state == "Error"){
			message = this.getErrorMessage(true);
		}
	}
    if (isFocused) {
        var parent = this.domNode;
        while(parent && !dojo.hasClass(parent, "dojoxGridRow")) {
            parent = parent.parentNode;
        }
        if (this.domNode.parentNode) {
	        this._lastRow = parent;
    	    this._lastCol = dojo.indexOf(this.domNode.parentNode.parentNode.parentNode.childNodes, this.domNode.parentNode.parentNode);
    	} else {
  			wm.job("GridValidationNode", 20, this, function() {
  				if (this.domNode.parentNode) {
	     		    this._lastRow = parent;
    	    		this._lastCol = dojo.indexOf(this.domNode.parentNode.parentNode.parentNode.childNodes, this.domNode.parentNode.parentNode);
    			}
  			});

    	}
    }
	this.displayMessage(message);
	// CHANGE: return valid if focused or valid
	return isFocused || isValid;
}



// expose validation process to "owner" (this is a wm concept)
dijit.form.ValidationTextBox.prototype._defaultValidator = dijit.form.ValidationTextBox.prototype.validator;
dijit.form.ValidationTextBox.prototype.validator = function(value, constraints) {
	var
		validator = dijit.form.ValidationTextBox.prototype._defaultValidator,
		valid = validator.call(this, value, constraints);
	return valid && (this.owner && this.owner.validator ? this.owner.validator(value, constraints) : true);
}

// dojo customization: hide tooltip after a delay

dijit.form.ValidationTextBox.prototype.displayMessage = function(message){
	if(this._message == message){     
        return; 
    }
	this._message = message;
	this._cancelHideTooltip();
	dijit.hideTooltip(this.domNode);
    if (message && this.inGrid && !this.domNode.parentNode) {
	/* this.domNode is not currently in the document; must wait until it is */
	wm.job("GridValidationNode", 20, dojo.hitch(this, function() {
	    dijit.showTooltip(message, this.domNode.parentNode || this._lastRow.firstChild.firstChild.firstChild.childNodes[this._lastCol], this.tooltipPosition);
	    dijit._hideTooltipHandle = setTimeout(dojo.hitch(this, function() {
		wm.fire(this, "_hideTooltip");
	    }), 2500);
	}));
    } else if (message && (!this.owner || !this.owner.readonly)){
	    dijit.showTooltip(message, this.domNode, this.tooltipPosition);
	    dijit._hideTooltipHandle = setTimeout(dojo.hitch(this, function() {
		wm.fire(this, "_hideTooltip");
	    }), this.tooltipDisplayTime || 2500);
	}
}

// dojo customization: hide tooltip

dijit.form.ValidationTextBox.prototype._hideTooltip = function() {
	this._cancelHideTooltip();
	wm.hideToolTip();
}
dijit.form.ValidationTextBox.prototype._cancelHideTooltip = function() {
	clearTimeout(dijit._hideTooltipHandle);
	dijit._hideTooltipHandle = null;
}


}

if(!dojo._hasResource["wm.base.widget.Editors.AbstractEditor"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.widget.Editors.AbstractEditor"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */


dojo.provide("wm.base.widget.Editors.AbstractEditor");




// check if a property is not undefined or not same as in the object prototype
wm.propertyIsChanged = function(inValue, inProp, inCtor) {
    var p = (inCtor||0).prototype;
    return p && p[inProp] !== inValue;
}

wm.defaultEmptyValue = function(inType){
    switch(inType){
        case 'Text': return '';
        case 'Number': return 0;

    }
}



dojo.declare("wm.AbstractEditor", wm.Control, {
    _captionTagName: "div",
    // we should use "label", but using label causes the editor to receive events from the label node.  This means accidentlly clicking on a label
    //  while touch scrolling can cause an editor to focus, its popup to popup and all manner of unintended consequences.
    changeKeycodes: [dojo.keys.ENTER, dojo.keys.NUMPAD_ENTER, dojo.keys.DELETE, dojo.keys.BACKSPACE],
    classNames: "wmeditor",

    // default is to only evaluate bindings on the dataValue when in a form when doing an insert operation
    // but designer can also can it to be reevaluated when doing an update operation
    // possible values are "onInsert", "onUpdate", "both"
    dataValueBindingEvaluated: "onInsert",

    /* Formating */
    formatter: '',
    height: "24px",
    width: "300px",
    enableTouchHeight: true,
    mobileHeight: "35px",
    padding: "2",
    border: "0",
    editorBorder: true,

    /* Editor */
    dataValue: null,
    displayValue: null,
    emptyValue: "unset",
    required: false,
    readonly: false,
    ignoreParentReadonly: false,
    editorNode: null,
    isDirty: false,
    _lastValue: "",
    _lastValueReported: "",

    /* Caption */
    caption: "",
    captionPosition: "left",
    captionSize: "100px",
    captionNode: null,
    captionAlign: "right",
    singleLine: true,

    /* Tips */
    helpText: "",

    /* Events */
    changeOnEnter: false,
    changeOnKey: false,
    _updating: 0,

    scrim: true,

    init: function() {
        this._editorConnects = [];
        this.inherited(arguments);
    },
    // If I name it getMinHeight, then it will be used to show the "minHeight" property in the designer; this func is meant to use EITHER a user supplied value OR a best calculation, and that calculation varies at runtime based on various factors, so we do NOT want to write this calculation as a property to widgets.js
    getMinHeightProp: function() {
        if (this.minHeight) return this.minHeight;
        if (this.captionPosition == "left" || this.captionPosition == "right" || !this.caption) {
            return 20;
        } else if (this.captionSize.match(/\%/)) {
            return 40;
        } else {
         return 20 + parseInt(this.captionSize);
     }
    },
    getMinWidthProp: function() {
        if (this.minWidth) return this.minWidth;
        if (this.captionPosition == "top" || this.captionPosition == "bottom" || !this.caption) {
            return 80;
        } else if (this.captionSize.match(/\%/)) {
            return 120;
        } else {
            return 80 + parseInt(this.captionSize);
        }
    },
    createCaption: function() {
        var labeldiv = document.createElement(this._captionTagName);
        var s = labeldiv.style;
        s.padding = "0px";
        s.margin = "0px";

        dojo.addClass(labeldiv, "wmeditor-caption");
        dojo.addClass(labeldiv, "wmlabel");
        labeldiv.innerHTML = this.caption;
        this.domNode.appendChild(labeldiv);
        this.captionNode = labeldiv;
        this.setCaptionAlign(this.captionAlign);
        this.setSingleLine(this.singleLine);
    },
    postInit: function() {
        this.createEditor();
        this.inherited(arguments);
        wm.fire(this, "ownerLoaded"); // TODO: Replace this with call in SelectEditor.postInit
        if (this.captionPosition != "left") this.setCaptionPosition(this.captionPosition);
        this._inPostInit = true;
        this.displayValue = this.getDisplayValue();
        this.dataValue = this.getDataValue();
        this.valueChanged("displayValue", this.displayValue);
        this.valueChanged("dataValue", this.dataValue);
        //this.editorChanged();
        delete this._inPostInit;
    },


    setCaption: function(inCaption) {
        var oldCap = this.caption;
        this.caption = inCaption;
        if (!this.captionNode) return;
        var cap = inCaption + ((this.required && !this.readonly) ? '&nbsp;<span class="wmeditor-required">*</span>' : "");
        this.captionNode.innerHTML = cap;
        if (oldCap && !inCaption || !oldCap && inCaption) {
            dojo.style(this.captionNode, "display", (inCaption) ? "block" : "none");
            this.sizeEditor();
        }
    },
    setCaptionSize: function(inCaptionSize) {
        this.captionSize = inCaptionSize;
        this.sizeEditor();
    },
    setCaptionAlign: function(inCaptionAlign) {
        this.captionAlign = inCaptionAlign;
        if (this.captionNode) {
        dojo.style(this.captionNode, "textAlign", this.captionAlign);
        }
    },
    setCaptionPosition: function(pos) {
        var oldPos = this.captionPosition;
        this.captionPosition = pos;
        if ((oldPos == "left" || oldPos == "right") && (pos == "bottom" || pos == "top")) {
            if (this.height.match(/px/) && parseInt(this.height) < 48) {
                this.setValue("height", "48px");
            }
            this.captionSize = "28px";
        } else if ((pos == "left" || pos == "right") && (oldPos == "bottom" || oldPos == "top")) {
            if (this.bounds.h >= 48) {
                this.setValue("height", this.constructor.prototype.height);
            }
            if (this.captionSize.match(/px/) && parseInt(this.captionSize) < 100) {
                this.captionSize = "100px";
            }
        }
        this.sizeEditor();
    },
    setCaptionPositionLF: function(inPosition, liveform) {
        if (!liveform) {
            liveform = this.isAncestorInstanceOf(wm.LiveFormBase) || this.isAncestorInstanceOf(wm.FormPanel);
        }
        if (liveform) {
            this.setCaptionPosition(liveform.captionPosition);
            this.setCaptionSize(liveform.captionSize);
            this.setCaptionAlign(liveform.captionAlign);
            if (this.constructor.prototype.height == wm.AbstractEditor.prototype.height) this.setValue("height", liveform.editorHeight); // don't set height for large text areas/richtext areas based on editorHeight.
        }
        this.sizeEditor();
    },
    setSingleLine: function(inSingleLine) {
        this.singleLine = inSingleLine;
        var s = this.captionNode.style;
        s.whiteSpace = (inSingleLine) ? "nowrap" : "normal";
        s.overflow = "hidden";
        s.lineHeight = (this.singleLine) ? s.height : "normal";
        if (this.readOnlyNode) this.updateReadOnlyNodeStyle();
    },
    setDisabled: function(inDisabled) {
        this.inherited(arguments);
        if (this.editor) {
        if (this.editor instanceof wm.Control) {
            dojo[this._disabled ? "addClass" : "removeClass"](this.captionNode, "wmeditor-caption-disabled");
        } else if (!wm.isNode(this.editor)) {
            if (this._disabled != this.editor.get("disabled")) {
            this.editor.set("disabled", Boolean(this._disabled));
            dojo[this._disabled ? "addClass" : "removeClass"](this.captionNode, "wmeditor-caption-disabled");
            }
        }
        }
    },

    destroy: function() {
        this.destroyEditor();
        this.inherited(arguments);
    },
    createHelpNode: function() {
        this.helpNode = dojo.create("div", {
            className: "EditorHelpIcon"
        }, this.domNode);
        if (typeof this.helpText == "string") {
			if (wm.isMobile) {
			    this._helpTextTouchStartConnect = this.connect(this.helpNode, "ontouchstart", this, function(e) {
					this._helpTouchPos = {x: e.targetTouches[0].clientX,
										   y: e.targetTouches[0].clientY};
	        	});
			    this._helpTextTouchMoveConnect = this.connect(this.helpNode, "ontouchmove", this, function(e) {
					if (!this._helpTouchPos) return;
					if (Math.abs(this._helpTouchPos.x - e.targetTouches[0].clientX) >= 5 ||
						Math.abs(this._helpTouchPos.y - e.targetTouches[0].clientY) >= 5) {
							delete this._helpTouchPos;
			        }
	        	});
			    this._helpTextTouchEndConnect = this.connect(this.helpNode, "ontouchend", this, function(e) {
					if (!this._helpTouchPos) return;
					app.alert(this.helpText);
				});

			} else {
	            this._helpTextOverConnect = this.connect(this.helpNode, "onmouseover", this, function(e) {
	                wm.job(this.getRuntimeId() + ".helpText", 100, dojo.hitch(this, function() {
	                    var coords = dojo.coords(this.helpNode);
	                    //app.createToolTip(this.helpText, null, {mouseX: coords.x, mouseY: coords.y + coords.h});
	                    app.createToolTip(this.helpText, null, {
	                        mouseX: coords.x,
	                        mouseY: coords.y + coords.h
	                    });
	                }));
	            });
	            this._helpTextOutConnect = this.connect(this.helpNode, "onmouseout", this, function() {
	                wm.job(this.getRuntimeId() + ".helpText", 100, dojo.hitch(this, function() {
	                    if (app.getToolTip() == this.helpText) // make sure tooltip isn't showing another editor's help text
	                    app.hideToolTip();
	                }));

	            });
	        }
        }
        this.connect(this.helpNode, "onclick", this, "onHelpClick");
    },
    onHelpClick: function() {},
    destroyHelpNode: function() {
        dojo.destroy(this.helpNode);
        wm.Array.removeElement(this._connections, this._helpTextOverConnect);
        wm.Array.removeElement(this._connections, this._helpTextOutConnect);
        wm.Array.removeElement(this._connections, this._helpTextTouchStartConnect);
        wm.Array.removeElement(this._connections, this._helpTextTouchMoveConnect);
        wm.Array.removeElement(this._connections, this._helpTextTouchEndConnect);
        dojo.disconnect(this._helpTextOverConnect);
        dojo.disconnect(this._helpTextOutConnect);
        dojo.disconnect(this._helpTextStartConnect);
        dojo.disconnect(this._helpTextMoveConnect);
        dojo.disconnect(this._helpTextEndConnect);
    },
    createEditor: function(inProps) {
        // Its possible for createEditor to be called before postInit where createCaption is called,
        // and we need it for styleEditor to work correctly.
        if (!this.captionNode) this.createCaption();
        if (this.helpText && !this.helpNode) {
            this.createHelpNode();
        }
        this.destroyEditor();
        var n = document.createElement('div');
        this.domNode.appendChild(n);
        this.startTimerWithName("CreateDijit", this.declaredClass);
        this.editor = this._createEditor(n, inProps);
        dojo.attr(this.captionNode, "for", this.editor.id);
        /* TODO: add a nice ontouchstart effect, and use wm.TouchMixin to determine when/if to open the popup
        if (this.editor instanceof wm.Control == false && this.editor.domNode && wm.isMobile && "ontouchstart" in this.editor.domNode) {
            dojo.query(".dijitArrowButton", this.editor.domNode).connect("ontouchstart", this.editor, "openDropDown");
        }*/
        /*
            if (this.editor._onChangeHandle) {
                window.clearTimeout(this.editor._onChangeHandle);
                this.editor._onChangeHandle = null;
            }
        */
        /* this.editor.tagName is an IE safe way of doing this.editor instanceof Node */
        this.editorNode = wm.isNode(this.editor) ? this.editor : this.editor.domNode;
        this.editorNode.style.margin = "0"; // failure to explicitly set these is throwing off my bounds calculations
        this.editorNode.style.padding = "0";
        this.stopTimerWithName("CreateDijit", this.declaredClass);
        // If using html widgets and replacing them with dijits use  "if (this.editor && this.editor.declaredClass) "
        if (this.editor) {
            if (this._disabled) this.setDisabled(this.disabled); // if its disabled, or if its parent is disabled, rerun its disabled logic without changing this.disabled
            this.styleEditor();
            if (this.validationEnabled()) this.validatorNode = this._getValidatorNode();
            this.sizeEditor();
            this.connectEditor();
            this.setRequired(this.required);
            this.setInitialValue();

            /*
            if (this.editor._onChangeHandle) {
                window.clearTimeout(this.editor._onChangeHandle);
                this.editor._onChangeHandle = null;
            }
        */
            this.setReadonly(this.readonly);
        }

        if (this.editor && this.editor.displayMessage && this.editor instanceof dijit._WidgetBase) {
            this.editor.displayMessage = dojo.hitch(this, "_displayMessage");
        }
        return this.editor;
    },
    _displayMessage: function(message) {
        if (!this.showMessages) return;
        var o = dojo.getObject(this.editor.declaredClass);
        if (o) o.prototype.displayMessage.apply(this.editor, arguments);
    },
    validationEnabled: function() { return true;},
    _createEditor: function(inNode, inProps) {
        return new dijit.form.TextBox(this.getEditorProps(inNode, inProps));
    },
    destroyEditor: function() {
        this.disconnectEditor();
        wm.fire(this.editor, "destroy");
        this.editor = null;
    },
    styleEditor: function() {
        if (this.isRelativePositioned){
            if (this.captionNode)
                dojo.addClass(this.captionNode, 'wmInlineDiv');
            return;
        }
        dojo.style(this.editorNode, {position: "absolute"});
        if (this.captionNode)
            dojo.style(this.captionNode, {position: "absolute"});
    },

    sizeEditor: function() {
        if (this._cupdating) return;
        var e = (this.readonly) ? this.readOnlyNode : this.editor;
        if (e) {
            var bounds = this.getContentBounds();
            var position = this.captionPosition;
            var captionEditorSpacing = (position == "left" || position == "right") ? wm.AbstractEditor.captionPaddingWidth : wm.AbstractEditor.captionPaddingHeight;
            var w = bounds.w;
            var h = bounds.h;
            var labelWidth;
            var editorWidth;
            var height = bounds.h; //bounds.h ? bounds.h - ((bounds.h > 20) ? Math.floor(bounds.h * 0.1) : 2) : "";
            var labelHeight;
            var editorHeight;
            var helpIconSize = 16;
            var helpIconMargin = 4;
            var allocateHelpIconSpace = Boolean(this.helpText);
            if (!this.caption || this.captionSize == "0px" || this.captionSize == "0%") {
                labelWidth = 0;
                editorWidth = w;
                editorHeight = h;
            } else if (position == "left" || position == "right") {
                if (this.fixedEditorWidth && position == "right") {
                    editorWidth = this.fixedEditorWidth;
                    labelWidth = w - editorWidth - (this.helpText ? helpIconSize + helpIconMargin : 0);
                    allocateHelpIconSpace = false;
                } else {
                    var minEditorWidth = this.minEditorWidth || wm.isMobile ? 32 : 16;
                    var tmpWidth = (this.captionSize.match(/px/)) ? parseInt(this.captionSize) : Math.floor(parseInt(this.captionSize) * w / 100);
                    if (w - tmpWidth < (minEditorWidth || 0)) {
                        editorWidth = minEditorWidth;
                        labelWidth = w - editorWidth - (this.helpText ? helpIconSize + helpIconMargin : 0);
                        allocateHelpIconSpace = false;
                    } else {
                        labelWidth = tmpWidth;
                        editorWidth = w - labelWidth;
                    }
                }
                //          if (labelWidth) editorWidth -=  18; // TODO: number 18 is a random number that worked out in FF, but needs testing elsewhere
                labelHeight = (height) ? height : "";
                editorHeight = labelHeight;
            } else {
                labelHeight = (this.captionSize.match(/px/)) ? parseInt(this.captionSize) : Math.floor(parseInt(this.captionSize) * height / 100);
                if (labelHeight > height) {
                    labelHeight = height - 16;
                    //if (this.captionSize.match(/px/)) this.captionSize = labelHeight + "px";
                }
                editorHeight = (height - labelHeight);
                labelWidth = (w) ? w : "";
                editorWidth = labelWidth;
                if (this.helpText) labelWidth -= helpIconSize + helpIconMargin;
            }

            labelWidth = Math.round(labelWidth);
            editorWidth = Math.round(editorWidth);
            if (allocateHelpIconSpace) {
                if (this.captionPosition == "left" || !this.caption) {
                    editorWidth -= helpIconSize + helpIconMargin;
                } else {
                    labelWidth -= helpIconSize + helpIconMargin;
                }
            }
            if (this._editorPaddingLeft && labelWidth) editorWidth -= this._editorPaddingLeft;
            if (this._editorPaddingRight && labelWidth) editorWidth -= this._editorPaddingRight;
            var s = this.captionNode.style;
            var labelWidthWithSpacing = (labelWidth - ((position == "right" || position == "left") ? captionEditorSpacing : 0));
            labelWidthWithSpacing = (labelWidthWithSpacing) ? labelWidthWithSpacing : 0;
            if (labelWidthWithSpacing < 0) labelWidthWithSpacing = 0;
            var form = wm.FormPanel && this.isAncestorInstanceOf(wm.FormPanel);
            if (!this.maxCaptionWidth && (!form || !form.autoSizeCaption || form.autoSizeCaption && this._isMaxEditor === false)) {
                s.width = labelWidthWithSpacing + "px";
            } else {
                s.display = "inline-block";
            }
            s.height = ((labelHeight && labelHeight > 0) ? labelHeight : 0) + "px";

            // if height changes, then lineHeight may have to change
            s.lineHeight = (s.lineHeight != "normal") ? s.height : "normal";
            //var captionLeft = (position == "right") ? (bounds.w + bounds.l - labelWidthWithSpacing) : bounds.l;
            var captionLeft = (position == "right") ? (bounds.l + editorWidth + captionEditorSpacing) : bounds.l;
            if (position == "right" && allocateHelpIconSpace) captionLeft -= helpIconSize + helpIconMargin;
            s.left = captionLeft + "px";
            s.top = (position == "bottom") ? (editorHeight + bounds.t - captionEditorSpacing) + "px" : bounds.t + "px";

            var b = {
                w: editorWidth,
                h: editorHeight,
                l: ((position == "left" && labelWidth) ? labelWidth : 0) + bounds.l,
                t: ((position == "top" && labelHeight) ? labelHeight : 0) + bounds.t
            };
            /*
            if (this instanceof wm.Checkbox) {
            b.w = "16";
            b.h = "16";
            }
            */

            if (!b.w || b.w < 0) b.w = 0;
            if (!b.h || b.h < 0) b.h = 0;

            if (e instanceof wm.Control) {
                var oldUpdatingValue = e._cupdating;
                e._cupdating = true; // make sure that we call render only once; setBorder should not call render.
                e.setBorder((this.editorBorder) ? "1" : "0");
                e.setBounds(b);
                e._cupdating = oldUpdatingValue;
                if (e.invalidCss) e.render();
                else e.renderBounds();
                e.reflow();

            } else {
                var setnode = (e["domNode"]) ? e.domNode : e;

                var s = setnode.style;

                if (this.editorBorder && b.w && b.h) {
                    s.borderWidth = "1px";
                    if (!this._editorBackgroundColor) s.backgroundColor = "";
                    s.backgroundImage = "";
                    b.w -= 2;
                    b.h -= 2;
                    if (s.lineHeight != "normal") s.lineHeight = (b.h) + "px"
                } else {
                    s.borderWidth = "0px";
                    if (!this._editorBackgroundColor) s.backgroundColor = "transparent";
                    s.backgroundImage = "none";
                    if (s.lineHeight != "normal" && b.h) s.lineHeight = b.h + "px"
                }
                s.width = b.w + "px";
                s.height = b.h + "px";
                s.left = b.l + "px";
                s.top = b.t + "px";
                /*
                        dojo.style(this.editorNode, {width:  b.w + "px",
                                                     height: b.h + "px",
                                                     left:   b.l + "px",
                                                     top:    b.t + "px"});
                             */
            }
            if (e == this.readOnlyNode) this.updateReadOnlyNodeStyle(b.h);

            this._editorHeight = b.h;
            this._editorWidth = b.w;
        }
        if (this.helpText && this.helpNode) {
            var s = this.helpNode.style;
            s.top = (this.caption) ? (parseInt(this.captionNode.style.top) + (this.captionPosition == "bottom" ? 5 : 0)) + "px" : b.t + "px";
            s.left = (this.getContentBounds().w - 16) + "px";
        }
    },
    setHelpText: function(inText) {
        var formerText = this.helpText;
        this.helpText = inText;
        if (inText && !this.helpNode) {
            this.createHelpNode();
            this.sizeEditor();
        } else if (!inText && this.helpNode) {
            this.destroyHelpNode();
            this.sizeEditor();
        } else if (inText && !formerText) {
            this.sizeEditor();
        }
    },
    updateReadOnlyNodeStyle: function(h) {
        var s = this.readOnlyNode.style;
        var overflow = this.getReadOnlyNodeOverflow();
        if (s.overflow != overflow) s.overflow = overflow;

        var lineHeight = this.getReadOnlyNodeLineHeight();
        if (s.lineHeight != lineHeight) s.lineHeight = (lineHeight == "normal") ? lineHeight : lineHeight + "px";

        var whiteSpace = this.getReadOnlyNodeWhiteSpace();
        if (s.whiteSpace != whiteSpace) s.whiteSpace = whiteSpace;

        var wordWrap = this.getReadOnlyNodeWordWrap();
        if (s.wordWrap != wordWrap) s.wordWrap = wordWrap;
    },
    getReadOnlyNodeLineHeight: function() {
        if (this.singleLine) return parseInt(this.readOnlyNode.style.height) + ((this.editorBorder) ? 2 : 0);
        else return "normal";
    },
    getReadOnlyNodeOverflow: function() {
        return "hidden";
    },
    getReadOnlyNodeWhiteSpace: function() {
        return this.singleLine ? "nowrap" : "";
    },
    getReadOnlyNodeWordWrap: function() {
        return "normal";
    },
    adjustCaptionPositionForMobile: function() {
        if (this.isAncestorHidden()) return;
        if (this.captionPosition == "left" || this.captionPosition == "right") {
            // see if we need to switch to top
            var minWidth = this.getMinWidthProp();

            if (minWidth > this.parent.getContentBounds().w) {
                this._captionPosition = this.captionPosition;
                this._captionAlign = this.captionAlign;
                this._captionSize = this.captionSize;
                this._editorHeight = this.height;
                this.captionPosition = "top";
                this.setCaptionAlign("left");
                var height = parseInt(this.height); // we know height is in px
                this.captionSize = "20px";
                this.bounds.h = height + 20;
                this.setBounds(this.bounds);
                wm.job(this.parent.getRuntimeId() + ".adjustForMobileEditorCaption", 1, this.parent, function() {
                    if (!this.isDestroyed) {
                        this.setBestHeight();
                        this._heightAdjustedForMobileCaption = true;
                        if (this.bounds.h > this.parent.bounds.h) {
                            this.setAutoScroll(true);
                        }
                    }
                });
            }
        } else if (this._captionPosition) {
            this.captionPosition = this._captionPosition;
            var captionSizeWas = this.captionSize;
            this.captionSize = this._captionSize;
            var minWidth = this.getMinWidthProp(true);
            this.captionPosition = "top";
            this.captionSize = captionSizeWas;
            if (minWidth <= this.parent.getContentBounds().w) {
                this.captionPosition = this._captionPosition;
                delete this._captionPosition;
                this.setCaptionAlign(this._captionAlign);
                delete this._captionAlign;
                this.captionSize = this._captionSize;
                delete this._captionSize;
                this.bounds.h = this._editorHeight;
                delete this._editorHeight;
                this.setBounds(this.bounds);
                wm.job(this.parent.getRuntimeId() + ".adjustForMobileEditorCaption", 1, this.parent, function() {
                    if (!this.isDestroyed && this._heightAdjustedForMobileCaption) {
                        this.setBestHeight();
                    }
                });
            }
        }
    },

    renderBounds: function() {
        if (!this._initializing && wm.device == "phone" && this.parent.layoutKind == "top-to-bottom" && !this._percEx.h) {
            this.adjustCaptionPositionForMobile();

        }
        this.inherited(arguments);
        this.sizeEditor();
    },
    // TODO: Changing this from true to false works, changing from false to true does not; this was true back when wm.Editor was in use as well.
    setEditorBorder: function(inEditorBorder) {
        this.editorBorder = inEditorBorder;
            this.sizeEditor();
    },
    addEditorConnect: function(inConnect) {
        this._editorConnects.push(dojo.connect.apply(dojo, arguments));
    },
    connectEditor: function() {
        this.disconnectEditor();
        this.addEditorConnect(this.editor, "onChange", this, "changed");
        this.addEditorConnect(this.editor, "onBlur", this, "blurred");
        this.addEditorConnect(this.editor, "_onFocus", this, "focused");
        var editorNode = this.editor.focusNode || this.editor.domNode || this.editor;
        this.addEditorConnect(editorNode, "onkeypress", this, "keypressed");
        if (editorNode.tagName == "INPUT") {
            try {
                this.addEditorConnect(editorNode, "oncut", this, "keypressed");
                this.addEditorConnect(editorNode, "onpaste", this, "keypressed");
            } catch(e) {}
        }


/*
        this.addEditorConnect(this.editor.domNode, "onkeypress", this, "keypressed");
        this.addEditorConnect(this.editor.domNode, "onkeypress", this, "dokeypress");
*/
        if (this.validationEnabled())
          this.addEditorConnect(this.editor, "validate", this, "editorValidated");
    },
    disconnectEditor: function() {
        dojo.forEach(this._editorConnects, dojo.disconnect);
        this._editorConnects = [];
    },
    invalidate: function() {
        delete this._isValid;
    },
    keypressed: function(inEvent){
        /* Generally speaking, there aren't modifier keys in mobile devices (though I expect that to change); and I wasn't getting any charCode OR keyCode from some
         * mobile browsers (chrome for android)
         */
        if (inEvent.type == "cut" || inEvent.type == "paste" || wm.isMobile || inEvent.charCode || inEvent.keyCode == dojo.keys.BACKSPACE || inEvent.keyCode == dojo.keys.DELETE || dojo.indexOf(this.changeKeycodes, inEvent.keyCode) != -1) {
        this.validate();
            this.dokeypress(inEvent);
        }
    },
    blurred: function() {
        this.validate();
        this.doOnblur();
    },
    focused: function() {
            dojo.publish("wm.AbstractEditor-focused", [this]);
        this.doOnfocus();
    },
    doOnblur: function() {
        if (!this.disabled) {
            /* Sometimes values don't update before the event fires; build in a delay before the event handler so
             * values have time to update before firing the handler.
             */
            wm.onidle(this, function() {
                this.onblur();
            });
        }
    },
    onblur: function() {},
    doOnfocus: function() {
        if (!this.disabled) {

            /* Sometimes values don't update before the event fires; build in a delay before the event handler so
             * values have time to update before firing the handler.
             */
            wm.onidle(this, function() {
                this.onfocus();
            });
        }
    },
    onfocus: function() {},
    changed: function() {
        this.validate();
        this.doOnchange();
    },
    doOnchange: function() {
        if (this.editorChanged()) {
            var e = this.editor;
            if (!this._loading && !this.isUpdating() && !this.readonly && e && !this.isLoading()) {
                this.onchange(this.getDisplayValue(), this.getDataValue(), this._inSetDataValue);
            }
        }
    },
    onchange: function(inDisplayValue, inDataValue, inSetByCode) {},
    _getValidatorNode: function() {
        var n = this.editor && this.editor instanceof dijit._WidgetBase && this.editor.domNode.firstChild;
        if (!n)
        {
            return null;
        }
        for (var i=0, c, children=n.childNodes; c=children[i]; i++)
            if (dojo.hasClass(c, "dijitValidationIcon"))
                return c;
    },
    editorValidated: function() {
        if (this.validatorNode)
            this.validatorNode.style.display = this.editor.state == "Error" ? "" : "none";
    },
    validate: function() {
        if (this.validationEnabled())
            this.invalidate();

            // just because the editor doesn't have validation doesn't mean that the container won't need to validate the sum of all inputs
        wm.job(this.getRuntimeId() + "_validate", 25, dojo.hitch(this, function() {
            if (!this.isDestroyed) {
            if (this.parent)
                wm.fire(this.parent, "validate");
            this.valueChanged("invalid", this.getInvalid());
            }
        }));
    },
    getEditorProps: function(inNode, inProps) {
        return dojo.mixin({srcNodeRef: inNode, owner: this, disabled: this.disabled}, inProps || {});
    },
    isValid: function() {
        return !this.getInvalid();
    },
    getInvalid: function() {
        var validationEnabled = this.validationEnabled();
        if (validationEnabled && this.editor && this.editor.isValid) { /* test for existence of isValid method */
            if (this._isValid === undefined) this._isValid = this.editor.isValid();
            return !(this.readonly || this._isValid);
        } else if (this.required && !this.readonly) {
            var value = this.getDataValue();
            if (value === undefined || value === null || value === "") {
                return true;
            }
        }
    },

    setInvalid: function(inValue) {
        if (inValue === undefined) inValue = true;
        this._isValid = false;
        if (this.editor instanceof dijit._WidgetBase) {
            this.editor.set("state",inValue ? "Error" : "");
        }
        this.editorValidated();
        this.valueChanged("invalid", Boolean(inValue));
    },
    _getReadonlyValue: function() {
        return this.getDisplayValue() || "";
    },
    createReadOnlyNode: function() {
        var node = dojo.create("div");
        dojo.addClass(node, "wmeditor-readonlyNode");
		dojo.attr(node, "role", "textbox");
		dojo.attr(node, "aria-readonly", true);
		dojo.attr(node, "aria-labelledby", this.domNode.id);
        var readstyle = node.style;
        readstyle.lineHeight = "normal";
        readstyle.position = "absolute";
        readstyle.whiteSpace =  (this.singleLine) ? "nowrap" : "normal";
        return node;
    },

    // TODO: If editor gets resized, what will the readOnlyNode do?
    setReadonly: function(inReadonly, hideOrShowEditor) {
        var r = this.readonly;
        this.readonly = inReadonly;
        if (r != this.readonly)
            this.setCaption(this.caption);

        var domNode = this.domNode;

        // Insure we have a readonly node, let each subclass override what the readonly node actually consists of
        if (!this.readOnlyNode && this.readonly)
            this.readOnlyNode = this.createReadOnlyNode();

        // If there is a readOnlyNode, then take care of adding/removing it from our domNode.
        if (this.readOnlyNode) {
            // If we're in readonly mode, and the readonly node is not in our domNode, add it in.
            if (this.readonly && this.readOnlyNode.parentNode != domNode)
                dojo.place(this.readOnlyNode, domNode,  "last");
            // If we are NOT in readonly mode, and the readonly node is within our domNode, remove it.
            else if (!this.readonly && this.readOnlyNode.parentNode == domNode)
                domNode.removeChild(this.readOnlyNode);
        }

        if (hideOrShowEditor) {
        if (this.readonly)
          this.editorNode.style.display = 'none';
        else
          this.editorNode.style.display = 'block';
        } else {
            // Add or remove the editorNode from our domNode
            if (!this.readonly && this.editorNode.parentNode != domNode)
                dojo.place(this.editorNode, domNode, "last");
            else
                if (this.readonly && this.editorNode.parentNode == domNode)
                    domNode.removeChild(this.editorNode);
        }

        this.invalidCss = true;
        this.render();

        if (this.readonly)
            wm.fire(this.editor,"_hideTooltip");

        this.updateReadonlyValue();
    },

    updateReadonlyValue: function(inValue) {
        if (this.readonly && this.readOnlyNode) {
            var value;
            if (this.$.format && this.$.format.declaredClass != "wm.DataFormatter") {
                value = this.$.format.format(inValue || this.getDataValue());
            } else if (this.formatter && dojo.isFunction(this.owner[this.formatter])) {
                try {
                    value = this.owner[this.formatter](this, inValue || this.getDataValue());
                } catch (e) {
                    console.error("Formatter error in " + this.toString() + ": " + e);
                }
            }
            if (value === undefined) {
                value = inValue || this._getReadonlyValue();
            }
            this.readOnlyNode.innerHTML = value;
        }
    },

    getDisplayValue: function() {
        return this.editor && this.editor.declaredClass &&  this.editor.get && this.editor.get('displayedValue') ? this.editor.get('displayedValue') || "" : this.getEditorValue() || "";
    },
    makeEmptyValue: function() {
        // this.display is only set by LiveForm therefore will only work for fields in LiveForm and their emptyValue is not set yet.
        if (this.emptyValue == 'unset' && this.display)
            return wm.defaultEmptyValue(this.display);

        switch (this.emptyValue) {
            case "null": return null;
            case "false": return false;
            case "emptyString": return "";
            case "zero": return 0;
        }
    },
    getEditorValue: function() {
        var v;
        // If using html widgets and replacing them with dijits use
        // v = (this.editor.declaredClass) ? this.editor.attr('value') : this.editor.value;
        if (this.editor)
            v = this.editor.get('value') ;

        return (v || v === 0) ? v : this.makeEmptyValue();
    },
    normalizeDataValue: function(inValue) {return inValue;},
    setEditorValue: function(inValue) {
        if (this.editor) { // If using html widgets and replacing them with dijits use  if (this.editor && this.editor.declaredClass) {
            inValue = inValue === undefined ? null : inValue;
            inValue = this.normalizeDataValue(inValue);
            var oldValue = this.editor.get('value');
            this.editor.set('value', inValue, false);

            /* Bug in dojo causes this value NOT to be updated if we pass in "false" as our last
             * parameter to set("value"); we pass in false so we can maintain an easier to
             * understand syncrhonous setting of values and triggering of side effects */
            this.editor._lastValueReported = inValue ? inValue : "";
            if (oldValue != inValue) {
                this.changed();
            } else if ((typeof inValue != "object" || inValue === null) && this.dataValue !== inValue) {
                this.displayValue = this.getDisplayValue();
                this.dataValue = this.getDataValue();
            }

            /* If updateReadonlyValue is called before this.changed, then this.dataValue will not yet have been set */
            this.updateReadonlyValue();
        } else {
            this.dataValue = inValue;
        }
    },

    setDisplayValue: function(inValue) {
        this.setEditorValue(inValue);
    },
    setRequired: function(inValue) {
            var oldValue = this.required;
        this.required = inValue;
        if (this.editor) {
            this.editor.required = inValue;
            if (this.required || oldValue) {
                this.validate();
                this.setCaption(this.caption);
            }
        }
    },

    getRequired: function(){
        return this.required;
    },

    beginEditUpdate: function(inProp) {
        this._updating++;
    },
    endEditUpdate: function(inProp) {
        this._updating--;
    },
    requireChanged: function() {
        this.setCaption(this.caption);
    },
    setInitialValue: function() {
        this.beginEditUpdate();
        try {
            this.setEditorValue(wm.propertyIsChanged(this.dataValue, "dataValue", this.constructor) ? this.dataValue : this.displayValue);
        } catch(e) {}
        this.endEditUpdate();
        this.clearDirty(true);
    },

    /* EditorChanged is called when we think that the editor has changed values.  If it returns false however,
     * it has concluded that the editor has not in fact changed.
     * If you need to set this.dataValue/this.displayValue before editorChanged is called, then you should
     * use a subclass that provides its own editorChanged method, and which returns true.
     * Added to prevent onblur from firing bindings and onchange events if onKeyPress already fired that change.
     */
    editorChanged: function() {
        var displayValue = this.getDisplayValue();
        var changed = false;
        if (this.displayValue != displayValue) {
            this.valueChanged("displayValue", this.displayValue = displayValue);
            changed = true;
        }

        var dataValue = this.getDataValue();
        if (this.calcIsDirty(dataValue, this._lastValueReported)) {
            this.valueChanged("dataValue", this.dataValue = dataValue);
            changed = true;
        } else {
            this.dataValue = dataValue; // its possible for _lastValueReported to not be stored in this.dataValue, though its probably just a special case for DataSet editors
        }
        if (changed) {
            /* NOTE: editorChanged is called when the user types OR when setDataValue is called
             * _lastValue must NOT be updated if its caused by the user typing, so its cleared from
             * setDataValue instead.  But _inPostInit gets special treatment.
             */
            if (this._inPostInit) {
                this._lastValue = this.dataValue;
            }
            this.updateIsDirty();
        }
        return changed;
        //wm.fire(this.editor, "ownerEditorChanged");
    },

    calcIsDirty: function(val1, val2) {
        if (val1 === undefined || val1 === null) val1 = "";
        if (val2 === undefined || val2 === null) val2 = "";
        return val1 != val2;
    },
    clearDirty: function(noEvent) {
        this._lastValueReported = this._lastValue = this.dataValue == null ? this.makeEmptyValue() : this.dataValue;
        this.updateIsDirty();
    },
    updateIsDirty: function() {
        var wasDirty = this.isDirty;
        var isDirty = true;
        if (this._initializing) {
            isDirty = false;
            this._lastValueReported = this._lastValue = this.dataValue == null ? this.makeEmptyValue() : this.dataValue;
        } else if (!this.calcIsDirty(this.dataValue, this._lastValue)) {
            isDirty = false;
        } else if ((this.dataValue === "" || this.dataValue === null || this.dataValue === undefined) && (this._lastValue === "" || this._lastValue === null || this._lastValue === undefined)) {
            isDirty = false;
        }
        this.valueChanged("isDirty", this.isDirty = isDirty);
        if (wasDirty != this.isDirty) dojo.toggleClass(this.domNode, "isDirty", this.isDirty);
        if (!app.disableDirtyEditorTracking) wm.fire(this.parent, "updateIsDirty");
    },
    getDataValue: function() {
        if (this.isReady()) {
            return this.getEditorValue();
        } else if (this.dataValue === null || this.dataValue === undefined || this.dataValue === "") {
            return this.makeEmptyValue();
        } else {
            return this.dataValue;
        }
    },

    setDataValue: function(inValue) {
        this._inSetDataValue = true;
        // for simplicity, treat undefined as null
        if (inValue === undefined)
        inValue = null;
/*
        this._lastValue  = inValue instanceof wm.Variable ? inValue.getData() : inValue;
        if (this._lastValue == null)
            this._lastValue = this.makeEmptyValue();
        */
        this.setEditorValue(inValue);
        if (inValue === "" || inValue === null)
            this.resetState();
        if (!this.isUpdating())
            this.clearDirty(); // calls to setDataValue should always clear the dirty indicator and assume the input value is "Good"
        delete this._inSetDataValue;
    },
    isUpdating: function() {
        return this._updating > 0;
    },

    // used to determine if the editor is ready to send and receive values
    isReady: function() {
        return Boolean(this.editor);
    },
    canFocus: function() {
        return !this.readonly;
    },
    focus: function() {
        wm.fire(this.editor, "focus");
    },
    reset: function() {
        this.setDataValue(this._lastValue);
        this.resetState();
    },
    resetState: function() {
        this.invalidate();
        var e = this.editor;
        if (e && e instanceof dijit._WidgetBase) {
            e._hasBeenBlurred = false;
            wm.fire(e, "_hideTooltip");
            if (this.validatorNode && !this.getDisplayValue()) {
                this.validatorNode.style.display = "none";
                e.set("state", "Normal");
                e._setStateClass();
            }
        }
    },
    clear: function() {
        //this.setEditorValue(null);
            this._lastValue = this.makeEmptyValue();

            this.setDataValue(null);  // changed from setEditorValue because setEditorValue does not handle readonly editor
            //this.resetState();  called by setDataValue now
    },
    // design time
    listOwnerProperties: function() {
        var p = dojo.mixin({}, wm.Component.prototype.listProperties.apply(this) || {});
        // include properties intended for editor's owner
        for (var i in p) {
            if (!p[i].isOwnerProperty)
                delete p[i];
        }
        return p;
    },
    listProperties: function() {
        var p = dojo.mixin({}, this.inherited(arguments) || {});
        // exclude properties intended for editor's owner
        // This will exclude owner props from serialization by default.
        // If these properties are *not* serialized in the owner and should be serialized
        // then override isWriteableProp and serialize here.
        for (var i in p) {
            if (p[i].isOwnerProperty)
                delete p[i];
        }
        return p;
    },
    valueChanged: function(inProp, inValue) {
        if (this._updating && (inProp == "dataValue" || inProp == "isDirty" || inProp == "displayValue" || inProp == "invalid"))
            return;
        if (inProp == "dataValue")
        this._lastValueReported = inValue;
        this.inherited(arguments);
        //if (this.isDesignLoaded() && inProp)
        //  this.createEditor();
    },
    isLoading: function() {
        return this._loading;
    },
    dokeypress: function(inEvent) {
        if (this.changeOnKey || (this.changeOnEnter && inEvent.keyCode == dojo.keys.ENTER)) wm.onidle(this, "doChangeOnKey", inEvent);
        if (inEvent.keyCode == dojo.keys.ENTER) wm.onidle(this, "onEnterKeyPress", [this]);
    },

    doChangeOnKey: function(inEvent) {
        var e = this.editor;
            //e.set("value",e.get("value"));
        this.changed();
    },

    setDefaultOnInsert: function() {
        if (this.editor && this.defaultInsert !== undefined) {
            if (this.$.binding && this.$.binding.wires.defaultInsert) this.$.binding.wires.defaultInsert.refreshValue();

            this.editor.set('value', this.defaultInsert, false);
            this.invalidate();
        }
    },

    onEnterKeyPress: function() {},


    toHtml: function(inWidth) {
        var remainingWidth = inWidth - 4; // always seem to need a 4px buffer to avoid wrapping
        var margin = "2px 4px 2px 4px";
        remainingWidth -= 8; // margin for the wrapper div
        remainingWidth -= 2; // border for the editor
        var captionSize = 125;
        var topToBottomLayout = (remainingWidth - captionSize < 100 || this.captionPosition == "top" || this.captionPosition == "bottom");
        var style = this.toHtmlStyles();
        if (this.caption && this.captionSize != "0px" && this.captionSize != "0%" && !topToBottomLayout) {
            var captionPadding = 4;
            var editorSize = remainingWidth - captionSize;
            return "<div " + style + " class='wmeditor' id='" + this.domNode.id + "' style='margin: " + margin + ";'><div class='wmeditor-label' style='width:" + (captionSize - captionPadding) + "px;padding-right:" + captionPadding + "px;display:inline-block;'>" + this.caption + "</div><div class='wmeditor-value' style='display: inline-block;width:" + editorSize + "px'>" + (this.getDisplayValue() || "&nbsp;") + "</div></div>";
        } else {
            var html = [];
            html.push("<div " + style + " class='wmeditor' id='" + this.domNode.id + "' style='margin: " + margin + ";'>");
            if (this.caption && this.captionSize != "0px" && this.captionSize != "0%") {
                html.push("<div class='wmeditor-label' >" + this.caption + "</div>");
            }
            html.push("<div class='wmeditor-value'>" + (this.getDisplayValue() || "&nbsp;") + "</div>");
            html.push("</div>");
            return html.join("\n");
        }
    }

});

wm.AbstractEditor.captionPaddingWidth = 8;
wm.AbstractEditor.captionPaddingHeight = 2;

/* A subclass of AbstractEditor whose "editor" property points to a Container instead of a dijit */
dojo.declare("wm.AbstractEditorContainer", wm.AbstractEditor, {
    containerLayoutKind: "left-to-right",
    editorBorder: false,
    /* Sublcasses should override this, but should create the container using this.inherited(arguments)
     * For a single row of controls, use padding: "0" on any editors.
     */
    _createEditor: function(inNode, inProps) {
        this.editor = new wm.Container({
            owner: this,
            parent: this,
            name: "editContainer",
            width: "100%",
            height: "100%",
            padding: "0",
            margin: "0",
            layoutKind: this.containerLayoutKind,
            verticalAlign: "top",
            horizontalAlign: "left"
        });
        return this.editor;
    },
    _onShowParent: function() {
        if (this.editor) this.editor.callOnShowParent();
    },
    _onHideParent: function() {
        if (this.editor) this.editor.callOnHideParent();
    },
    sizeEditor: function() {
        this.inherited(arguments);
        this.flow();
    },
    flow: function() {
        if (this.editor) {
            this.editor.flow();
        }
    },
     setDisabled: function(inValue) {
        wm.Control.prototype.setDisabled.call(this, inValue);
        /*if (this.editor) {
            this.editor._parentDisabled = this._disabled;
            this.editor.setParentDisabled(inValue);
        }*/
    },
    focus: function(inValue) {}, // TODO: Subclass should override this method
    blur:  function(inValue) {}, // TODO: Subclass should override this method
    _getValidatorNode: function() {
        return null;
    },
    setEditorValue: function(inValue) {// TODO: Override this
        this.dataValue = inValue;
    },
    getEditorValue: function() { // TODO: Override this unless your maintaining dataValue (which is probably a good practice)
        return this.dataValue;
    }
});




}

if(!dojo._hasResource["dijit.form.SimpleTextarea"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.SimpleTextarea"] = true;
dojo.provide("dijit.form.SimpleTextarea");




dojo.declare("dijit.form.SimpleTextarea",
	dijit.form.TextBox,
	{
	// summary:
	//		A simple textarea that degrades, and responds to
	// 		minimal LayoutContainer usage, and works with dijit.form.Form.
	//		Doesn't automatically size according to input, like Textarea.
	//
	// example:
	//	|	<textarea dojoType="dijit.form.SimpleTextarea" name="foo" value="bar" rows=30 cols=40></textarea>
	//
	// example:
	//	|	new dijit.form.SimpleTextarea({ rows:20, cols:30 }, "foo");

	baseClass: "dijitTextBox dijitTextArea",

	attributeMap: dojo.delegate(dijit.form._FormValueWidget.prototype.attributeMap, {
		rows:"textbox", cols: "textbox"
	}),

	// rows: Number
	//		The number of rows of text.
	rows: "3",

	// rows: Number
	//		The number of characters per line.
	cols: "20",

	templateString: "<textarea ${!nameAttrSetting} dojoAttachPoint='focusNode,containerNode,textbox' autocomplete='off'></textarea>",

	postMixInProperties: function(){
		// Copy value from srcNodeRef, unless user specified a value explicitly (or there is no srcNodeRef)
		// TODO: parser will handle this in 2.0
		if(!this.value && this.srcNodeRef){
			this.value = this.srcNodeRef.value;
		}
		this.inherited(arguments);
	},

	buildRendering: function(){
		this.inherited(arguments);
		if(dojo.isIE && this.cols){ // attribute selectors is not supported in IE6
			dojo.addClass(this.textbox, "dijitTextAreaCols");
		}
	},

	filter: function(/*String*/ value){
		// Override TextBox.filter to deal with newlines... specifically (IIRC) this is for IE which writes newlines
		// as \r\n instead of just \n
		if(value){
			value = value.replace(/\r/g,"");
		}
		return this.inherited(arguments);
	},

	_previousValue: "",
	_onInput: function(/*Event?*/ e){
		// Override TextBox._onInput() to enforce maxLength restriction
		if(this.maxLength){
			var maxLength = parseInt(this.maxLength);
			var value = this.textbox.value.replace(/\r/g,'');
			var overflow = value.length - maxLength;
			if(overflow > 0){
				if(e){ dojo.stopEvent(e); }
				var textarea = this.textbox;
				if(textarea.selectionStart){
					var pos = textarea.selectionStart;
					var cr = 0;
					if(dojo.isOpera){
						cr = (this.textbox.value.substring(0,pos).match(/\r/g) || []).length;
					}
					this.textbox.value = value.substring(0,pos-overflow-cr)+value.substring(pos-cr);
					textarea.setSelectionRange(pos-overflow, pos-overflow);
				}else if(dojo.doc.selection){ //IE
					textarea.focus();
					var range = dojo.doc.selection.createRange();
					// delete overflow characters
					range.moveStart("character", -overflow);
					range.text = '';
					// show cursor
					range.select();
				}
			}
			this._previousValue = this.textbox.value;
		}
		this.inherited(arguments);
	}
});

}

if(!dojo._hasResource["wm.base.widget.Editors.Text"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.widget.Editors.Text"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */


dojo.provide("wm.base.widget.Editors.Text");



/* We may want to move this class to another file */
dojo.declare("wm.ResizableEditor", wm.AbstractEditor, {
    maxHeight: 96,
    // only used if autoSizeHeight is enabled; and height is in pixels
    /*
    sizeEditor: function() {
        this.inherited(arguments);
        if(this._cupdating) return;
            if ((this.autoResizeHeight || this.autoResizeWidth) && !this._autoResizing)
            this.scheduleAutoResize();

            if (this.readOnlyNode)
            this.disruptChromeOverflow("readOnlyNode");
    },
        */
    getReadOnlyNodeLineHeight: function() {
        if (this.autoSizeHeight) return "normal";
        else return this.inherited(arguments);
    },
    getReadOnlyNodeWhiteSpace: function() {
        // if autoSizeWidth, all text goes on a single line
        if (this.autoSizeWidth) return "nowrap";
        // if autoReszieHeight, text must wrap
        else if (this.autoSizeHeight) return "normal";
        // else, autosize isn't used; revert to default behaviors
        else return this.singleLine ? "nowrap" : "normal";
    },
    getReadOnlyNodeOverflow: function() {
        // doAutoResize adjusts this value
        // scrollbars for a node less than 40px high is pretty much useless; even 40 is questionable
        if (dojo.marginBox(this.readOnlyNode).h < 40) return "hidden";
        if (this.autoSizeHeight || this.autoSizeWidth) return (this._autoSizeNeedsOverflow) ? "auto" : "hidden";
        else return "hidden";
    },
    updateReadonlyValue: function(inValue) {
        this.inherited(arguments);
        // the test for width is actually a test to see if sizeEditor has been called; we can't autoSize if caption and readOnlyNode have not yet been assigned an initial size
        if (this.readonly && this.readOnlyNode && this.readOnlyNode.style.width && (this.autoSizeHeight || this.autoSizeWidth)) this.doAutoSize(1, 1);
    },
    /*
        setAutoResizeHeight: function(inValue, noupdate) {
        this.autoSizeHeight = inValue;
        if (inValue) {
            this.autoSizeWidth = false;
            this.height = this.bounds.h + "px"; // can't be % sized anymore
            this._percEx.h = 0;  // Has to be done with setting width to px.
        }
        if (this.readOnlyNode) {
            this.updateReadOnlyNodeStyle();
            if (this.readOnlyNode && inValue && !noupdate && this.readonly)
            this.autoSize();
        }
        if (this.isDesignLoaded() && studio.inspector) wm.fire(studio.inspector, "reinspect");
    },

        setAutoResizeWidth: function(inValue, noupdate) {
        if (inValue && this.isDesignLoaded()) {
        // Only one editor in a left-to-right layout can be autoSizeWidth; clear all others
        if (this.parent.layoutKind == "left-to-right") {
            var siblings = this.parent.c$;
            var length = siblings.length;
            for (var i = 0; i < length; i++) {
                if (siblings[i] != this && siblings[i].autoSizeWidth) this.setAutoResizeWidth(false);
            }
        }
        this.width = this.bounds.w + "px"; // can't be % sized anymore
        this._percEx.w = 0;  // Has to be done with setting width to px.
        }
        this.autoSizeWidth = inValue;
        if (inValue)
            this.autoSizeHeight = false;
        if (this.readOnlyNode) {
            this.updateReadOnlyNodeStyle();
            if (this.readOnlyNode && inValue && !noupdate && this.readonly)
            this.autoSize();
        }
        if (this.isDesignLoaded() && studio.inspector) wm.fire(studio.inspector, "reinspect");
    },

        scheduleAutoResize: function() {
        if (!this.autoSizeHeight && !this.autoSizeWidth || !this.readonly || this._autoSizeScheduled) return;
        if (!this._autoSizeScheduled) {
        this._autoSizeScheduled = true;
        wm.onidle(this, "doAutoSize", true);
        }
    },
        */
    // requireScheduled is for internal use only; call this without parameters
    // requireScheduled means that if autoResize is called, and scheduled has already been set to false, then we no longer need to perform this scheduled resize.

    _onShowParent: function() {
        if (this._needsAutoSize) {
            wm.job(this.getRuntimeId() + ".autoSize", 1, dojo.hitch(this, "doAutoSize"));
        }
    },
    doAutoSize: function(setSize, force) {
        if (!this.readonly) return;

        if (this._doingAutoSize || !this.autoSizeHeight && !this.autoSizeWidth) return;
        if (!force && !this._needsAutoSize) return;

        if (this.isAncestorHidden()) {
            return;
        }


        this._doingAutoSize = true;
        this._needsAutoSize = false;


        var bases = this.readOnlyNode.style;
        var divObj = wm.Label.sizingNode;
        divObj.innerHTML = this.readOnlyNode.innerHTML;
        divObj.className = this.readOnlyNode.className; // make sure it gets the same css selectors as this.domNode (we may need to handle ID as well, but most styling is done via classes)
        var s = divObj.style;
        s.position = "absolute";

        s.paddingRight = "5px";
        s.paddingTop = "5px";

        // wm.Label sets these, need to make sure they are unset for wm.Html
        s.lineHeight = bases.lineHeight;
        s.whiteSpace = bases.whiteSpace;

        // append to parent so that it gets the same css selectors as this.domNode.
        this.domNode.appendChild(divObj);

        // TODO: Does not yet handle case where current height is less than the captionSize
        if (this.autoSizeHeight && !this._percEx.h) {
            s.height = "";
            s.width = bases.width;

            var readonlyHeight = divObj.clientHeight;

            var newHeight = readonlyHeight;
            if (this.caption) {
                if (this.captionPosition == "top" || this.captionPosition == "bottom") {
                    newHeight += parseInt(this.captionNode.style.height) + wm.AbstractEditor.captionPaddingHeight;
                }
            }

            var minHeight = this.getMinHeightProp();
            if (minHeight > newHeight) newHeight = minHeight;
            // scrollbars for a node less than 40px high is pretty much useless; even 40 is questionable
            if (this.maxHeight && this.maxHeight < newHeight && (dojo.marginBox(this.readOnlyNode).h > 40)) {
                newHeight = this.maxHeight;
                bases.overflow = "auto";
                this._autoSizeNeedsOverflow = true;
            } else {
                bases.overflow = "hidden";
                this._autoSizeNeedsOverflow = false;
            }
            if (setSize) this.setHeight(newHeight + "px");
            else {
                this.bounds.h = newHeight;
                this.height = newHeight + "px";
            }
        } else if (this.autoSizeWidth && !this._percEx.w) {
            var maxWidth;
            if (this.parent.layoutKind == "left-to-right") {
                maxWidth = this.parent.layout.getMaxFreeSpace(this.parent.c$, "w", this.parent.bounds.w);
                maxWidth += this.bounds.w;
            } else {
                maxWidth = this.parent.getCurrentMaxWidth();
            }

            //this.domNode.style.width = maxWidth + "px"; // give it some room to work with
            s.height = bases.height;
            s.width = "";

            /*

        var targetHeight = parseInt(bases.height);
        s.height = "";
        s.width = bases.width;

        // STEP 0: Get the height of a single line
        divObj.innerHTML = "a";
        var lineHeight = divObj.clientHeight

        divObj.innerHTML = this.readOnlyNode.innerHTML;
        var dif = parseInt(divObj.clientHeight) - targetHeight;

        // STEP 1: Make a coarse estimate
        // delta makes the following arbitrary assumptions (font size will screw with this)
        // 1. every line is lineHeight high
        // 2. If there are two lines of text, then to make things fit, we increase width by 2
        // 3. If there are three lines of text, then to make things fit, we increase the width by 1.5
        // 4. If there are n lines of text, then to make things fit, we increase the width by n/n-1
        if (dif > 0) {
            var numLines = Math.floor(parseInt(divObj.clientHeight)/lineHeight);
            var desiredLines = Math.floor(targetHeight/lineHeight);
            var deltaLines = numLines - desiredLines;
            var newwidth = parseInt(s.width) * (desiredLines/(desiredLines-1)); // Not right; need to repeat this once per line
            s.width = newwidth + "px";
        }

        // STEP 2: GROW BY 20 PX UNTIL IT FITS
        dif = parseInt(divObj.clientHeight) - targetHeight;
        while (dif > 0) {
            s.width = (parseInt(s.width) + 20) + "px";
            dif = parseInt(divObj.clientHeight) - targetHeight;
        }

        // STEP 3: OPTIMIZE: SHIRINK WIDTH BY 5PX UNTIL WE REACH OPTIMAL WIDTH
        while (dif < 0) {
            s.width = (parseInt(s.width) - 5) + "px";
            dif = parseInt(divObj.clientHeight) - targetHeight;
        }

        // STEP 4: We probably overshot by 5px, in the optimize step; correct for that
        if (diff > 0) s.width =  (parseInt(s.width) + 5) + "px";
        */
            var readonlyWidth = divObj.clientWidth;
            var newWidth = readonlyWidth;
            if (this.caption) {
                if (this.captionPosition == "left" || this.captionPosition == "right") {
                    newWidth += parseInt(this.captionNode.style.width) + wm.AbstractEditor.captionPaddingWidth;
                }
            }

            if (newWidth > maxWidth) {
                newWidth = maxWidth;
                bases.overflow = "auto";
                this._autoSizeNeedsOverflow = true;
            } else {
                bases.overflow = "hidden";
                this._autoSizeNeedsOverflow = false;
            }
            var minWidth = this.getMinWidthProp();
            if (minWidth > newWidth) newWidth = minWidth;
            if (setSize) this.setWidth(newWidth + "px");
            else {
                this.bounds.w = newWidth;
                this.width = newWidth + "px";
            }
        }
        divObj.parentNode.removeChild(divObj);
        this.disruptChromeOverflow("readOnlyNode");
        this.updateReadOnlyNodeStyle();
        this._doingAutoSize = false;
    },

    setAutoSizeWidth: function(inValue) {
        this.inherited(arguments);
        if (this.readOnlyNode && this.readonly) this.updateReadOnlyNodeStyle();
    },
    setAutoSizeHeight: function(inValue) {
        this.inherited(arguments);
        if (this.readOnlyNode && this.readonly) this.updateReadOnlyNodeStyle();
    },
    setMaxHeight: function(newMax) {

        this.inherited(arguments);
        if (!this.maxHeight && this.readOnlyNode) this.readOnlyNode.style.overflow = "hidden";
        if (this.readOnlyNode) {
            this.updateReadOnlyNodeStyle();
            this.doAutoSize(1, 1);
        }
    },
    // Any time the user changes the class for the label, recalculate autosize with the new styleing which may include font size changes
    addUserClass: function(inClass, inNodeName) {
        this.inherited(arguments);
        if ((this.autoSizeHeight || this.autoSizeWidth) && this.isDesignLoaded()) {
            this.doAutoSize(1, 1);
        }
    },
    getAutoSize: function(inSize) {
        return this.autoSizeHeight ? "height" : this.autoSizeWidth ? "width" : "none";
    },
    setAutoSize: function(inSize) {
        if (inSize == "none") {
            if (this.autoSizeHeight) {
                this.setAutoSizeHeight(false);
            }
            if (this.autoSizeWidth) {
                this.setAutoSizeWidth(false);
            }
        } else if (inSize == "width") {
            if (this.autoSizeHeight) {
                this.setAutoSizeHeight(false);
            }
            if (!this.autoSizeWidth) {
                this.setAutoSizeWidth(true);
            }
        } else if (inSize == "height") {
            if (!this.autoSizeHeight) {
                this.setAutoSizeHeight(true);
            }
            if (this.autoSizeWidth) {
                this.setAutoSizeWidth(false);
            }
        }
    }

});



dojo.declare("wm.Text", wm.ResizableEditor, {
    selectOnClick: false,
    resetButton: false,
    placeHolder: "",
    changeOnKey: false,
    changeOnEnter: true,

    showMessages: true,
    promptMessage: "",
    invalidMessage: "",
    password: false,
    maxChars: "",
    regExp: ".*",
    _passwordChar: "&#8226;",
    tooltipDisplayTime: 2000,
    getEditorProps: function(inNode, inProps) {
        var p = dojo.mixin(this.inherited(arguments), {
            selectOnClick: this.selectOnClick,
            promptMessage: this.promptMessage,
            invalidMessage: this.invalidMessage || "$_unset_$",
            placeHolder: this.placeHolder,
            regExp: this.regExp,
            constraints: {regExpOptions: this.regExpOptions},
            value: this.displayValue,
            required: this.required,
            tooltipDisplayTime: this.tooltipDisplayTime
        });
        /*
        if (!this._isDesignLoaded) {
        if (this.customFormatter != this.constructor.prototype.customFormatter)
            p.format = this.customFormatter;
        if (this.customParser != this.constructor.prototype.customParser)
            p.parse = this.customParser;
        }
        */
        // this dijit supports setting password type at creation time only
        if (this.password) p.type = "password";

        // maxChar property should only be set if user sets a limit otherwise, textEditor and all its sub-class will not work in IE8(Compatible mode for IE7)
        if (this.maxChars) p.maxLength = this.maxChars;

        return dojo.mixin(p, inProps || {});
    },
    /*
    customFormatter: function(/ * take inValue and return the formatted version of it to display in the editor * / inValue) {},
    customParser: function(/ * take inValue and return the dataValue represented by this value; also affects display of editor while editing * /inValue) {},
    */
    _onDijitFocus: function() {
        if (this.disabled) {
            return;
        }
        var val = this.editor.get('value');
        if (val) {
            var formattedValue = this.editor.format(val);
            if (formattedValue !== undefined) {
                this.editor.textbox.value = formattedValue;
            }
        }
        this.inherited(arguments);
    },
    validationEnabled: function() {
        return (this.regExp && this.regExp != ".*") || this.required;
    },

    setSelectOnClick: function(inSelectOnClick) {
        this.selectOnClick = inSelectOnClick;
        if (this.editor) this.editor.attr("selectOnClick", inSelectOnClick);
    },
    setPlaceHolder: function(inPlaceHolder) {
        this.placeHolder = inPlaceHolder;
        if (this.editor) this.editor.attr("placeHolder", inPlaceHolder);
    },
    setPassword: function(inPassword) {
        this.password = inPassword;
        this.createEditor();
        var pos = this.captionPosition;
        this.captionPosition = "";
        this.setCaptionPosition(pos);

    },
    setRegExp: function(inExpr) {
        this.regExp = inExpr;
        if (!this._cupdating) this.createEditor();
    },
    selectText: function() {
        dijit.selectInputText(this.editor.focusNode);
    },

    /* a way to create an html editor and transform it to a dijit onclick; this approach may still be desired at some point... for both performance and usability reasons.  Usability reasons though could be handled with a click to exit readonly mode
    __createEditor: function(node,inProps) {
        if (this.fakeEditor) {
        dojo.destroy(this.fakeEditor);
        delete this.fakeEditor;
        return this._createEditor2(node,inProps);
        }

        var input = dojo.create("input", {type: "text",
                          id:    this.id + "_INPUT",
                          className: "dijit dijitReset dijitLeft dijitTextBox",
                          style: {width: "100%", height: "100%"}}, node, "first");
        this.fakeEditor = input;
        dojo.connect(input, "onfocus", this, function() {
        this.createEditor(inProps);
        this.editor.focus();
        });
        return {domNode: input};

    },
    */
    _createEditor: function(inNode, inProps) {
        var result;
        if (this.validationEnabled() || this.promptMessage) result = new dijit.form.ValidationTextBox(this.getEditorProps(inNode, inProps));
        else result = new dijit.form.TextBox(this.getEditorProps(inNode, inProps));
        if (this.resetButton) {
            dojo.addClass(this.domNode, "wmreseteditor");
            if (wm.isMobile) {
                this._resetButtonNode = document.createElement("span");
                this._resetButtonNode.innerHTML = "X";
                var s = this._resetButtonNode.style;
                s.position = "absolute";
                s.fontWeight = "bold";
                s.top = "1px";
                s.right = "1px";
                s.width = "16px";
                s.textShadow = "1px 1px #aaa";
            } else {
                this._resetButtonNode = document.createElement("img");
                this._resetButtonNode.src = this._resetButtonUrl || dojo.moduleUrl("lib.images.boolean.Signage") + "Close_gray.png";
                var s = this._resetButtonNode.style;
                s.position = "absolute";
                s.width = "16px";
                s.height = "16px";
                s.top = "1px";
                s.right = "1px";
            }
            result.domNode.appendChild(this._resetButtonNode);
            this._resetButtonConnect = dojo.connect(this._resetButtonNode, "onclick", this, function() {
                wm.onidle(this, function() {
                    this._onResetClick();
                    this.setDataValue("");
                });
            });
        }
        return result;
    },
    _onResetClick: function() {},
    sizeEditor: function() {
        this.inherited(arguments);
        if (this._cupdating) return;
        if (dojo.isFF || dojo.isIE) {
            var input = dojo.query("input.dijitInputInner", this.domNode)[0];
            if (input) {
                input.style.height = this.editorNode.style.height;
                input.style.lineHeight = this.editorNode.style.lineHeight;
            }
        }
    },
    destroy: function() {
        if (this._resetButtonNode) dojo.destroy(this._resetButtonNode);
        if (this._resetButtonConnect) dojo.disconnect(this._resetButtonConnect);
        this.inherited(arguments);
    },
    validator: function(inValue, inConstraints) {
        var l = Number(this.maxChars);
        return this.maxChars !== "" && !isNaN(l) ? inValue.length <= l : true;
    },
    _getReadonlyValue: function() {
        var v = this.inherited(arguments);
        if (this.password) {
            for (var i = 0, a = [], l = v.length; i < l; i++)
            a.push(this._passwordChar);
            v = a.join('');
        }
        return v;
    },
    /*
    changed: function() {
    this.inherited(arguments);
    if (this.customFormatter != this.constructor.prototype.customFormatter && this.editor && this.editor.textbox) {
        var val = this.editor.get("displayedValue");
        var formattedValue = this.editor.format(val);
        if(formattedValue !== undefined) {
        this.editor.textbox.value = formattedValue;
        }
    }
    },
    */
    setResetButton: function(inReset) {
        if (this._resetButtonConnect) {
            dojo.disconnect(this._resetButtonConnect);
            delete this._resetButtonConnect;
        }
        this.resetButton = inReset;
        dojo[inReset ? "addClass" : "removeClass"](this.domNode, "wmreseteditor");
        this.createEditor();
    },
    getCursorPosition: function() {
        var CaretPos = 0;
        // IE Support
        var ctrl = this.editor ? this.editor.focusNode || this.editor : null;
        if (document.selection) {
            this.focus();
            var Sel = document.selection.createRange();
            Sel.moveStart('character', -ctrl.value.length);
            CaretPos = Sel.text.length;
        }
        // Firefox support
        else if (ctrl.selectionStart || ctrl.selectionStart == '0') CaretPos = ctrl.selectionStart;
        return (CaretPos);
    },
    getCursorLength: function() {
        var CaretPos = 0;
        // IE Support
        var ctrl = this.editor ? this.editor.focusNode || this.editor : null;
        if (document.selection) {
            this.focus();
            var Sel = document.selection.createRange();
            Sel.moveStart('character', -ctrl.value.length);
            CaretPos = Sel.text.length;
        }
        // Firefox support
        else if (ctrl.selectionStart || ctrl.selectionStart == '0') return ctrl.selectionStart - ctrl.selectionEnd;
    },
    setCursorPosition: function(pos) {
        var ctrl = this.editor ? this.editor.focusNode || this.editor : null;
        if (ctrl.setSelectionRange) {
            this.focus();
            ctrl.setSelectionRange(pos, pos);
        } else if (ctrl.createTextRange) {
            var range = ctrl.createTextRange();
            range.collapse(true);
            range.moveEnd('character', pos);
            range.moveStart('character', pos);
            range.select();
        }
    },
    afterPaletteDrop: function() {
        this.inherited(arguments);
        var liveform = this.getParentForm();
        if (liveform) {
            this.emptyValue = "emptyString";
        }
    }
});



dojo.declare("wm.LargeTextArea", wm.Text, {
    _editorPaddingLeft: 3,
    _editorPaddingRight: 3,
    showMessages: false,
    width: "300px",
    height: "96px",
    captionSize: "24px",
    captionPosition: "top",
    captionAlign: "left",
    singleLine: false,

    changeOnEnter: false,
    normalizeDataValue: function(inValue) {
        if (inValue === undefined || inValue === null) return "";
        else return String(inValue);
    },
    _createEditor: function(inNode, inProps) {
        var editor = new dijit.form.SimpleTextarea(this.getEditorProps(inNode, inProps));
        editor.domNode.style.lineHeight = "normal"; // we test for this style before setting it to height of height px; if its normal we leave it alone
        return editor;
    },
    validationEnabled: function() {
        return false;
    },
    sizeEditor: function() {
        this.inherited(arguments);
    },
    setSingleLine: function(inSingleLine) {
        this.inherited(arguments);
        this.captionNode.style.lineHeight = "normal";
    },
    getReadOnlyNodeLineHeight: function() {
        return "normal";
    },

    // readonly node always wraps unless autoResizeWidth is used
    getReadOnlyNodeWhiteSpace: function() {
        if (this.autoSizeWidth) return this.inherited(arguments);
        else return "normal";
    },
    getReadOnlyNodeOverflow: function() {
        if (this.autoSizeWidth || this.autoSizeHeight) return this.inherited(arguments);
        else return "auto";
    },
    getMinHeightProp: function() {
        return this.minHeight || 80; // scrollbars sometimes have trouble when an editor is too short
    }
});


}

if(!dojo._hasResource["wm.base.widget.Spacer"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.widget.Spacer"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide("wm.base.widget.Spacer");

dojo.declare("wm.Spacer", wm.Control, {
	classNames: "wmspacer",
        border: 0,
    getMinWidthProp: function() {return this.minWidth || 0;},
    getMinHeightProp: function() {return this.minHeight || 0;}
});

}

if(!dojo._hasResource["wm.base.widget.Panel"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.widget.Panel"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide("wm.base.widget.Panel");

/**
	Container for widgets.
	@name wm.Panel
	@class
	@extends wm.Container
*/
dojo.declare("wm.Panel", wm.Container, {
	/** @lends wm.Panel.prototype */
	//border: 1,
    classNames: "wmcontainer wmpanel",    
    setThemeStyleType: function(inType) {        
        var widgetsjs = this.write("");
	widgetsjs = dojo.fromJson(widgetsjs.replace(/^.*?\:/,""));
	var name = this.name;	
        var parent = this.parent;
	var owner = this.owner;
        var indexInParent = dojo.indexOf(this.parent.c$, this);
        this.destroy();
	
        var clone = parent.createComponent(name, "wm." + (inType||"") + "Panel", widgetsjs[1], widgetsjs[2], widgetsjs[3], owner);
        parent.moveControl(clone, indexInParent);
        parent.reflow();
	studio.refreshVisualTree();
	studio.select(clone);
    },
    getThemeStyleType: function() {
        return this.declaredClass.replace(/^wm\.(.*)Panel/,"$1");
    }

});


dojo.declare("wm.MainContentPanel", wm.Panel, {
    classNames: "wmcontainer wmpanel MainContent"
});

dojo.declare("wm.EmphasizedContentPanel", wm.Panel, {
    classNames: "wmcontainer wmpanel EmphasizedContent"
});

dojo.declare("wm.HeaderContentPanel", wm.Panel, {
    classNames: "wmcontainer wmpanel HeaderContent"
});

dojo.declare("wm.FancyPanel", wm.Panel, {
    //useDesignBorder: 0, // move this to a _design file if we ever create one
    freeze: true,
    classNames: "wmcontainer wmfancypanel",
    //_classes: 	{"domNode": ["wm_FontSizePx_16px", "wm_BackgroundGradient_Blue", "wm_Border_TopStyleCurved12px", "wm_Border_BottomStyleCurved4px", "wm_FontColor_White", "wm_TextDecoration_Bold", "wm_Border_DropShadow"]},
    title: "Panel Heading",
    labelWidget: null,
    containerWidget: null,
    layoutKind: "top-to-bottom",
    innerLayoutKind: "top-to-bottom",
    innerHorizontalAlign: "left",
    innerVerticalAlign: "top",
    margin: "6",
    padding: "0",    
    border: "0",
    innerBorder: "3",
    borderColor: "#404040",
    width: "100%",
    height: "100%",
    _topImgWidth: 0,
    _bottomImgWidth: 0,
    labelHeight: 30,
    themeStyleType: "ContentPanel",
    init: function() {
	if (!this.labelHeight)
	    this.labelHeight = 30;

	var classes = this._classes;
	var containerClasses = {domNode:[]};
	for (var i = classes.domNode.length-1; i >= 0; i--) {
	    if (classes.domNode[i].match(/^wm_Border_(Bottom|Drop)/)) {
    		containerClasses.domNode.push(classes.domNode[i]);
    		wm.Array.removeElementAt(classes.domNode,i);
	    }
	}

        try {
	    //var classes = this.captionClasses.split(/\s+/);
	    this.layout = wm.layout.cache["top-to-bottom"];
	    this.inherited(arguments);

            this._isDesign = this.isDesignLoaded();

	    this.labelWidget = new wm.Label({border: this.innerBorder,
                                             borderColor: this.borderColor,
                                             showing: Boolean(this.title),
		                             _classes: classes,
                                             name: "labelWidget",
                                             caption: this.title,
                                             width: "100%",
                                             height: this.labelHeight + "px",
                                             padding: "0,0,0,10",
                                             owner: this,
                                             parent: this,
					     flags: {notInspectable: true}});

	    var innerBorder = String(this.innerBorder);
            innerBorder = this._parseExtents(innerBorder);
	    this.containerWidget = new wm.Container({
		                                     _classes: containerClasses,
                                                     name:           "containerWidget",
                                                     layoutKind:     this.innerLayoutKind,
                                                     width:          "100%",
                                                     height:         "100%",
                                                     owner:          this,
                                                     parent:         this,
                                                     noInspector:    true,
                                                     autoScroll:     this.autoScroll,
                                                     horizontalAlign:this.innerHorizontalAlign,
                                                     verticalAlign:  this.innerVerticalAlign,
                                                     fitToContentHeight: this.fitToContentHeight,
                                                     fitToContentWidth: this.fitToContentWidth,
                                                     /* margin: "0,0,7,0",*/
                                                     border:         "0,"+innerBorder.r+","+innerBorder.b+","+innerBorder.l,
                                                     borderColor: this.borderColor,
                                                     _assignChildrenToOwner: this.owner                
            });

	    this.containerWidget.setLayoutKind(this.innerLayoutKind);
	    this.widgets.labelWidget = this.labelWidget;
	    this.widgets.containerWidget = this.containerWidget;
            this.setTitle(this.title);
/*
	    wm.onidle(this, function() {
                try {
		    this._readyForInitClasses = true;
		    if (dojo.isIE < 9) {
                        var namelist = ["topRightCornerImg","topLeftCornerImg","bottomRightCornerImg","bottomLeftCornerImg"];
                        for (var i = 0; i < namelist.length; i++) {
                            var name = namelist[i];
                            var div = document.createElement("div");
                            div.id = this.getRuntimeId() + "_" + name;
                            div.className = "FancyPanel" + name;
		            this.parent.domNode.appendChild(div);
                            this["_" + name] = div;
                        }
		        this.initUserClasses();
		        this.renderCorners();
                        console.log("initUserClasses: " + this.toString() + " has label: " + Boolean(this.labelWidget));
                    }
		    this.initUserClasses();
                    this.setShowing(this.showing, true);
                } catch(e) {
                    alert("onIdle Panel:" + e);
		}

	    });
            */
        } catch(e) {
            alert("PANEL:" + e);
        }
    },
    setFitToContentHeight: function(inValue) {
        this.inherited(arguments);
        if (this.containerWidget) {
            this.containerWidget.setFitToContentHeight(inValue);
	    if (!inValue)
		this.containerWidget.setHeight("100%");
	}
    },
    setFitToContentWidth: function(inValue) {
        this.inherited(arguments);
        if (this.containerWidget) {
            this.containerWidget.setFitToContentWidth(inValue);
	    if (!inValue)
		this.containerWidget.setWidth("100%");
	}
    },
    setBorder: function(inBorder) {
        wm.Control.prototype.setBorder.call(this, "0");
    },

    setShowing: function(inShowing) {
	this.inherited(arguments);
	if(dojo.isIE < 9) {
            if (this._topLeftCornerImg) {
	        this._topLeftCornerImg.style.display = (this.showing) ? "block" : "none";
	        this._topRightCornerImg.style.display = (this.showing) ? "block" : "none";
            }
            if (this._bottomLeftCornerImg) {
	        this._bottomLeftCornerImg.style.display = (this.showing) ? "block" : "none";
	        this._bottomRightCornerImg.style.display = (this.showing) ? "block" : "none";
            }
	}
    },
	getMinHeightProp: function() {
            if (this.minHeight) return Number(this.minHeight);
            if (!this.containerWidget) return this.inherited(arguments);
            return this.containerWidget.getMinHeightProp() + ((this.labelWidget && this.labelWidget.showing) ? this.labelWidget.bounds.h : 0) + 30;
	},
	getPreferredFitToContentWidth: function() {
		// get the maximum width in this column; 
		// and get the sum of widths in this row... we'll worry later about whether its a row or column
                var extra = this.padBorderMargin.r + this.padBorderMargin.l;	
	        var max = 0;
	        var sum = 0;
		var v;
		for (var i=0, c; c=this.c$[i]; i++) {
			if (this.layout.inFlow(c)) {
			    if (c instanceof wm.Container) {
				if (c.fitToContentWidth || c._percEx.w) {
					v =  c.getPreferredFitToContentWidth();
				} else {
					v =  c.bounds.w;
				}
			    } else {
				if (c._percEx.w) {
				        v =  c.getMinWidthProp();
				} else {
					v =  c.bounds.w;
				}				
			    }
				max = Math.max(max, v);
				sum += v;				
			}
		}

                // Never return less than 30px wide; mostly this is for design mode where users still need to be able to find and drop widgets into the container.
	        var result = ((this.layoutKind == "top-to-bottom") ? max : sum) + extra;
            return Math.max(this.minWidth,Math.max(result, 30));
	},

    /* Get the preferred height of this container, for use if this is a fitToContentHeight container.
     * top-to-bottom container: height is the sum of the heights of all px sized children and the sum of all minHeights for % sized children.
     * left-to-right container: height is the max of the heights of all px sized children and the minHeights for % sized children
     */
	getPreferredFitToContentHeight: function() {
		// get the maximum width in this column; 
		// and get the sum of height in this row... we'll worry later about whether its a row or column
            var extra = this.padBorderMargin.t + this.padBorderMargin.b;	
	    var max = 0;
	    var sum = 0;
		var v;
		for (var i=0, c; c=this.c$[i]; i++) {
			if (this.layout.inFlow(c)) {
			    if (c instanceof wm.Container) {
				 if (c.fitToContentHeight || c._percEx.h) {
					v = c.getPreferredFitToContentHeight();
				 } else {
					v = c.bounds.h;
				}
			    } else {
				 if (c.fitToContentHeight || c._percEx.h) {
					v = c.getMinHeightProp();
				 } else {
					v = c.bounds.h;
				}
			    }
			    max = Math.max(max, v);
			    sum += v;
			}
		}
            // never return less than 15px height
            var result =  ((this.layoutKind == "left-to-right") ? max : sum) + extra;
	    return Math.max(this.minHeight,Math.max(result, 15));
	},

    destroy: function() {
	if(dojo.isIE < 9) {
            if (this._topLeftCornerImg) {
	        dojo.destroy(this._topLeftCornerImg);
	        dojo.destroy(this._topRightCornerImg);
            }
            if (this._bottomLeftCornerImg) {
	        dojo.destroy(this._bottomLeftCornerImg);
	        dojo.destroy(this._bottomRightCornerImg);
            }
	}
	this.inherited(arguments);
    },
    flow: function() {
	this.inherited(arguments);
	if (dojo.isIE < 9)
	    this.renderCorners();
    },
    renderCorners: function() {
	if (!this._topLeftCornerImg) return;
	if (this._topLeftCornerImg.className.match(/px/)) {
	    this._topLeftCornerImg.style.top =  this._topRightCornerImg.style.top = 
		(this.bounds.t + this.marginExtents.t) + "px";

	    this._topLeftCornerImg.style.left = (this.bounds.l + this.marginExtents.l) + "px";
	    this._topRightCornerImg.style.left = (this.bounds.r-this._topImgWidth-this.marginExtents.r) + "px";
	}

	if (this._bottomLeftCornerImg.className.match(/px/)) {
	    this._bottomLeftCornerImg.style.top =  this._bottomRightCornerImg.style.top = 
		(this.bounds.b - this.marginExtents.b - this._bottomImgHeight) + "px";

	    this._bottomLeftCornerImg.style.left = (this.bounds.l + this.marginExtents.l) + "px";
	    this._bottomRightCornerImg.style.left = (this.bounds.r-this._bottomImgWidth-this.marginExtents.r) + "px";
	}

	
    },
    postInit: function() {
	var changeParents = [];
	for (var i = 0; i < this.c$.length; i++) {
	    var c = this.c$[i];
	    if (this.$[c.name] != c && c instanceof wm.Control) {
		changeParents.push(c);
	    }
	}
	for (var i = 0; i < changeParents.length; i++) {
	    var c = changeParents[i];
	    c.setParent(this.containerWidget);
	    if (c.designWrapper)
		c.designWrapper.controlParentChanged();
	}
	this.inherited(arguments);
    },
    writeComponents: function(inIndent, inOptions) {
	var result = [];
	if (this.containerWidget)
	    result = result.concat(this.containerWidget.writeComponents(inIndent, inOptions));
	if (this.components.binding && !wm.isEmpty(this.components.binding.$))
	    result = result.concat(this.components.binding.write(inIndent, inOptions));
	return result;
    },
    setInnerHorizontalAlign: function(inAlign) {
	this.innerHorizontalAlign = inAlign
	if (this.containerWidget)
	    this.containerWidget.setHorizontalAlign(inAlign);
    },    
    setInnerVerticalAlign: function(inAlign) {
	this.innerVerticalAlign = inAlign
	if (this.containerWidget)
	    this.containerWidget.setVerticalAlign(inAlign);
    },    
    setInnerLayoutKind: function(inKind) {
	this.innerLayoutKind = inKind;
	if (this.containerWidget)
	    this.containerWidget.setLayoutKind(inKind);
    },    
    setInnerBorder: function(inBorder) {
	inBorder = String(inBorder);
        this.innerBorder = inBorder;
        this.labelWidget.setBorder(inBorder);
        var b = this._parseExtents(inBorder);
        this.containerWidget.setBorder("0," + b.r + "," + b.b + "," + b.l);
    },
    setLayoutKind: function(inKind) {
	wm.Panel.prototype.setLayoutKind.call(this,"top-to-bottom");
	if (this.containerWidget) {
	    this.setInnerLayoutKind(inKind);
	}
	
	// noop
	/*
	this.innerLayoutKind = inKind;
	if (this.containerWidget)
	    this.containerWidget.setLayoutKind(inKind);
	    */
    },    

/*
	addUserClass: function(inClass, inNodeName) {
            if (!this._readyForInitClasses) return this.inherited(arguments);

		this.inherited(arguments);
		if (dojo.isIE < 9)
		    switch(inClass) {
		    case "wm_Border_TopStyleCurved12px":
			dojo.addClass(this._topRightCornerImg, "topright_wm_Border_TopStyleCurved12px");
			dojo.addClass(this._topLeftCornerImg, "topleft_wm_Border_TopStyleCurved12px");
			this._topImgWidth = 11;
			break;
		    case "wm_Border_TopStyleCurved8px":
			dojo.addClass(this._topRightCornerImg, "topright_wm_Border_TopStyleCurved8px");
			dojo.addClass(this._topLeftCornerImg, "topleft_wm_Border_TopStyleCurved8px");
			this._topImgWidth = 7;
			break;
		    case "wm_Border_TopStyleCurved4px":
			dojo.addClass(this._topRightCornerImg, "topright_wm_Border_TopStyleCurved4px");
			dojo.addClass(this._topLeftCornerImg, "topleft_wm_Border_TopStyleCurved4px");
			this._topImgWidth = 3;
			break;
		    case "wm_Border_BottomStyleCurved12px":
			dojo.addClass(this._bottomRightCornerImg, "bottomright_wm_Border_BottomStyleCurved12px");
			dojo.addClass(this._bottomLeftCornerImg, "bottomleft_wm_Border_BottomStyleCurved12px");
			this._bottomImgWidth = 11;
			this._bottomImgHeight = 10;
			break;
		    case "wm_Border_BottomStyleCurved8px":
			dojo.addClass(this._bottomRightCornerImg, "bottomright_wm_Border_BottomStyleCurved8px");
			dojo.addClass(this._bottomLeftCornerImg, "bottomleft_wm_Border_BottomStyleCurved8px");
			this._bottomImgWidth = 7;
			this._bottomImgHeight = 7;
			break;
		    case "wm_Border_BottomStyleCurved4px":
			dojo.addClass(this._bottomRightCornerImg, "bottomright_wm_Border_BottomStyleCurved4px");
			dojo.addClass(this._bottomLeftCornerImg, "bottomleft_wm_Border_BottomStyleCurved4px");
			this._bottomImgWidth = 3;
			this._bottomImgHeight = 3;
			break;
		    }
 		if (inClass.match(/_bottom/i)) {
		    this.containerWidget.addUserClass("wm_Border_BottomStyleCurved4px", inNodeName);
		}

            
	},
    	removeUserClass: function(inClass, inNodeName) {
            if (!this._readyForInitClasses) return this.inherited(arguments);

		this.inherited(arguments);
		if (dojo.isIE < 9) 
		    switch(inClass) {
		    case "wm_Border_TopStyleCurved12px":
			dojo.removeClass(this._topRightCornerImg, "topright_wm_Border_TopStyleCurved12px");
			dojo.removeClass(this._topLeftCornerImg, "topleft_wm_Border_TopStyleCurved12px");
			break;
		    case "wm_Border_TopStyleCurved8px":
			dojo.removeClass(this._topRightCornerImg, "topright_wm_Border_TopStyleCurved8px");
			dojo.removeClass(this._topLeftCornerImg, "topleft_wm_Border_TopStyleCurved8px");
			break;
		    case "wm_Border_TopStyleCurved4px":
			dojo.removeClass(this._topRightCornerImg, "topright_wm_Border_TopStyleCurved4px");
			dojo.removeClass(this._topLeftCornerImg, "topleft_wm_Border_TopStyleCurved4px");
			break;
		    case "wm_Border_BottomStyleCurved12px":
			dojo.removeClass(this._bottomRightCornerImg, "bottomright_wm_Border_BottomStyleCurved12px");
			dojo.removeClass(this._bottomLeftCornerImg, "bottomleft_wm_Border_BottomStyleCurved12px");
			break;
		    case "wm_Border_BottomStyleCurved8px":
			dojo.removeClass(this._bottomRightCornerImg, "bottomright_wm_Border_BottomStyleCurved8px");
			dojo.removeClass(this._bottomLeftCornerImg, "bottomleft_wm_Border_BottomStyleCurved8px");
			break;
		    case "wm_Border_BottomStyleCurved4px":
			dojo.removeClass(this._bottomRightCornerImg, "bottomright_wM_Border_BottomStyleCurved4px");
			dojo.removeClass(this._bottomLeftCornerImg, "bottomleft_wm_Border_BottomStyleCurved4px");
			break;
		    }
 		if (inClass.match(/_bottom/i)) {
		    if (dojo.indexOf(this._classes.domNode, "wm_Border_BottomStyleCurved12px") != -1 ||
			dojo.indexOf(this._classes.domNode, "wm_Border_BottomStyleCurved8px") != -1 ||
			dojo.indexOf(this._classes.domNode, "wm_Border_BottomStyleCurved4px") != -1)
			this.containerWidget.removeUserClass("wm_Border_BottomStyleCurved4px", inNodeName);
		}
	},
	initUserNodeClasses: function(inClasses, inNodeName) {
	    if (!this._readyForInitClasses) return;
	    this._classes.domNode = [];
	    var k = dojo.clone(inClasses) || [], n = this[inNodeName];	    
	    if (n) {
		for (var i = 0; i < k.length; i++) {
		    this.addUserClass(k[i]);
		}
	    }
	},
        */
    setTitle: function(inTitle) {
	var oldTitle = this.title;
	this.title = inTitle;
	if (this.containerWidget) {
	    this.labelWidget.setCaption(inTitle);
	    this.labelWidget.setShowing(Boolean(inTitle));
            //this.containerWidget.setOneMargin((inTitle) ? 0 : 7, "t"); // make room for the curved corners if there's no title showing
	}
    },

        setThemeStyleType: function(inMajor) {
	    this.containerWidget.setThemeStyleType(inMajor);
	    this.themeStyleType = inMajor;
	},
    setLabelHeight: function(inHeight) {
        this.labelHeight = inHeight;
        this.labelWidget.setHeight(inHeight);
    },
    toHtml: function(inWidth) {
	var remainingWidth = inWidth - 12; // this panel should have a 1px border; which costs 2 width; and a 5px margin costing 10px
	return "<div id='" + this.domNode.id + "' class='" + this.classNames + "'><div class='wmFancyPanel-labelWidget'>" + this.title + "</div><div class='wmFancyPanel-containerWidget'>" + this.containerWidget.toHtml(remainingWidth) + "</div></div>";
    }
});


}

if(!dojo._hasResource["wm.base.widget.Layout"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.widget.Layout"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide("wm.base.widget.Layout");

dojo.declare("wm.Layout", wm.Container, {
    mobileFoldingType: "wm.TabLayers",
	// useful properties
	classNames: 'wmlayout',
        autoScroll: true,
	fit: false,
	width: "100%",
	height: "100%",
        _mobileFolded: false,
	create: function() {
		this.inherited(arguments);
	},
	build: function() {
		this.inherited(arguments);
		this.domNode.style.cssText += this.style + "overflow: hidden; position: relative;";
	},
	init: function() {
	    if (this.isDesignLoaded() && this.owner == studio.page) {
		this.parent = studio.designer;
	    } else if (this.owner && this.owner.owner instanceof wm.PageContainer) { // this is false within the ThemeDesigner
		this.parent = this.owner.owner;
	    }
	    this.inherited(arguments);
	    this.subscribe("deviceSizeRecalc", this, "resize");
	},
    postInit: function() {
	this.inherited(arguments);
	if (app.appRoot.deviceSize == "tiny" || app.appRoot.deviceSize == "300") {
	    this.foldUI();
	}
    },
    resize: function() {
	if (app.appRoot.deviceSize == "tiny" || app.appRoot.deviceSize == "300") {
	    if (!this._mobileFolded) {
		this.foldUI();
	    }
	} else if (this._mobileFolded) {
	    this.unfoldUI();
	}
    },
    foldUI: function() {
	if (!this.owner.enableMobileFolding) return;
	this._mobileFolded = true;
	    var parentLayers;
	    var layers = [];
	    var hasMobileFolding = false;
	    wm.forEachWidget(this, function(w) {
		if (w._mobileFoldingParent) {
		    ;
		} else if (w.mobileFolding) {
		    layers.push(w);
		    w._mobileFoldingParentIndex = w.parent.indexOfControl(w);
		    hasMobileFolding = true;
		} else if (w.isMobileFoldingParent && !parentLayers) {
		    parentLayers = w;
		}
	    }, true);
	if (!parentLayers) parentLayers = this;
	    if (layers.length > 1 || parentLayers instanceof wm.Layers && parentLayers.layers.length >= 1 && layers.length >= 1) {
		var currentLayer;
		if (!parentLayers.showing) {
		    parentLayers.setShowing(true);
		}
		if (parentLayers instanceof wm.Layers == false) {
		    var ctor = dojo.getObject(this.mobileFoldingType) || wm.TabLayers;
		    this.mobileFoldingLayers = new ctor({owner:  this.owner,
					      parent: parentLayers,
					      name:   "_mobileLayers",
					      width:  "100%",
					      height: "100%"});
		    this.mobileFoldingLayers.setIndexInParent(0);
		    parentLayers = this.mobileFoldingLayers;
		} else {
		    this.owner._mobileLayers = parentLayers;
		    parentLayers.setIndexInParent(layers[0].getIndexInParent());
		}
		var animation = parentLayers.transition;
		parentLayers.transition = "none";
		parentLayers._cupdating = true;
		layers = layers.sort(function(a,b) { 
		    if (a.mobileFoldingIndex === b.mobileFoldingIndex ||
			a.mobileFoldingIndex > b.mobileFoldingIndex)
			return 1;
		    else 
			return -1;
		});

		//var generatedTabs = [];
		for (var i = 0; i < layers.length; i++) {
		    layers[i]._mobileFoldingParent = layers[i].parent;

		    if (layers[i] instanceof wm.Layer == false) {
			layers[i]._mobileFoldingWidth = layers[i].width;
			layers[i]._mobileFoldingHeight = layers[i].height;
/*
			var currentParentLayers;

			// If its already in a layer, we can't just rip it out of that Layers, nor can we leave it alone because
			// presumably there are multiple panels in this Layers that need folding.  So see if this Layers has
			// a mobileLayer generated for it, and if not, generate one
			var ancestorLayers = layers[i].isAncestorInstanceOf(wm.Layer);
			if (ancestorLayers && ancestorLayers.owner == this.owner && ancestorLayers.parent != parentLayers) {
			    if (ancestorLayers._mobileLayer) {
				currentParentLayers = ancestorLayers._mobileLayer;
			    } else {
				currentParentLayers = ancestorLayers._mobileLayer = new wm.TabLayers({owner: ancestorLayers,
												      parent: ancestorLayers,
												      name: "_mobileLayers",
												      _generatedTabs: true,
												      width: "100%",
												      height: "100%"});
				generatedTabs.push(currentParentLayers);
			    }
			} else {
			    currentParentLayers = parentLayers;
			}

			var l = currentParentLayers.addLayer(layers[i].mobileFoldingCaption,true);
			*/
			var l = parentLayers.addLayer(layers[i].mobileFoldingCaption,true);
			layers[i].setParent(l);
			layers[i].setWidth("100%");
			layers[i].setHeight("100%");
			l._mobileFoldingGenerated = true;			
		    } else if (layers[i].parent != parentLayers) {/*currentParentLayers) {*/
			var l = layers[i];
			layers[i].setParent(parentLayers);//currentParentLayers);
		    } else {
			var l = layers[i];
		    }

		    if (String(layers[i].mobileFoldingIndex).length) {
			//currentParentLayers.moveLayerIndex(currentParentLayers.layers[currentParentLayers.layers.length-1], Number(layers[i].mobileFoldingIndex));
			parentLayers.moveLayerIndex(parentLayers.layers[parentLayers.layers.length-1], Number(layers[i].mobileFoldingIndex));
			if (layers[i].active)
			    //currentParentLayers.layerIndex = layers[i].getIndex();
			    parentLayers.layerIndex = layers[i].getIndex();
		    }
		}

		parentLayers._cupdating = false;
		if (currentLayer) {
		    currentLayer.activate();
		} else {
		    parentLayers.setLayerIndex(0);
		}
/*
		for (var i = 0; i < generatedTabs.length; i++) {
		    generatedTabs[i].setLayerIndex(0);
		}
		*/
		parentLayers.transition = animation;

		if (this.mobileFoldingLayers) {
		    for (var i = 1; i < this.c$.length; i++) {
			var c = this.c$[i];
			if (c.showing) {
			    c.hide();
			    c._mobileFoldingShowing = true;
			}
		    }
		}
	    }
	wm.fire(this.owner,"onMobileFolding");
    },
    unfoldUI: function() {
	if (!this.owner.enableMobileFolding) return;
	    this._mobileFolded = false;

	if (this.mobileFoldingLayers) {
	    for (var i = 1; i < this.c$.length; i++) {
		var c = this.c$[i];
		if (c._mobileFoldingShowing) {
		    c.setShowing(true);
		    delete c._mobileFoldingShowing;
		}
	    }
	}
	var generatedTabs = [];
	    wm.forEachWidget(this, function(w) {
		if (w._mobileFoldingParent) {
		    if (w.parent != w._mobileFoldingParent) {
			w.setParent(w._mobileFoldingParent);
		    }
		    if (w instanceof wm.Layer) {
			w.parent.setLayerIndex(w,w._mobileFoldingParentIndex);
		    } else {
			w.parent.moveControl(w,w._mobileFoldingParentIndex);
		    }
		    if (w._mobileFoldingWidth) {
			w.setWidth(w._mobileFoldingWidth);
			w.setHeight(w._mobileFoldingHeight);
		    }
		    delete w._mobileFoldingParent;
		    delete w._mobileFoldingParentIndex;
		}
		if (w._mobileFoldingGenerated) {
		    generatedTabs.push(w);
		}
	    }, true);	
	var newLayerIndex;
	var layers;
	dojo.forEach(generatedTabs, function(w) {
	    w._cupdating = true;
	    if (!layers) {
		layers = w.parent;
		newLayerIndex = layers.layerIndex;
	    }
	    if (w.getIndex() >= w.parent.layerIndex)
		newLayerIndex--;
	    w.destroy();
	    w._cupdating = false;
	});

	if (this.mobileFoldingLayers) {
	    this.mobileFoldingLayers.destroy();
	    delete this.mobileFoldingLayers;
	}
	delete this.owner._mobileLayers;

	if (layers && !layers.isDestroyed) layers.setLayerIndex(Math.max(0,newLayerIndex));

	wm.fire(this.owner,"onMobileUnfolding");
    },
	updateBounds: function() {
	    this._percEx = {w:100, h: 100};
	    this.setBounds(this.parent.getContentBounds());
	},
	reflow: function() {
	        if (this._cupdating || this.isDestroyed)
			return;
	        this.updateBounds();
		this.renderBounds();
		//this.fitTo();
		this.inherited(arguments);
		//wm.layout.box.reflow(this.domNode);
	}/*,
	canResize: function() {
		return false;
	}*/
});

wm.LayoutBox = wm.Layout;

}

if(!dojo._hasResource["wm.base.widget.Bevel"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.widget.Bevel"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide("wm.base.widget.Bevel");


dojo.declare("wm.Bevel", wm.Widget, {
	className: "wmbevel",
	flex: 0,
        bevelSize: 4,
	init: function() {
		this.inherited(arguments);
	},
	getOrientedStyleName: function() {
		return this.className + " " + this.className + (this.vertical ? "-h" : "-v");
	},
	addOrientation: function() {
		dojo.addClass(this.domNode, this.getOrientedStyleName());
	},
	removeOrientation: function() {
		dojo.removeClass(this.domNode, this.getOrientedStyleName());
	},
	updateSize: function() {
		var h = (this.parent||0).layoutKind == "left-to-right", d = this.bevelSize + "px";
		this.setWidth(h ? d : "100%");
		this.setHeight(h ? "100%" : d);
	},
	setParent: function() {
		this.inherited(arguments);
		this.addOrientation();
		this.updateSize();
	},
    toHtml: function() {
	return "<hr/>";
    }
});

}

if(!dojo._hasResource["wm.base.drag.capture"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.drag.capture"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide("wm.base.drag.capture");

kit = dojo;

kit.declare("wm.Capture", null, {
	isCaptured: false,
	setEvents: function() {
		this.events = {};
		kit.forEach(arguments, kit.hitch(this, "addEvent"));
	},
	addEvent: function(inEvent) {
		if (!this[inEvent])
			this[inEvent] = function() {};
		this.events[inEvent] = kit.hitch(this, inEvent);
	},
	capture: function() {
		if (this.isCaptured)
			return;
		this.doCapture();
		this.isCaptured = true;
	},
	release: function() {
		if (!this.isCaptured)
			return;
		this.doRelease();
		this.isCaptured = false;
	}
});

if (kit.isIE) {
	wm.Capture.extend({
		_bind: function(inTarget, inEvent, inHandler) {
			var on = 'on' + inEvent, old = inTarget[on];
			inTarget[on] = function(){
				inHandler(kit.fixEvent());
			};
			return old;
		},
		_unbind: function(inTarget, inEvent, inHandler) {
			var on = 'on' + inEvent;
			inTarget[on] = inHandler;
		},
		doCapture: function() {
			var n = document.body, e, oldf, newf;
			n.setCapture(true);
			this._captures = {};
			for (var i in this.events) {
				if (!(0)[i]) {
					this._captures[i] = this._bind(n, i, this.events[i]);
				}
			}
		},
		doRelease: function() {
			var n = document.body;
			for (var i in this._captures) {
				if (!(0)[i]) {
					this._unbind(n, i, this._captures[i]);
				}
			}
			this._captures = null;
			n.releaseCapture(true);
		}
	});
} else {
	wm.Capture.extend({
		doCapture: function(inEvents) {
			for (var i in this.events) {
				if (!(0)[i])
					document.addEventListener(i, this.events[i], true);
			}
		},
		doRelease: function() {
			for (var i in this.events) {
				if (!(0)[i])
					document.removeEventListener(i, this.events[i], true);
			}
			this.isCaptured = false;
		}
	});
}

kit.declare("wm.MouseCapture", wm.Capture, {
	constructor: function() {
		this.setEvents("mousemove", "mouseup", "mouseout", "click");
	},
	mousedown: function(e) {
		// FIXME: prevents "click" on FF2 ... have to test other browsers
		kit.stopEvent(e);
		this.capture();
	},
	mousemove: function(e) {
	},
	mouseout: function(e) {
		// helpful for motion detection
	},
	mouseup: function(e) {
		// FIXME: putting this here because "stopEvent" in mousedown prevents "click" on FF2 ... have to test other browsers
		this.release();
		kit.stopEvent(e);
	},
	click: function(e) {
		// FIXME: not executed because "stopEvent" in mousedown prevents "click" on FF2 ... have to test other browsers
		alert("MouseCapture saw a click!");
	}
});

}

if(!dojo._hasResource["wm.base.drag.drag"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.drag.drag"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide("wm.base.drag.drag");

/**
	@class
	@name wm.Drag
*/
dojo.declare("wm.Drag", null, {
	/** @lends wm.Drag.prototype */
	hysteresis: 4,
	/**
		Difference between current position and start position
	*/
	dx:0, dy:0, 
	/**
		Starting page position
	*/
	px:0, py:0,
	constructor: function() {
		this.initNodes();
	},
	initNodes: function() {
		// make a scrim for cursor style control and event capture
		this.scrimNode = document.createElement("div");
		var css = "position: absolute; z-index: 200; width: 100%; height: 100%; top: 0; left: 0; display: none;";
		// FIXME: is this needed only for IE6? test.
		css += /*dojo.isIE ? 
			"background-color: white; filter: alpha(opacity=0);" :*/
				"background-color: transparent;";
		this.scrimNode.style.cssText = css;
		document.body.appendChild(this.scrimNode);
	},
	setCursor: function(inCursor) {
		if (!this.avatarNode)
		{
			this.scrimNode.style.cursor = inCursor;
			return;
		}
		
		if (inCursor == 'no-drop')
		{
			dojo.addClass(this.avatarNode, 'invalidDropCSS');
		}
		else
		{
			dojo.removeClass(this.avatarNode, 'invalidDropCSS');
		}

		this.scrimNode.style.cursor = 'default';
	},
	mousedown: function(e) {
		this.inherited(arguments);
		this.mouseIsDown = true;
		this.dragging = false;
		this.dx = 0;
		this.dy = 0;
		this.px = e.pageX;
		this.py = e.pageY;
		if (this.scrimEarly) {
			// Because scrim is inserted immediately, mouseup will not occur on
			// the same node as mousedown, so we've killed
			// click and dblclick.
			// Ironically, scrim is necessary only to allow motion detection
			// (hysteresis) that would be blocked by IFRAME nodes, and motion
			// detection is only necessary to support differentiating clicks from
			// drags.
			// We support click detection via click/onclick methods
			// in this class (but not dblclick yet).
			//wm.showHideNode(this.scrimNode, true);
		}
	},
	mouseout: function(e) {
		// Alternative motion detection in case, e.g., an IFRAME is stealing our
		// mousemove
		if (this.mouseIsDown && !this.dragging) {
			this.start(e);
		}
	},
	mousemove: function(e) {
		if (this.mouseIsDown) {
			this.dx = e.pageX - this.px;
			this.dy = e.pageY - this.py;
			if (this.dragging) {
				this.drag(e);
			} else if (Math.sqrt(this.dx*this.dx + this.dy*this.dy) > this.hysteresis) {
				this.start(e);
			}
		}
	},
	start: function(e) {
		this.dragging = true;
		wm.showHideNode(this.scrimNode, true);
		this.onstart(e);
	},
	drag: function(e) {
		this.ondrag(e);
	},
	mouseup: function(e) {
		this.inherited(arguments);
		this.mouseIsDown = false;
		this.finish();
		if (this.dragging) {
			this.dragging = false;
			this.drop();
			//wm.onidle(this, "drop");
		}/* else {
			this.click(e);
			//wm.onidle(this, "click", e);
		}*/
	},
	drop: function() {
		this.ondrop();
	},
	/*click: function(e) {
		console.log("drag.click");
		this.onclick(e);
	},*/
	finish: function() {
		wm.showHideNode(this.scrimNode, false);
	},
	onstart: function(e) {
	},
	ondrag: function(e) {
	},
	ondrop: function() {
	}/*,
	onclick: function(e) {
		// if dragging was never triggered
	}*/
});

/**
	@class
	@name wm.MouseDrag
	@inherits wm.MouseCapture
	@inherits wm.Drag
*/
dojo.declare("wm.MouseDrag", [wm.MouseCapture, wm.Drag], {
	/** @lends wm.MouseDrag */
});

/**
	@class
	@name wm.DragDropper
	@inherits wm.MouseDrag
*/
dojo.declare("wm.DragDropper", wm.MouseDrag, {
	/** @lends wm.DragDropper */
	initNodes: function() {
		this.inherited(arguments);
		// make a drag avatar
		this.avatarNode = document.createElement("div");
		dojo.addClass(this.avatarNode, 'dragAvatarCSS');
		this.avatarNode.style.cssText = "display: none;";
		this.avatarNode.innerHTML = "(control)";
		this.scrimNode.appendChild(this.avatarNode);
	},
	showHideAvatar: function(inTrueToShow) {
		wm.showHideNode(this.avatarNode, inTrueToShow);
	},
	setAvatarContent: function(inContent) {
		this.avatarNode.innerHTML = inContent;
	},
	update: function(e) {
		this.pxp = this.px + this.dx;
		this.pyp = this.py + this.dy;
		dojo._setMarginBox(this.avatarNode, this.pxp + 12, this.pyp + 16);
	},
	start: function(e) {
		this.inherited(arguments);
		this.update();
		wm.showHideNode(this.avatarNode, true);
	},
	drag: function() {
		this.inherited(arguments);
		this.update();
	},
	finish: function() {
		wm.showHideNode(this.avatarNode, false);
		this.inherited(arguments);
	}
});

}

if(!dojo._hasResource["wm.base.widget.Splitter"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.widget.Splitter"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide("wm.base.widget.Splitter");



/**
    @class
    @name wm.SplitterResize
    @inherits wm.MouseDrag
*/
dojo.declare("wm.SplitterResize", wm.MouseDrag, {
    beginResize: function(e, inSplitter) {
        this.splitter = inSplitter;
        this.setCursor(this.splitter.vertical ? "w-resize" : "n-resize");
        this.mousedown(e);
    },
    drag: function() {
        this.inherited(arguments);
        this.splitter.drag(this.dx, this.dy);
    },
    finish: function() {
        this.inherited(arguments);
        this.splitter.drop();
    }
});

dojo.declare("wm.Splitter", wm.Bevel, {
    className: "wmsplitter",
    minimum: -1,
    maximum: -1,
    mode: dojo.isMoz < 4 || dojo.isIE < 9 ? 2 : 0,
    layout: "",
    constructor: function() {
        wm.Splitter.resizer = wm.Splitter.resizer || new wm.SplitterResize();
    },
    init: function() {
        this.inherited(arguments);
        this.splitterWidget = this.parentIsSplitter ? this.parent : this;
        this.findLayout();
        this.connectEvents(this.domNode, ["mousedown", "dblclick"]);
    },
    /*
    // FIXME: unify canSize and getSizeNode
    canSize: function(n, next) {
        while (n=n[next]) {
            if (n.style && !n.style.visibility && !n.style.display)
                return !(n.flex > 0);
        }
        return false;
    },
    */
    findLayout: function() {
        var v = this.splitterWidget.parent.layoutKind == "left-to-right";
        var p = this.splitterWidget.parent.prevSibling(this.splitterWidget,true);
        if (p) {
        var l = v ? (p.width == "100%" ? "right" : "left") : (p.height == "100%" ? "bottom" : "top");
        this.setLayout(l);
        }
    },
    updateSize: function() {
        if (this._isDestroying) return;
        var widget = this.parentIsSplitter ? this.parent : this;
        var h = (widget.parent||0).layoutKind == "left-to-right", d = this.bevelSize + "px";
        this.setWidth(h ? d : "100%");
        this.setHeight(h ? "100%" : d);
    },

    setLayout: function(inLayout) {
        this.layout = inLayout;
        this.removeOrientation();
        this.vertical = this.layout == "left" || this.layout == "right";
        this.addOrientation();
        this.updateSize();
    },
    getSizeControl: function() {
        var widget = this.splitterWidget;
        //if (!this.layout)
            //this.findLayout();
        switch (this.layout) {
            case "left":
            case "top":
                        this.percentSizeControl = widget.parent.nextSibling(widget,true);
                        return widget.parent.prevSibling(widget,true);
                /*var node = this.domNode.previousSibling;
                while (node && node.nodeType != 1)
                    node = node.previousSibling;
                break;*/
            case "right":
            case "bottom":
                        this.percentSizeControl = widget.parent.prevSibling(widget,true);
                        return widget.parent.nextSibling(widget, true);
                /*var node = this.domNode.nextSibling;
                while (node && node.nodeType != 1)
                    node = node.nextSibling;
                break;*/
        }
        //return node;
    },
    getPosition: function() {
        //return { top: this.domNode.offsetTop, left: this.domNode.offsetLeft };
        return { top: this.splitterWidget.bounds.t, left: this.splitterWidget.bounds.l };
    },
    mousedown: function(e) {
        this.sizeControl = this.getSizeControl();
        if (!this.sizeControl)
            return;
        var otherControl = this.sizeControl.getIndexInParent() > this.getIndexInParent() ? this.sizeControl.parent.c$[this.sizeControl.getIndexInParent()-2] : this.sizeControl.parent.c$[this.sizeControl.getIndexInParent()+2];
        //this.size = dojo._getMarginBox(this.sizeNode);
        //this.containerSize = dojo._getContentBox(this.sizeNode.parentNode);
        this.size = this.sizeControl.cloneBounds();
        this.containerSize = this.sizeControl.parent.cloneBounds();
        this.initialPosition = this.getPosition();
        this.position = this.getPosition();
        wm.Splitter.resizer.beginResize(e, this);

        switch (this.layout) {
            case "top":
            case "bottom":
                this._boundsMax = this.sizeControl.parent.bounds.h - otherControl.getPreferredFitToContentHeight() + this.sizeControl.bounds.h;
                this._boundsMin = this.sizeControl.getPreferredFitToContentHeight ? this.sizeControl.getPreferredFitToContentHeight() : this.sizeControl.getMinHeightProp();

                break;
            case "left":
            case "right":
                this._boundsMax = this.sizeControl.parent.bounds.w - otherControl.getPreferredFitToContentWidth() + this.sizeControl.bounds.w;
                this._boundsMin = this.sizeControl.getPreferredFitToContentWidth ? this.sizeControl.getPreferredFitToContentWidth() : this.sizeControl.getMinWidthProp();
                break;
        }
    },
    drag: function(inDx, inDy) {
        if (this.vertical)
            this.moveX(inDx);
        else
            this.moveY(inDy);
        this.changing();
    },
    drop: function() {
        this.change();
    },
    // events
    changing: function() {
        this._collapsed = false;
        switch(this.mode) {
            case 0:
                // slowest, best feedback
                this.adjustSize();
                break;
            /*case 1:
                // slower, partial feedback
                this.adjustSize();
                with (wm.layout.box) {
                    recurse = false;
                    this.reflowParent();
                    recurse = true;
                }
                wm.job(this.id+"reflow", 5, dojo.hitch(this, "reflowParent"));
                break;*/
            default:
                // fastest, minimal feedback (do nothing)
                break;
        }
    },
    change: function() {
        this.adjustSize();
    },
    boundValue: function(inValue) {
        var widget = this.splitterWidget;
        var x = inValue;
        if (this.minimum != -1) inValue = Math.max(this.minimum, inValue);
        if (this.maximum != -1) inValue = Math.min(this.maximum, inValue);
        var parentBounds = widget.parent.getContentBounds();

        if (inValue < this._boundsMin) inValue = this._boundsMin;
        else if (inValue > this._boundsMax) inValue = this._boundsMax;

        this.atLimit = (x != inValue);
        return inValue;
    },
    adjustSize: function() {
        var dx = this.position.left - this.initialPosition.left;
        var dy = this.position.top - this.initialPosition.top;
        var w = this.size.w + (this.layout=="right" ? -dx : dx);
        var h = this.size.h + (this.layout=="bottom" ? -dy : dy);
        //console.log(w, h, dx, dy);
        //dojo._setMarginBox(this.sizeNode, NaN, NaN, w, h);
        if (this.layout == "top" || this.layout == "bottom")
        this.sizeControl.setHeight(h + "px");
        else
        this.sizeControl.setWidth(w + "px");
    },
    move: function(inD, inOrd, inExtent) {
        if (inD == 0)
            return;
        this.position[inOrd] = this.initialPosition[inOrd] + inD;
        if (this.layout==inOrd)
            this.position[inOrd] = this.boundValue(this.position[inOrd]);
        else {
            var e = this.containerSize[inExtent];
            this.position[inOrd] = e - this.boundValue(e - this.position[inOrd]);
        }
            this.splitterWidget.domNode.style[inOrd] = this.position[inOrd] + "px";
    },
    moveX: function(inDx) {
        this.move(inDx, "left", "w");
    },
    moveY: function(inDy) {
        this.move(inDy, "top", "h");
    },
    dblclick: function() {
            if (this._collapsed)
                this.expand();
            else
                this.collapse();
    },
    collapse: function() {
        this._collapsed = true;
        this.initialPosition = this.getPosition();
        this._expandedPosition = dojo.mixin({}, this.initialPosition);
        switch (this.layout) {
            case "left":
                this.position.left = 0;
                break;
            case "top":
                this.position.top = 0;
                break;
            case "right":
                this.position.left = this.boundValue(this.position.left + this.size.w);
                break;
            case "bottom":
                this.position.top = this.boundValue(this.position.top + this.size.h);
                break;
        }
        this.change();
    },
    expand: function() {
        this._collapsed = false;
        this.initialPosition = this.getPosition();
        dojo.mixin(this.position, this._expandedPosition);
        this.change();
    }
});

}

if(!dojo._hasResource["wm.base.widget.Buttons.ToolButton"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.widget.Buttons.ToolButton"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */


dojo.provide("wm.base.widget.Buttons.ToolButton");


dojo.declare("wm.ToolButton", [wm.Control, wm.TouchMixinOptional], {
	enableTouchHeight: true,
	mobileHeight: "40px",
	width: "80px",
	border: 0,
	padding: "",
	margin: "",
	caption: "",
	classNames: "wmtoolbutton",
	iconUrl: "",
	iconWidth: "16px",
	iconHeight: "16px",
	iconMargin: "0 10px 0 0",
	clicked: false,
	//alignInParent: "topLeft",
	build: function() {
		if (!this.domNode) {

			this.domNode = document.createElement('button');
			// in IE8, type becomes submit and then acts weired everywhere.
			// therefore setting type to 'button'.
			dojo.attr(this.domNode, 'type', 'button');
		}
		this.btnNode = this.domNode;
	},

	/* Sometimes users go from an editor to clicking a button and some browsers don't update the editor value in time for
	 * our onclick handler to see it.  So build in a delay before firing onclick handlers.
	 */

	init: function() {
		this.inherited(arguments);

		if (!wm.isMobile) {
			/* IE 8 loses the event after our setTimeout; to access data about the event, we have to copy it and pass on the copy.
			 * Users should not see this pseudoevent and most definitely should not try to call stopEvent on this event
			 * You can change this behavior if your not supporing IE 8 by removing the setTimeout.
			 * Be sure to test for timing issues when going from editting/focus on an editor to clicking on a save button;
			 * Timing issue: focus leaves editor; editor validates; save button's disabled state is updated based on validation; did click happen before or after button's state was updated?
			 */
			this.connect(this.btnNode, "onclick", this, function(evt) {
				this.click(evt, true);
			});
			/* addTouchListener called by Control.js
	    } else {
		this.addTouchListener();*/
		}

		//this.setHint(this.title || this.hint);
		this.imageListChanged();

	},
	onTouchStart: function(evt, isMove) {
		dojo.addClass(this.btnNode, "Active");
	},
	onTouchMove: function() {
		dojo.removeClass(this.btnNode, "Active");
	},
	onTouchEnd: function(evt, isMove) {
		if (isMove) return;
		dojo.removeClass(this.btnNode, "Active");
		/* Force inputs to fire onchange events and update bound service var inputs if they have focus.
		 * Normally, on touch devices, a touchstart and touchend can happen without the editor ever losing focus,
		 * triggering its dijit's onBlur, and delivering new values.
		 */
		if (document.activeElement.tagName == "INPUT") {
			var id = document.activeElement.id;
			var d = dijit.byId(id);
			if (d) d._onBlur();
			else document.activeElement.blur();
		}
		this.click(evt, true);
	},
	click: function(inEvent, useDelay) {
		if (!this._disabled) {
			if (!this.clicked) {
				this.setProp("clicked", true);
			}
			if (!useDelay) {
				this.onclick(inEvent, this);
			} else {
				var pseudoEvt = dojo.isIE && inEvent ? {
					clientX: inEvent.clientX,
					clientY: inEvent.clientY,
					offsetX: inEvent.offsetX,
					offsetY: inEvent.offsetY,
					screenX: inEvent.screenX,
					screenY: inEvent.screenY,
					pageX: inEvent.pageX,
					pageY: inEvent.pageY,
					x: inEvent.x,
					y: inEvent.y,
					target: inEvent.target,
					currentTarget: inEvent.currentTarget,
					"type": inEvent.type
				} : inEvent || {};
				wm.onidle(this, function() {
					if (!this._isDestroyed) {
						this.onclick(pseudoEvt, this);
					}
				});
			}

			if (app.toolTipDialog && this == app.toolTipDialog.tipOwner) {
				app.toolTipDialog.hide();
			}
		}
	},
	onclick: function() {},
	setDisabled: function(inDisabled) {
		var wasdisabled = this._disabled;
		this.inherited(arguments);
		var disabled = this._disabled;
		if (Boolean(wasdisabled) != Boolean(disabled) || this._cupdating) {
			this.btnNode.disabled = disabled ? "disabled" : "";
			dojo[disabled ? "addClass" : "removeClass"](this.domNode, "wmbutton-disabled");

			/* Used to always call render, which destroys and recreates the button. Unfortunately,
			 * it had an annoying tendency to do this while the user is trying to click on it, which often
			 * means the user's click fails.  Example: I go from an editor to a button.  Editor's onchange is bound to this button's
			 * disabled state.  Call to setDisabled rerendered the button while I click on it. Click fails. */
			if (this._imageList && parseInt(this.imageIndex) != NaN && this.imageIndex != -1 && this.declaredClass == "wm.ToolButton") this.updateImageListButtonHtml();
		}
	},
	setSelected: function(inSelected) {
		this.selected = inSelected;
		if (this._imageList && this.imageIndex && this.declaredClass == "wm.ToolButton") {
			this.updateImageListButtonHtml();
		}
	},
	setCaption: function(inCaption) {
		this.caption = inCaption;
		if (!this._cupdating) {
			this.invalidCss = true;
			this.render(true, true);
		}
		this.valueChanged("caption", this.caption);
	},
	setIconUrl: function(inUrl) {
		/*
	    var root = "";
	    if (inUrl) {
		if (inUrl.slice(0, 4) == "http" || inUrl.slice(0, 1) == "/") {
		    root = "";
		} else if (inUrl.indexOf("lib/") == 0) {
		    root = dojo.moduleUrl("lib").path.replace(/lib\/$/, "");
		}
	    }
		*/
		this.iconUrl = inUrl;
		this.invalidCss = true;
		this.render(true, true);
	},
	setIconWidth: function(w) {
		this.iconWidth = w;
		this.invalidCss = true;
		this.render(true, true);
	},
	setIconHeight: function(h) {
		this.iconHeight = h;
		this.invalidCss = true;
		this.render(true, true);
	},
	setIconMargin: function(m) {
		this.iconMargin = m;
		this.invalidCss = true;
		this.render(true, true);
	},
	setContent: function(inContent) { // BC
		this.setCaption(inContent);
	},
	/*
	setHint: function(inHint) {
		this.btnNode.title = this.hint = inHint;
	},
	*/
	imageListChanged: function() {
		this.inherited(arguments);
		this.invalidCss = true;
		this.render(true, true);
	},
	getCurrentImageIndex: function() {
		if (this.declaredClass != "wm.ToolButton") {
			return this.inherited(arguments);
		} else {
			if (this._disabled) return this.imageIndex + this._imageList.colCount * 2;
			if (this.selected) return this.imageIndex + this._imageList.colCount;
		}
		return this.imageIndex;
	},

	updateImageListButtonHtml: function() {
		var sl = this.singleLine ? "line-height: " + this.height + "; " : "";
		var captionHtml = this.caption ? '<span style="padding-left: 2px; ' + sl + '">' + (this.caption == undefined ? "" : this.caption) + '</span>' : "";
		var ii = this.getCurrentImageIndex();
		this.btnNode.innerHTML = this._imageList.getImageHtml(ii) + captionHtml;
	},
	render: function(forceRender, noInherited) {
		if (!forceRender && (!this.invalidCss || !this.isReflowEnabled())) return;
		if (!noInherited) this.inherited(arguments);
		var il = this._imageList;
		if (il && il.getImageHtml && this.imageIndex >= 0) {
			if (this.btnNode != this.domNode) this.btnNode.style.padding = "0px";
			this.updateImageListButtonHtml();
		} else if (this.iconUrl) {
			var url = this.iconUrl;
			var root;
			if (url.indexOf("lib/") === 0) {
				root = dojo.moduleUrl("lib").path.replace(/lib\/$/, "");
				url = root + url;
			} else {
				root = this.getPath() || "";
			}
			var sl = this.singleLine ? "line-height: " + this.height + "; " : "";
			var captionHtml = this.caption ? '<span style="padding-left: 2px; ' + sl + '">' + (this.caption == undefined ? "" : this.caption) + '</span>' : "";


			this.btnNode.innerHTML = "<img src='" + wm.theme.getImagesPath() + "blank.gif' style='margin: " + this.iconMargin + "; width: " + this.iconWidth + "; height: " + this.iconHeight + "; vertical-align: middle; background:url(" + root + url + ") no-repeat; background-color: transparent;' />" + captionHtml;

            if (this.btnNode != this.domNode) this.btnNode.style.padding = "0px";
		} else {
			this.btnNode.innerHTML = this.caption;
			if (this.btnNode != this.domNode) {
				this.btnNode.style.padding = "";
			}
		}
	},
    renderBounds: function() {
        this.inherited(arguments);
        if(dojo.isIE && dojo.isIE < 9) {
            if(this.btnNode.firstChild && this.btnNode.firstChild.style) {
                this.btnNode.firstChild.style.padding = "1px";
                wm.job(this.getRuntimeId() + ".IEButtonTrick", 5, dojo.hitch(this, function() {
                    this.btnNode.firstChild.style.padding = "0px";
                }));
            } else {
                this.btnNode.style.padding = this.padding == "1" ? "2" : "1";
                wm.job(this.getRuntimeId() + ".IEButtonTrick", 5, dojo.hitch(this, function() {
                    this.btnNode.style.padding = this.paddingExtents.t + "px " + this.paddingExtents.r + "px " + this.paddingExtents.b + "px \
" + this.paddingExtents.l + "px";
                }));
            }
        }
    },
    destroy: function() {
		if (this.btnNode) {
			dojo.destroy(this.btnNode);
			this.btnNode = null;
		}

		if (this.domNode) {
			dojo.destroy(this.domNode);
			this.domNode = null;
		}

		this.inherited(arguments);
	}
});

}

if(!dojo._hasResource["wm.base.widget.Buttons.Button"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.widget.Buttons.Button"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */


dojo.provide("wm.base.widget.Buttons.Button");



dojo.declare("wm.Button", wm.ToolButton, {
    desktopHeight: "32px",
    height: "32px",
    border: 1,
    borderColor: "#ABB8CF",
    margin: 4,
    /* TODO: Localize This */
    caption: "Button",
    classNames: "wmbutton"
});

dojo.declare("wm.IconButton", wm.Button, {
    build: function() {
        this.inherited(arguments);
        var html = "<table class='dijitMenuTable' style='width:100%'><tbody class='dijitReset'><tr class='dijitMenuItem dijitReset'><td class='dijitReset dijitMenuItemIconCell' style='width:" + (parseInt(this.iconWidth) + 4) + "px;'><" + (this._useIconUrl ? "img" : "div") + " style='display:none;width:" + this.iconWidth + ";height:" + this.iconHeight + ";'/></td><td class='dijitReset dijitMenuItemLabel'>" + this.caption + "</td><td class='dijitReset dijitMenuArrow'><div class='popupIcon'/></td></tr></tbody></table>";
        this.domNode.innerHTML = html;
    },
    // TODO: I want code that will change how we render a button and its icon if there is an icon...
    render: function(forceRender) {
        if (!forceRender && (!this.invalidCss || !this.isReflowEnabled())) return;
        wm.Control.prototype.render.call(this, forceRender);
        dojo.query(".dijitMenuItemLabel", this.domNode)[0].innerHTML = this.caption;
        var img = this._iconImage = dojo.query(".dijitMenuItemIconCell " + (this._useIconUrl ? "img" : "div"), this.domNode)[0];
        img.style.width = this.iconWidth;
        img.style.height = this.iconHeight;
        if (this.iconUrl) {
            img.src = this.iconUrl;
        }
        img.style.display = this.iconUrl || this.iconClass ? "block" : "none";
        var width = parseInt(this.iconWidth) || 0;
        img.parentNode.style.width = (width + 4) + "px";
        /*
    var height = parseInt(this.iconHeight) || 0;
    img.parentNode.style.height = (height+4) + "px";
    */
    }

});

dojo.declare("wm.MobileIconButton", wm.ToolButton, {
    direction: "down",
    caption: "Back",
    height: "40px",
    displayWhenHistoryEmpty: "", // "", "hidden", "disabled"
    historyEmptyIfLessThanOrEqualTo: 0,
    classNames: "wmMobileButton",
    init: function() {
        this.inherited(arguments);
        if (!this._isDesignLoaded && this.direction == "back" && this.displayWhenHistoryEmpty) {
            this.connect(app, "_onBack", this, "updateEmptyState");
            this.connect(app, "addHistory", this, "updateEmptyState");
            this.updateEmptyState();
        }
    },
    updateEmptyState: function() {
        var hasHistory = app.history && app.history.length > this.historyEmptyIfLessThanOrEqualTo;
        switch(this.displayWhenHistoryEmpty){
            case "hidden":
                this.setShowing(hasHistory);
                break;
            case "disabled":
                this.setDisabled(!hasHistory);
                break;

        }
    },
    build: function() {
        this.inherited(arguments);
        if (this.direction == "back") {
            /* Copied from dojo 1.6.1: dojox.mobile._base  */
            var btn = dojo.create("DIV", {className:"mblArrowBackButton"}, this.domNode, "first");
            var head = dojo.create("DIV", {className:"mblArrowBackButtonHead"}, btn);
            var body = dojo.create("DIV", {className:"mblArrowBackButtonBody mblArrowButtonText", innerHTML: this.caption}, btn);
            this.captionNode = body;
            dojo.addClass(this.domNode, "wmBackButton");
        } else {
            var icon = this.iconNode = document.createElement("div");
            dojo.addClass(icon, "mblArrow " + "mbl" + wm.capitalize(this.direction) + "Arrow");
            this.domNode.appendChild(icon);
        }
    },
    setCaption: function(inCaption) {
        this.caption = inCaption;
        if (this.captionNode) this.captionNode.innerHTML = inCaption;
    },
    render: function(forceRender, noInherited) {
       wm.Control.prototype.render.call(this, forceRender);
    }

});

}

if(!dojo._hasResource["wm.base.widget.Buttons.ToggleButton"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.widget.Buttons.ToggleButton"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */


dojo.provide("wm.base.widget.Buttons.ToggleButton");




dojo.declare("wm.ToggleButton", wm.ToolButton, {
	height: "32px",
	border: 1,
	borderColor: "#ABB8CF",
	margin: 4, 
    /* TODO: Localize This */
	captionUp: "Btn Up",
    /* TODO: Localize This */
        captionDown: "Btn Down",
        classNames: "wmbutton wmtogglebutton",
        init: function() {
	    this.caption = this.captionUp;
	    this.inherited(arguments);
            if (this.clicked)
                this.setClicked(true);
	},
	click: function(inEvent) {
	    this.setProp("clicked", !this.clicked);

	    /* Sometimes users go from an editor to clicking a button and some browsers don't update the editor value in time for
	     * our onclick handler to see it.  So build in a delay before firing onclick handlers
	     */
	    wm.onidle(this, function() {
	        this.onclick(inEvent, this);
	    });
	},
    /* Sets the state, updates the css, does not fire events; useful in a set of toggle buttons where clicking one updates the states of the others, but firing events on each one would be bad */
    setClicked: function(inClicked) {
	/* this._cupdating occurs when initializing a togglebutton whose clicked value is true */
	if (inClicked != this.clicked || this._cupdating) {
	    this.clicked = inClicked;
	    this.valueChanged("clicked", inClicked);
	    this.setCaption(this.clicked ? this.captionDown : this.captionUp);
	    dojo[this.clicked ? "addClass" : "removeClass"](this.domNode, "toggleButtonDown");
	}
    },
    setCaptionUp: function(inCaption) {
        this.captionUp = inCaption;
	if (!this.clicked)
            this.setCaption(inCaption);
    },
    setCaptionDown: function(inCaption) {
        this.captionDown = inCaption;
	if (this.clicked)
            this.setCaption(inCaption);
    }
});

dojo.declare("wm.ToggleButtonPanel", wm.Container, {
    border: "1",
    buttonBorder: "0,1,0,0",
    lastButtonBorder: "0",
    manageURL: false,
    manageHistory: false,
    classNames: "wmtogglebuttonpanel",
    layoutKind: "left-to-right",
    currentButton: -1,
    currentButtonName: "",
    currentButtonCaption: "",
    height: "40px",
    enableTouchHeight: true,
    width: "100%",
    buttonMargins: "0",
    init: function() {
        this._btns = [];
        this.inherited(arguments);
    },
    postInit: function() {
        this.inherited(arguments);
        if (this.manageURL && this.owner.locationState) {
            this.restoreFromLocationHash(this.owner.locationState[this.getRuntimeId()]);
        }
        if (this.buttonBorder || this.lastButtonBorder) {
            dojo.forEach(this.c$, function(button,i) {
                var border = i == this.c$.length - 1 ? this.lastButtonBorder || this.buttonBorder : this.buttonBorder;
                if (button.border != border) {
                    button.setBorder(border);
                }
            }, this);
        }
        if (this.buttonBorderColor) {
            dojo.forEach(this.c$, function(button,i) {
                if (button.borderColor != this.buttonBorderColor) {
                    button.setBorderColor(this.buttonBorderColor);                    
                }
            }, this);
        }            

        /*
	for (var i = 0; i < this.c$.length; i++) {
	    if (this.c$[i] instanceof wm.ToolButton) {
		this.c$[i].connect(this.c$[i], "onclick", dojo.hitch(this, "changed", this.c$[i]));
		this._btns.push(this.c$[i]);
	    }
	}
	*/
    },
    addWidget: function(inWidget) {
        this.inherited(arguments);
        if (inWidget instanceof wm.ToolButton) {
            inWidget.setHeight("100%");
            this._btns.push(inWidget);
            inWidget.connect(inWidget, "onclick", dojo.hitch(this, "changed", inWidget));
            inWidget.setMargin(this.buttonMargins);            
        }
    },
    removeWidget: function(inWidget) {
        this.inherited(arguments);
        wm.Array.removeElement(this._btns, inWidget);
    },
    changed: function(inButton) {
        var currentButtonWas = this.currentButton;
        if (inButton instanceof wm.ToolButton) {
            this.currentButton = inButton;
            this.currentButtonName = inButton.name;
            this.currentButtonCaption = inButton.caption;
            if (inButton) {
                dojo.addClass(inButton.domNode, "toggleButtonDown");
            }
            if (this.currentButton !== currentButtonWas) {
                if (currentButtonWas instanceof wm.ToolButton) {
                    currentButtonWas.setValue("clicked", false);
                }
                this.valueChanged("currentButton", this.currentButton); // currentButton is a bindSource
                this.onChange(this.currentButton);
            }
            this.currentButton.clicked = true; // there are paths where this fails to get set
        } else {
            if (currentButtonWas instanceof wm.ToolButton) {
                currentButtonWas.setValue("clicked", false);
            }
            this.currentButton = null;
            if (currentButtonWas instanceof wm.ToolButton) {
                this.valueChanged("currentButton", this.currentButton); // currentButton is a bindSource
                this.onChange(this.currentButton);
            }
        }
        this.valueChanged("currentButtonName", this.currentButtonName);
        this.valueChanged("currentButtonCaption", this.currentButtonCaption);

        if (currentButtonWas instanceof wm.ToolButton && currentButtonWas != inButton) {
            dojo.removeClass(currentButtonWas.domNode, "toggleButtonDown");
            if (!this._isDesignLoaded && !this._inBack && this.manageHistory && inButton) {
                app.addHistory({
                    id: this.getRuntimeId(),
                    options: {
                        name: currentButtonWas.name
                    },
                    title: inButton.caption + " Selected"
                });
            }

        }
    },
    setCurrentButton: function(inButton) { // currentIndex is a bindTarget
        // why wm.onidle? Without this, a button click event could be clicked before the layer or pagecontainer its trying trigger a navigation to is created
        var self = this;
        wm.job(this.getRuntimeId() + ".setCurrentButton", 1, function() {
            if (inButton instanceof wm.ToolButton) {
                inButton.click({type: "click"});
            } else {
                self.changed(null);
            }
        });
    },


    onChange: function(inButton) {},
    handleBack: function(inOptions) {
        this._inBack = true;
        var name = inOptions ? inOptions.name : null;
        var button = this.owner[name];
        if (button && this.currentButton != button) {
            button.click({
                type: "click"
            });
        }
        delete this._inBack;
        return true;
    },
    restoreFromLocationHash: function(inValue) {
        this.manageHistory = false;
        if (inValue !== undefined) {
            if (this.owner[inValue]) {
                this.setCurrentButton(this.owner[inValue]);
            }
        }
        this.manageHistory = true;
    },
    generateStateUrl: function(stateObj) {
        if (this.currentButton) stateObj[this.getRuntimeId()] = this.currentButton.name;
    }
});

}

if(!dojo._hasResource["wm.base.widget.Picture"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.widget.Picture"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide("wm.base.widget.Picture");

dojo.declare("wm.Picture", [wm.Control, wm.TouchMixinOptional], {
	aspect: "none",
	hint: "",
	width: "100px",
	height: "100px",
	link: "",
	source: "",
	init: function() {
	    this.inherited(arguments);
	    var d = this.domNode;
	    d.innerHTML = '<a><img></a>';
	    dojo.addClass(d, "wmpicture");
	    this.linkNode = d.firstChild;
	    this._touchNode = this.img = this.linkNode.firstChild;
	    dojo.addClass(this.img, "wmpicture-image");
	    //this.connect(this.img, "load", this, "imageLoaded");
        if (!wm.isMobile) {
    	    this.connect(this.img, "click", this, "_onclick");
    	    this.connect(this.linkNode, "click", this, "_onclick");
        }
	    this.setSource(this.source);
	    this.setAspect(this.aspect);
	    this.setLink(this.link);
	    if (this.imageList) this.imageListChanged();
	},
	postInit: function() {
	    this.inherited(arguments);
	    if (this.onclick != this.constructor.prototype.onclick) {
	        dojo.addClass(this.domNode, "onClickEvent");
	    }
	},
	setSource: function(inSource) {
	    this.source = inSource || "";
	    this.valueChanged("source", this.source);
	    this.img.style.display = this.source ? "" : "none"; // hiding now done by className
	    var root;
	    if (this.source.slice(0, 4) == "http" || this.source.slice(0, 1) == "/") {
	        root = "";
	    } else if (this.source.indexOf("lib/") == 0) {
	        root = dojo.moduleUrl("lib").path.replace(/lib\/$/, "");
	    } else {
	        root = this.getPath();
	    }
	    this.img.src = root + this.source;
	},

	setAspect: function(inAspect) {
	    var s = this.img.style,
	        w = "width",
	        h = "height",
	        a = this.aspect = inAspect;
	    s.width = (a == "v" ? "100%" : "");
	    s.height = (a == "h" ? "100%" : "");
	},
	setLink: function(inLink) {
	    this.link = inLink;
	    if (inLink) {
	        this.linkNode.target = "_blank";
	        this.linkNode.href = inLink;
	    } else this.linkNode.removeAttribute("href");

	    /* Make it bindable */
	    this.valueChanged("link", inLink);
	},
	onTouchEnd: function(evt, isMove) {
		if (isMove) return;
		/* Force inputs to fire onchange events and update bound service var inputs if they have focus.
		 * Normally, on touch devices, a touchstart and touchend can happen without the editor ever losing focus,
		 * triggering its dijit's onBlur, and delivering new values.
		 */
		if (document.activeElement.tagName == "INPUT") {
			var id = document.activeElement.id;
			var d = dijit.byId(id);
			if (d) d._onBlur();
			else document.activeElement.blur();
		}
		if (!this._disabled) {
    		this.onclick(evt);
    	}
	},
    _onclick: function(inEvent) {
        dojo.stopEvent(inEvent);
        if (this._disabled) return;
        var pseudoEvt = dojo.isIE && inEvent ? {
                    clientX: inEvent.clientX,
                    clientY: inEvent.clientY,
                    offsetX: inEvent.offsetX,
                    offsetY: inEvent.offsetY,
                    screenX: inEvent.screenX,
                    screenY: inEvent.screenY,
                    pageX: inEvent.pageX,
                    pageY: inEvent.pageY,
                    x: inEvent.x,
                    y: inEvent.y,
                    target: inEvent.target,
                    currentTarget: inEvent.currentTarget,
                    "type": inEvent.type
                } : inEvent || {};
        window.setTimeout(dojo.hitch(this, "onclick",pseudoEvt), 5);
    },
	onclick: function() {
	},


	imageListChanged: function() {
	    this.inherited(arguments);
	    if (this._imageList) {
		this.linkNode.style.display = "inline-block";
		this.linkNode.className = "wmpicture " + this._imageList.getImageClass(this.imageIndex);
	    }
	},
    toHtml: function() {
        var style = this.toHtmlStyles();
	   return "<img " + style + " class='wmpicture' style='width:" + this.bounds.w + "px;height:" + this.bounds.h + "px' src='" + this.img.src + "'/>";
    }
});


}

if(!dojo._hasResource["wm.base.widget.Label"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.widget.Label"] = true;
/*
* Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
* http://www.apache.org/licenses/LICENSE-2.0
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
dojo.provide("wm.base.widget.Label");


dojo.declare("wm.Label", [wm.Control, wm.TouchMixinOptional], {
    width: "200px",
    height: "24px",
    caption: 'Label',
    link: '',
    display: '',
    //resizeToFit: "(Resize to Fit)",
    padding: 4,
    singleLine: true,
    align: "none",
    init: function() {
        dojo.addClass(this.domNode, "wmlabel");
        this.inherited(arguments);
        if (!wm.isMobile) {
            this.connect(this.domNode, "onclick", this, "_onclick");
        }
        // this.connectEvents(this.domNode, ["dblclick"]); WAVEMAKER: Uncomment this if we find a good use for this...
    },
    build: function() {
        this.inherited(arguments);
        if (!this.noSizeNode) {
            this.sizeNode = document.createElement("div");
            dojo.addClass(this.sizeNode, "wmSizeNode");
            this.domNode.appendChild(this.sizeNode);
        } else {
            this.sizeNode = this.domNode;
        }
    },
	onTouchEnd: function(evt, isMove) {
		if (isMove) return;
		/* Force inputs to fire onchange events and update bound service var inputs if they have focus.
		 * Normally, on touch devices, a touchstart and touchend can happen without the editor ever losing focus,
		 * triggering its dijit's onBlur, and delivering new values.
		 */
		if (document.activeElement.tagName == "INPUT") {
			var id = document.activeElement.id;
			var d = dijit.byId(id);
			if (d) d._onBlur();
			else document.activeElement.blur();
		}
		if (!this._disabled) {
    		this.click(evt);
    	}
	},
    _onclick: function(inEvent) {
        if (this.name == "label2") {
            console.log("Label2");
        }
        if (this._disabled) return;
        var pseudoEvt = dojo.isIE && inEvent ? {
            clientX: inEvent.clientX,
            clientY: inEvent.clientY,
            offsetX: inEvent.offsetX,
            offsetY: inEvent.offsetY,
            screenX: inEvent.screenX,
            screenY: inEvent.screenY,
            pageX: inEvent.pageX,
            pageY: inEvent.pageY,
            x: inEvent.x,
            y: inEvent.y,
            target: inEvent.target,
            currentTarget: inEvent.currentTarget,
            "type": inEvent.type
        } : inEvent || {};
        window.setTimeout(dojo.hitch(this, "click", pseudoEvt), 5);
    },
    click: function(e) {
        this.onclick(e);
    },
    /* Uncomment this if/when we find a good use for it
dblclick: function(e) {
this.ondblclick(e);
},
ondblclick: function(inEvent) {
}, */
    postInit: function() {
        this.inherited(arguments);
        this.caption = this.label || this.content || this.caption;
        // bc
        delete this.content;
        delete this.label;
        this.renderLabel();
        this.valueChanged("caption", this.caption);
        this.valueChanged("link", this.link);
        if (this.onclick != this.constructor.prototype.onclick) {
            dojo.addClass(this.domNode, "onClickEvent");
        }
    },
    renderLabel: function() {
        if (this._loading) return;

        var c = this.caption;
        if (this.$.format) {
            c = this.$.format.format(c);
        } else if (this.display && dojo.isFunction(this.owner[this.display])) {
            try {
                c = this.owner[this.display](this, c);
            } catch (e) {
                console.error("Formatter error in " + this.toString() + ": " + e);
            }
        }

        if (this.link) {
            if (this._disabled) {
                c = ['<a href="#">', c, '</a>'].join('');
            } else {
                c = ['<a ', (this.link.indexOf("#") == -1 && this.link.indexOf("javascript") == -1) ? 'target="_blank" ' : '', 'href="', this.link, '">', c, '</a>'].join('');
            }
        }
        if (this.domNode.innerHTML != c) this.sizeNode.innerHTML = c;
        var whitespace = (this.singleLine || this.autoSizeWidth) ? "nowrap" : "normal";
        if (this.domNode.style.whiteSpace != whitespace) this.domNode.style.whiteSpace = whitespace;
        var align = (this.align == "none") ? "" : this.align;
        if (this._align != align && (!this.styles || !this.styles.textAlign)) {
            this.domNode.style.textAlign = align;
            this._align = align;
        }
        //this.reflowParent();
        //this.doAutoSize();
    },
    setDisabled: function(inDisabled) {
        this.inherited(arguments);
        if (!this._cupdating) {
            this.renderLabel();
        }
    },
    setCaption: function(inCaption) {
        if (inCaption == undefined) inCaption = "";
        var innerHTML = this.sizeNode.innerHTML;
        if (inCaption && dojo.isArray(inCaption)) {
            inCaption = inCaption.join(', ');
        } else if (inCaption && dojo.isObject(inCaption) && (!this.$.format || this.$.format instanceof wm.ArrayFormatter === false)) {
            inCaption = "";
        }
        this.caption = inCaption;
        this.renderLabel();
        if (innerHTML != this.sizeNode.innerHTML && (this.autoSizeHeight || this.autoSizeWidth)) {
            this.scheduleAutoSize();
        }

        /* Make it bindable */
        this.valueChanged("caption", inCaption);
    },

    scheduleAutoSize: function() {
        this._needsAutoSize = true;
        return wm.job(this.getRuntimeId() + ": doAutoSize", 10, dojo.hitch(this, function() {
            this.doAutoSize(true, false);
        }));
    },
    _onShowParent: function() {
        if (this._needsAutoSize) {
            this.scheduleAutoSize();
        }
    },
    doAutoSize: function(setSize, force) {
        if (this._doingAutoSize || !this.autoSizeHeight && !this.autoSizeWidth) return;
        if (!force && !this._needsAutoSize) return;

        if (this.isAncestorHidden()) {
            return;
        }

        this._doingAutoSize = true;
        this._needsAutoSize = false;

        var sizeNode = this.sizeNode;
        var contentHeight = sizeNode.offsetHeight;
        var contentWidth = sizeNode.offsetWidth;
        if (this.autoSizeHeight) {
            var newHeight = contentHeight + this.padBorderMargin.t + this.padBorderMargin.b;
            if (newHeight < this.minHeight) {
                newHeight = this.minHeight;
            }

            /* Account for space needed for scrollbars */
            if (contentWidth > this.bounds.w) {
                newHeight += 17;
            }
            this.bounds.h = newHeight;
            this.height = newHeight + "px";
            /*
if (setSize) {
this.setHeight(newHeight + "px");
} else {
this.bounds.h = newHeight;
this.height = newHeight + "px";
}
*/

            var p = this.parent;
            while (p.parent && (p.autoSizeHeight || p.fitToContentHeight)) {
                p = p.parent;
            }
            p.delayedReflow();

        }
        if (this.autoSizeWidth) {

            var newWidth = contentWidth + this.padBorderMargin.l + this.padBorderMargin.r; /* Account for space needed for scrollbars */
            if (contentHeight > this.bounds.h) {
                newWidth += 17;
            }
            this.bounds.w = newWidth;
            this.width = newWidth + "px";
            /*
if (setSize) {
this.setWidth(newWidth + "px");
} else {
this.bounds.w = newWidth;
this.width = newWidth + "px";
}
*/
            var p = this.parent;
            while (p.parent && (p.autoSizeWidth || p.fitToContentWidth)) {
                p = p.parent;
            }
            p.delayedReflow();
        }


        // the line underneath updates panel's width property. Therefore only required for studio.
        if (this.isDesignLoaded() && dojo.indexOf(studio.designer.selected, this) != -1)
            studio.inspector.reinspect();
        this._doingAutoSize = false;
    },
    setLink: function(inLink) {
        var oldLink = this.link;
        this.link = inLink;
        this.renderLabel();

        /* Make it bindable */
        this.valueChanged("link", inLink);
    },
    setSingleLine: function(inSingleLine) {
        var oldSingleLine = this.singleLine;
        this.singleLine = inSingleLine;
        if (oldSingleLine != inSingleLine) this.domNode.style.lineHeight = (inSingleLine) ? this.bounds.h + "px" : "normal";
        this.renderLabel();
        if (inSingleLine && this.autoSizeHeight) this.autoSizeHeight = false;

        if (inSingleLine != oldSingleLine && (this.autoSizeHeight || this.autoSizeWidth)) {
            this.scheduleAutoSize();
        }
    },
    setAlign: function(inAlign) {
        this.align = inAlign;
        this.renderLabel();
    },
    formatChanged: function() {
        this.renderLabel();
    },
    onclick: function(inEvent) {},

    toHtml: function() {
        var style = this.toHtmlStyles();
        return "<div " + style + " style='text-align:" + (this.align || "left") + ";' id='" + this.domNode.id + "'>" + (this.sizeNode.innerHTML) + "</div>";
    }
});

// NOTE: This sizing node is used by ALL classes that need a sizing node (wm.Html, wm.Base, etc...)
wm.Label.sizingNode = document.createElement("div");

}

if(!dojo._hasResource["wm.base.widget.Html"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.widget.Html"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide("wm.base.widget.Html");

dojo.declare("wm.Html", wm.Control, {
    minHeight: 15,
    width: "100%",
    height: "200px",
	html: "",
	htmlIsResource: false,
        autoScroll: true,
    allowScriptTags: false,
	init: function() {
		dojo.addClass(this.domNode, "wmhtml");
		this.inherited(arguments);
	    this.connect(this.domNode, "onclick", this, function(evt) {
		wm.onidle(this, "onclick", evt);
	    });
	    if (this.html && String(this.html).indexOf('resources/') === 0) {
	    	this.htmlIsResource = true;
	    }
	    this.setHtml(this.html);
	},
    build: function() {
	this.inherited(arguments);
	this.sizeNode = document.createElement("div");
	dojo.addClass(this.sizeNode, "wmSizeNode");
	this.domNode.appendChild(this.sizeNode);
    },
	getHtml: function() {
		return this.sizeNode.innerHTML;
	},
	setHtml: function(inHtml) {
                var innerHTML = this.sizeNode.innerHTML;
	        if (inHtml && this.htmlIsResource)
		{
			if (!this.htmlLoader)
				this.htmlLoader = new wm.HtmlLoader({owner: this, relativeUrl: true});
			this.htmlLoader._htmlNode = this.sizeNode;
			this.htmlLoader.setUrl(inHtml);
			this.html = inHtml;
		        this.valueChanged("html", inHtml);
                        if ( innerHTML != this.sizeNode.innerHTML && (this.autoSizeHeight || this.autoSizeWidth)) {
		            this.scheduleAutoSize();
                        }
			return;
		}

		if (inHtml && dojo.isArray(inHtml))
			inHtml = inHtml.join('');
		if (inHtml && inHtml.value)
			inHtml = inHtml.value;
	    this.html = this.sizeNode.innerHTML = (inHtml == undefined ? "" : inHtml);
	        this.valueChanged("html", this.inHtml);
                if ( innerHTML != this.sizeNode.innerHTML && (this.autoSizeHeight || this.autoSizeWidth)) {
                    this.scheduleAutoSize();
                }
        if (this.allowScriptTags) this.processScriptTags();
	},
    processScriptTags: function() {
        var nodes = dojo.query("script", main.html1.domNode);
        var tmpparent = document.createElement("div");
        dojo.forEach(nodes, function(node) {
            var originalParent = node.parentNode;
            var originalIndex = dojo.indexOf(originalParent.childNodes, node);
            tmpparent.appendChild(node);
            var scripthtml = tmpparent.innerHTML;

            var n = document.createElement("script");
            /* Find properties set by developer like djconfig and other arbitrary properties that may be written into the script node */
            var props = {};
            var parts = scripthtml.replace(/\<script\s*/,"").replace(/\>.*/,"").split(/\s+/);
            var partialName = "";
            var partialValue = "";
            for (var i = 0; i < parts.length; i++) {
                var part = parts[i];
                if (!partialValue) {
                    var namevaluematch = part.match(/^(.*?)\s*\=\s*(.*)\s*$/);
                    if (namevaluematch) {
                        var name = namevaluematch[1];
                        var value = namevaluematch[2];
                    }
                } else {
                    value = partialValue + " " + part;
                    partialValue = "";
                }
                if (value) {
                    value = value.replace(/^"(.*)"/,"$1");
                    value = value.replace(/^'(.*)'/,"$1");
                    if (value.match(/^['"]/)) {
                        partialValue = value;
                        partialName = name;
                    } else {
                        dojo.attr(n,name,value);
                    }

                }
            }

            try {
                n.innerText = node.innerText;
            }catch(e){}
            try {
                n.textContent = node.textContent;
            }catch(e){}

            dojo.destroy(node);
            dojo.place(n, originalParent, originalIndex);
        }, this);
    },
    scheduleAutoSize: function() {
        this._needsAutoSize = true;
        return wm.job(this.getRuntimeId() + ": doAutoSize", 10,  dojo.hitch(this, function() {this.doAutoSize(true,true);}));
    },
 _onShowParent: function() {
        if (this._needsAutoSize) {
            this.scheduleAutoSize();
        }
    },
     doAutoSize: function(setSize, force) {
            if (this._doingAutoSize || !this.autoSizeHeight && !this.autoSizeWidth) return;
	    if (!force && !this._needsAutoSize) return;

	    if (this.isAncestorHidden()) {
		return;
	    }

            this._doingAutoSize = true;
	    this._needsAutoSize = false;

	    var sizeNode = this.sizeNode;
	    var contentHeight = sizeNode.offsetHeight;
	    var contentWidth = sizeNode.offsetWidth;
	    if (this.autoSizeHeight) {
		var newHeight = contentHeight + this.padBorderMargin.t + this.padBorderMargin.b;
		if (newHeight < this.minHeight) {
		    newHeight = this.minHeight;
		}

		/* Account for space needed for scrollbars */
		if (contentWidth > this.bounds.w) {
		    newHeight += 17;
		}
		    this.bounds.h = newHeight;
		    this.height = newHeight + "px";
/*
		if (setSize) {
		    this.setHeight(newHeight + "px");
		} else {
		    this.bounds.h = newHeight;
		    this.height = newHeight + "px";
		}
		*/

		var p = this.parent;
		while (p.parent && (p.autoSizeHeight || p.fitToContentHeight)) {
		    p = p.parent;
		}
		p.delayedReflow();

	    }
	    if (this.autoSizeWidth) {

		var newWidth = contentWidth + this.padBorderMargin.l + this.padBorderMargin.r;
		/* Account for space needed for scrollbars */
		if (contentHeight > this.bounds.h) {
		    newWidth += 17;
		}
		    this.bounds.w = newWidth;
		    this.width = newWidth + "px";
/*
		if (setSize) {
		    this.setWidth(newWidth + "px");
		} else {
		    this.bounds.w = newWidth;
		    this.width = newWidth + "px";
		}
		*/
		var p = this.parent;
		while (p.parent && (p.autoSizeWidth || p.fitToContentWidth)) {
		    p = p.parent;
		}
		p.delayedReflow();
	    }


	    // the line underneath updates panel's width property. Therefore only required for studio.
	    if (this.isDesignLoaded() && dojo.indexOf(studio.designer.selected, this) != -1)
		studio.inspector.reinspect();
            this._doingAutoSize = false;
	},

	appendHtml: function(inHtml) {
	    if (inHtml && dojo.isArray(inHtml))
		inHtml = inHtml.join('');
	    if (inHtml && inHtml.value)
		inHtml = inHtml.value;
	    this.sizeNode.innerHTML += (inHtml == undefined ? "" : inHtml);
	    this.html = this.sizeNode.innerHTML;
	    this.valueChanged("html", this.inHtml);
	},
	onclick: function() {
	},
        addUserClass: function(inClass, inNodeName) {
	    this.inherited(arguments);
	    if (this.isDesignLoaded())
                if (this.autoSizeHeight || this.autoSizeWidth)
	            this.doAutoSize(1,1);
        },
    getAutoSize: function() {
	if (this.autoSizeWidth) return "width";
	if (this.autoSizeHeight) return "height";
	return "none";
    },
    /* This hack should only be called at design time */
    setAutoSize: function(inValue) {
        if (inValue == "none") {
	    if (this.autoSizeWidth)
		this.setAutoSizeWidth(false);
	    if (this.autoSizeHeight)
		this.setAutoSizeHeight(false);
        } else if (inValue == "width") {
	    if (!this.autoSizeWidth)
		this.setAutoSizeWidth(true);
	    if (this.autoSizeHeight)
		this.setAutoSizeHeight(false);

        } else if (inValue == "height") {
	    if (this.autoSizeWidth)
		this.setAutoSizeWidth(false);
	    if (!this.autoSizeHeight)
		this.setAutoSizeHeight(true);
        }
    },
    toHtml: function() {
	return this.html;
    }
});


}

if(!dojo._hasResource["wm.base.widget.PageContainer"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.widget.PageContainer"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide("wm.base.widget.PageContainer");



wm.pagesFolder = "pages/";

dojo.declare("wm.PageContainer", wm.Control, {
    manageHistory: false,
    manageURL: false,
    subpageProplist: null,
    subpageEventlist: null,
    subpageMethodlist: null,
    width: "100%",
    height: "100%",
    pageName: "",
    phonePageName: "",
    tabletPageName: "",
    deferLoad: false,
    loadParentFirst: true,
    classNames: "wmpagecontainer",
    init: function() {
        this.pageLoadedList = [];
        this.inherited(arguments);
        this.createPageLoader();
        this.pageLoadedDeferred = new dojo.Deferred();

        this.updatePageName();
        this._initialPageName = this._pageName;
        if (this.manageURL && app && app.locationState && app.locationState[this.getRuntimeId()]) {
            this.pageName = this._pageName = app.locationState[this.getRuntimeId()];
            this._restoringLocationState = true;
        }
        if (app && app.locationState) {
            this._locationState = app.locationState;
        }

        if (!this.deferLoad || !this.isAncestorHidden()) this.loadPage(this._pageName);
        //this._connections.push(dojo.connect(window, "onbeforeunload", this, "destroy"));
        dojo.addOnWindowUnload(this, 'destroy');

        if (this.subpageEventlist && !this._isDesignLoaded) {
            for (var propName in this.subpageEventlist) {
                if (this[propName] === undefined) {
                    this[propName] = function() {};
                }
            }
        }
        if (this.subpageMethodlist && !this._isDesignLoaded) {
            wm.forEachProperty(this.subpageMethodlist, dojo.hitch(this, function(value, name) {
                this[name] = dojo.hitch(this, function() {
                    var w = this.page.getValueById(value.replace(/\..*?$/, ""));
                    var f = w[value.replace(/^.*\./, "")];
                    f.apply(w, arguments);
                });
            }));
        }
        if (this._isDesignLoaded) {
            this.subscribe("deviceSizeRecalc", dojo.hitch(this, "updateDesignTimePageName"));
        }
    },
    updatePageName: function() {
        var device = this._isDesignLoaded ? studio.currentDeviceType : wm.device;
        if (device == "phone" && this.phonePageName) this._pageName = this.phonePageName;
        else if (device == "tablet" && this.tabletPageName) this._pageName = this.tabletPageName;
        else this._pageName = this.pageName;
        if (this._isDesignLoaded && !this._cupdating) {
            this.loadPage(this._pageName);
        }
    },
    postInit: function() {
        this.inherited(arguments);
        if (this.isDesignedComponent() && this.designWrapper) {
            dojo.addClass(this.designWrapper.domNode, "pageContainerDesignWrapper");
            this.designWrapper.domNode.style.backgroundColor = "white";
            this.createOpenPageButton();
        }
        if (this.isDesignedComponent() && this.getRoot() instanceof wm.Application) {
            this.subscribe("Page-Saved", dojo.hitch(this, function() {
                if (this._pageName == studio.project.pageName) {
                    this.forceReloadPage();
                }
            }));
        }
    },
    setBoundProp: function(inName) {
        if (this["_inSetBoundProp_" + inName]) return;
        this["_inSetBoundProp_" + inName] = true;
        try {
            var value = this.getProp(inName);
            this[inName] = value;
            this.valueChanged(inName, value);
            if (value instanceof wm.Variable) {
                var id = this.getRuntimeId(inName);
                dojo.publish(id + "-ownerChanged");
            }
        } catch(e) {}
        delete this["_inSetBoundProp_" + inName];
    },
    setProp: function(inName, inValue) {
        if (this.subpageProplist !== null && this.page && this.subpageProplist[inName]) {
            var prop = this.subpageProplist[inName];
            if (prop) {
                if (inValue instanceof wm.Component === false) this[inName] = inValue;
                if (prop.indexOf(".") == -1 && this.page.getValue(prop) instanceof wm.Variable) {
                    return this.page.getValue(prop).setDataSet(inValue);
                } else {
                    return this.page.setValue(prop, inValue);
                }
            }
        } else if (this.subpageEventlist !== null && this.page && this.subpageEventlist[inName]) {
            var prop = this.subpageEventlist[inName];
            if (prop) {
                if (this._isDesignLoaded) {
                    return this.setEvent(inName, inValue);
                } else {
                    return this.inherited(arguments);
                }
            }
        }
        return this.inherited(arguments);
    },
    getProp: function(inName) {
        if (this.subpageProplist !== null && this.page) {
            var prop = this.subpageProplist[inName];
            if (prop) {
                return this.page.getValue(prop);
            }
        }
        if (this._isDesignLoaded && this.subpageEventlist !== null && this.page) {
            var prop = this.subpageEventlist[inName];
            if (prop) {
                return this._getProp(inName);
            }
        }
        return this.inherited(arguments);
    },

    onError: function(inErrorOrMessage) {},
    createPageLoader: function() {
        this._pageLoader = new wm.PageLoader({
            owner: this,
            domNode: this.domNode,
            isRelativePositioned: this.isRelativePositioned
        });
        this._connections.push(this.connect(this._pageLoader, "onPageChanged", this, "pageChanged"));
        this._connections.push(this.connect(this._pageLoader, "onError", this, "onError"));
    },
    getMainPage: function() {
        var owner = this.owner;
        while (owner.owner) {
            owner = owner.owner;
        }
        if (owner instanceof wm.Application) return owner;
    },
    /* Not sure if this gets called */
    destroy: function() {
        if (this.isDestroyed) return;
        var owner = this.getMainPage();
        if (owner) owner.subPageUnloaded(this.page);
        try {
            this.inherited(arguments);
        } catch (e) {}

        if (this._pageLoader) {
            this.destroyPreviousPage();
            this._pageLoader.destroy();
            this._pageLoader = null;
        }
        owner = null;
    },
    destroyPreviousPage: function() {
        for (var i = 0; i < this.pageLoadedList.length; i++) {
            try {
                this._pageLoader.destroyPage(this.pageLoadedList[i]);
            } catch (e) {
                console.info('couldnt delete page <--------------');
            }
        }

        this.pageLoadedList = [];
    },
    pageChanged: function(inPage, inPreviousPage) {
        try {
            // establish page reference
            this.destroyPreviousPage();
            this.pageLoadedList.push(inPage);
            this.page = inPage;
            this[inPage.name] = inPage;

            var owner = this.getMainPage();
            if (owner) owner.subPageLoaded(this.page);

            // FIXME: parent required for layout
            if (this.page.root) this.page.root.parent = this;
            // change callback / event
            if (this.pageLoadedDeferred) {
	            this.pageLoadedDeferred.callback({
	                page: inPage,
	                previousPage: inPreviousPage
	            });
	            delete this.pageLoadedDeferred;
	        }
            this.onPageChanged(inPage, inPreviousPage);
            // clean up previous page reference
            var o = (inPreviousPage || 0).name;
            if (o && this[o]) delete this[o];
        } catch (e) {
            console.info('error in pageChanged in pagecontainer.js ......', e);
        }
    },
    loadPage: function(inName) {
        try {
			if (!this.pageLoadedDeferred) {
                this.pageLoadedDeferred = new dojo.Deferred();
            }
            var d = this.isDesignLoaded(),
                s = wm.studioConfig;
            if (d && s && s.preventSubPages) return;
            // bc: name with initial letter lowercase is required
            var pageName = inName.charAt(0).toLowerCase() + inName.slice(1);

            // If the design is loaded, then page loading of the container is handled elsewhere.
            if (pageName) {
                if (!d && this.loadParentFirst) {
                    var parentPage = this.getParentPage();
                }
                if (!d && this.loadParentFirst && parentPage && parentPage._loadingPage) {
                    // Prevent this from being connected multiple times
                    if (!this._pageLoaderConnectedToOwnerStart) {
                        if (this._currentPageConnect) dojo.disconnect(this._currentPageConnect);
                        this._currentPageConnect = this.owner.connect(this.owner, "onStart",
                            dojo.hitch(this, 'pageLoaderOnOwnerStart', inName, pageName));
                        this._pageLoaderConnectedToOwnerStart = true;
                    }
                } else {
                    this._pageLoader.loadPage(inName, pageName);
                    if (this._currentPageConnect) dojo.disconnect(this._currentPageConnect);
                    if (this._pageLoader.page._startCalled) this.onStart();
                    else this._currentPageConnect = this._pageLoader.page.connect(this._pageLoader.page, "onStart", this, "onStart");
                }
            } else {
                this.destroyPreviousPage();
            }
        } catch (e) {
            console.error("PageContainer page  '" + inName + "' failed to load: " + e);
        }
    },
    pageLoaderOnOwnerStart: function(inName, pageName) {
        this._pageLoaderConnectedToOwnerStart = false;
        this._pageLoader.loadPage(inName, pageName);
        this._pageLoader.page.connect(this._pageLoader.page, "onStart", this, "onStart");
    },
    onStart: function() {
        delete this._locationState;
        if (this.parent && this.page && !dojo.coords(this.page.root.domNode).w) this.parent.reflow();

        if (this.subpageEventlist && this.page) {
            for (var propName in this.subpageEventlist) {
                var propComponent = this.page[propName];
                if (propComponent && propComponent.isEvent && !this._isDesignLoaded) {
                    var componentName = propComponent.property.replace(/\..*?$/, "");
                    var eventName = propComponent.property.replace(/^.*\./, "");
                    var component = this.page.getValue(componentName);
                    this.connect(component, eventName, this, propName);
                }
            }
        }


        if (this.subpageProplist) {

            for (var propName in this.subpageProplist) {
                var v = this[propName];
                if (v instanceof wm.Component && v.isDestroyed) {
                    v = this[propName] = undefined;
                }

                if (v !== undefined) {
                    this.setProp(propName, this[propName]);
                }
                var propDef = this.page[propName];
                if (propDef && propDef.bindSource) {
                    var target = this.page.getRuntimeId() + "." + propDef.property;
                    this.subscribe(target + "-changed", dojo.hitch(this, "setBoundProp", propName));
                    var lastIndex = propDef.property.lastIndexOf(".");
                    if (lastIndex != -1) {
                        target = this.page.getRuntimeId() + "." + propDef.property.substring(0,lastIndex);
                        this.subscribe(target + "-changed", dojo.hitch(this, "setBoundProp", propName));
                    }

                }
            }
            if (this.$.binding) this.$.binding.refresh(); // update all bound values
        }

        if (this._restoringLocationState ||
            (this.manageHistory || this.manageURL) &&
            this._lastPageName && this._lastPageName != this._pageName && !this._isDesignLoaded) {
            app.addHistory({
                id: app && app.pageContainer == this ? "app.pageContainer" : this.getRuntimeId(),
                options: this._backState,
                title: "Show " + this._pageName
            }, !this.manageHistory || this._restoringLocationState);
            delete this._backState;
        }
        delete this._restoringLocationState;
    },
    handleBack: function(inOptions) {
        if (!inOptions.pageName || inOptions.pageName == this._pageName) return false;
        this._restoreBackState = inOptions;
        this.setPageName(inOptions.pageName);
        delete this._restoreBackState;
        return true;
    },
    /*
    restoreFromLocationHash: function(inValue, state) {
    this._locationState = state;
    this.setPageName(inValue);
    },
    */
    generateStateUrl: function(stateObj) {
        if (this.page && this._pageName !== this._initialPageName) {
            stateObj[app && app.pageContainer == this ? "pageName" : this.getRuntimeId()] = this._pageName;
        }
        if (this.page && this.page.generateStateUrl) {
            this.page.generateStateUrl(stateObj);
        }
    },
    forEachWidget: function(inFunc) {
        if (this.page) return this.page.forEachWidget(inFunc);
    },
    setPageName: function(inPageName, optionalInPageType) {
        if (this._pageLoading) return;

        if (this.manageHistory && this._pageName != inPageName && !this._isDesignLoaded) {
            this._backState = {
                pageName: this._pageName
            };
            if (this.page && this.page.generateBackState) {
                this.page.generateBackState(this._backState);
            }
        }
        this._lastPageName = this._pageName;

        if (this._designerOpenPageButton) dojo[this._pageName ? "addClass" : "removeClass"](this._designerOpenPageButton, "hasPageName");

        var o = this._pageName;
        this._pageName = this[optionalInPageType || "pageName"] = inPageName || "";
        if (this.isDesignedComponent() && this.designWrapper) {
            this.createOpenPageButton();
        }

        this.pageLoadedDeferred = new dojo.Deferred();
        if (o != this._pageName || !this.page) {
            this.loadPage(this._pageName);
        } else {
            this.pageChangeIgnored();
        }
        this.valueChanged("pageName", this._pageName);
    },
    pageChangeIgnored: function() {}, // NavigationCall connects to this method
    // Provided for use in debugging. Note that when we do a better job of caching pages from server, we will need to deallocate them in this call
    forceReloadPage: function() {
        var pageName = this._pageName;
        this.setPageName(null);
        delete window[pageName];
        this.setPageName(pageName);
    },
    onPageChanged: function(inNewPage, inPreviousPage) {},
    // optimization: page created when shown if doesn't exist.
    _onShowParent: function() {
        this.revealed();
    },
    _onHideParent: function() {
        if (this.page) {
            wm.fire(this.page, "onHide");
            this.page.root.callOnHideParent();
        }
    },
    revealed: function() {
        if (!this.page) this.loadPage(this._pageName);
        else {
            this.page.onShow();
            if (this.page.root) this.page.root.callOnShowParent();
        }
    },
    flow: function() {
        if (this._boundsDirty) wm.fire(this.page, "reflow");
    },
    reflow: function() {
        this._boundsDirty = true;
        this.flow();
    },
    hasPageLoaded: function(optionalPageName) {
        if (!optionalPageName) return Boolean(this.page);
        return Boolean(this.page && this.page.name == optionalPageName);
    },
    toHtml: function() {
        if (this.page && this.page.root) return this.page.root.toHtml();
        else return "";
    },
    updateIsDirty: function() {
        this.setValue("isDirty", this.getIsDirty());
        wm.fire(this.parent, "updateIsDirty");
    },
    getIsDirty: function() {
        if (this.page && !this.page.isDestroyed) return this.page.root.getIsDirty();
    },
    getOrderedWidgets: function() {
        if (this._isDesignLoaded) return [];
        if (this.page) {
            return [this.page.root];
        } else {
            return [];
        }
    }
});


}

if(!dojo._hasResource["wm.base.widget.Scrim"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.widget.Scrim"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dojo.provide("wm.base.widget.Scrim");

dojo.declare("wm.Scrim", wm.Widget, {
        _noAnimation: false,
	showing: false,
	waitCursor: true,
	init: function() {
	    if (this.owner && this.owner.isDesignedComponent())
		studio.designer.domNode.appendChild(this.domNode);
	    else
		document.body.appendChild(this.domNode);
	    this.inherited(arguments);
		dojo.addClass(this.domNode, "wmscrim");
		// remember, zIndex must be set in style to avoid layout.
		this.domNode.style.zIndex = 20;
		this.domNode.style.position = "absolute";
		if (this.waitCursor)
			this.domNode.style.cursor = "wait";
	    this.subscribe("window-resize", this, "resize");
	},
    resize: function() {
	wm.onidle(this, function() {
	    if (this.showing)
		this.reflowParent();
	});
    },
	reflowParent: function() {
		//if (this.domNode.parentNode)
        if (this.domNode.parentNode)
    		dojo.marginBox(this.domNode, dojo.contentBox(this.domNode.parentNode));
	},
	scrimify: function(/*inFunc*/) {
		var f = dojo.hitch.apply(dojo, arguments);
		this.setShowing(true);
		try{
			f();
			//inFunc();
		}finally{
			this.setShowing(false);
		}
	},
	scrimOnIdle: function(/*inFunc*/) {
		this.setShowing(true);
		var self = this, args = arguments;
		setTimeout(function() {
			self.scrimify.apply(self, args)
		}, 100);
	},

	setShowing: function(inShowing) {
            if (this._cupdating || this._noAnimation)
                return this.inherited(arguments);
	    var animationTime = (this._cupdating || this.showing == inShowing) ? 0 : app.dialogAnimationTime;
	    if (inShowing) {
		if (animationTime) {
		    if (this._hideAnimation) {
			this._hideAnimation.stop();
		    }
		    this._showAnimation = this._showAnimation ||
			dojo.animateProperty({node: this.domNode,
					      properties: {opacity: 0.35},
					      duration: animationTime});
		    if (this._showAnimation.status() != "playing") {
			this.domNode.style.opacity = 0.01;
			this.inherited(arguments);
			this._showAnimation.play();
		    }
		} else {
		    this.inherited(arguments);
		}

	    } else {
		if (animationTime) {
		    if (this._showAnimation)
			this._showAnimation.stop();
		    this._hideAnimation =
			this._hideAnimation ||
			dojo.animateProperty({node: this.domNode,
					      properties: {opacity: 0.01},
					      duration: animationTime,
					      onEnd: dojo.hitch(this, function() {
                                                  if (!this.domNode)
                                                      return;
						  wm.Control.prototype.setShowing.call(this,false);
					      })});
		    if (this._hideAnimation.status() != "playing") {
			this._hideAnimation.play();
		    }
		} else {
		    this.inherited(arguments);
		}
	    }
	},

//	setShowing: function(inShowing) {
//		this.inherited(arguments);
		// FIXME: Try to get scrim behavior in IE.... (not currently working)
		/*if (dojo.isIE) {
			setTimeout(dojo.hitch(this, function() {
				if (this.waitCursor)
					document.body.style.cursor = inShowing ? "wait" : "";
				document.body[inShowing ? "setCapture" : "releaseCapture"](true);
			}), 0);
		}*/
//	},
	scrimifyDeferred: function(inDeferred) {
		this.setShowing(true);
		inDeferred.addCallback(dojo.hitch(this, this.setShowing, false));
	}
});

}

if(!dojo._hasResource["dojo.dnd.Mover"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.Mover"] = true;
dojo.provide("dojo.dnd.Mover");





dojo.declare("dojo.dnd.Mover", null, {
	constructor: function(node, e, host){
		// summary:
		//		an object which makes a node follow the mouse, or touch-drag on touch devices.
		//		Used as a default mover, and as a base class for custom movers.
		// node: Node
		//		a node (or node's id) to be moved
		// e: Event
		//		a mouse event, which started the move;
		//		only pageX and pageY properties are used
		// host: Object?
		//		object which implements the functionality of the move,
		//	 	and defines proper events (onMoveStart and onMoveStop)
		this.node = dojo.byId(node);
		var pos = e.touches ? e.touches[0] : e;
		this.marginBox = {l: pos.pageX, t: pos.pageY};
		this.mouseButton = e.button;
		var h = (this.host = host), d = node.ownerDocument;
		this.events = [
			// At the start of a drag, onFirstMove is called, and then the following two
			// connects are disconnected
			dojo.connect(d, "onmousemove", this, "onFirstMove"),
			dojo.connect(d, "ontouchmove", this, "onFirstMove"),

			// These are called continually during the drag
			dojo.connect(d, "onmousemove", this, "onMouseMove"),
			dojo.connect(d, "ontouchmove", this, "onMouseMove"),

			// And these are called at the end of the drag
			dojo.connect(d, "onmouseup",   this, "onMouseUp"),
			dojo.connect(d, "ontouchend", this, "onMouseUp"),

			// cancel text selection and text dragging
			dojo.connect(d, "ondragstart",   dojo.stopEvent),
			dojo.connect(d.body, "onselectstart", dojo.stopEvent)
		];
		// notify that the move has started
		if(h && h.onMoveStart){
			h.onMoveStart(this);
		}
	},
	// mouse event processors
	onMouseMove: function(e){
		// summary:
		//		event processor for onmousemove/ontouchmove
		// e: Event
		//		mouse/touch event
		dojo.dnd.autoScroll(e);
		var m = this.marginBox,
			pos = e.touches ? e.touches[0] : e;
		this.host.onMove(this, {l: m.l + pos.pageX, t: m.t + pos.pageY}, e);
		dojo.stopEvent(e);
	},
	onMouseUp: function(e){
		if(dojo.isWebKit && dojo.isMac && this.mouseButton == 2 ?
				e.button == 0 : this.mouseButton == e.button){ // TODO Should condition be met for touch devices, too?
			this.destroy();
		}
		dojo.stopEvent(e);
	},
	// utilities
	onFirstMove: function(e){
		// summary:
		//		makes the node absolute; it is meant to be called only once.
		// 		relative and absolutely positioned nodes are assumed to use pixel units
		var s = this.node.style, l, t, h = this.host;
		switch(s.position){
			case "relative":
			case "absolute":
				// assume that left and top values are in pixels already
				l = Math.round(parseFloat(s.left)) || 0;
				t = Math.round(parseFloat(s.top)) || 0;
				break;
			default:
				s.position = "absolute";	// enforcing the absolute mode
				var m = dojo.marginBox(this.node);
				// event.pageX/pageY (which we used to generate the initial
				// margin box) includes padding and margin set on the body.
				// However, setting the node's position to absolute and then
				// doing dojo.marginBox on it *doesn't* take that additional
				// space into account - so we need to subtract the combined
				// padding and margin.  We use getComputedStyle and
				// _getMarginBox/_getContentBox to avoid the extra lookup of
				// the computed style.
				var b = dojo.doc.body;
				var bs = dojo.getComputedStyle(b);
				var bm = dojo._getMarginBox(b, bs);
				var bc = dojo._getContentBox(b, bs);
				l = m.l - (bc.l - bm.l);
				t = m.t - (bc.t - bm.t);
				break;
		}
		this.marginBox.l = l - this.marginBox.l;
		this.marginBox.t = t - this.marginBox.t;
		if(h && h.onFirstMove){
			h.onFirstMove(this, e);
		}
		
		// Disconnect onmousemove and ontouchmove events that call this function
		dojo.disconnect(this.events.shift());
		dojo.disconnect(this.events.shift());
	},
	destroy: function(){
		// summary:
		//		stops the move, deletes all references, so the object can be garbage-collected
		dojo.forEach(this.events, dojo.disconnect);
		// undo global settings
		var h = this.host;
		if(h && h.onMoveStop){
			h.onMoveStop(this);
		}
		// destroy objects
		this.events = this.node = this.host = null;
	}
});

}

if(!dojo._hasResource["dojo.dnd.Moveable"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.Moveable"] = true;
dojo.provide("dojo.dnd.Moveable");




/*=====
dojo.declare("dojo.dnd.__MoveableArgs", [], {
	// handle: Node||String
	//		A node (or node's id), which is used as a mouse handle.
	//		If omitted, the node itself is used as a handle.
	handle: null,

	// delay: Number
	//		delay move by this number of pixels
	delay: 0,

	// skip: Boolean
	//		skip move of form elements
	skip: false,

	// mover: Object
	//		a constructor of custom Mover
	mover: dojo.dnd.Mover
});
=====*/

dojo.declare("dojo.dnd.Moveable", null, {
	// object attributes (for markup)
	handle: "",
	delay: 0,
	skip: false,
	
	constructor: function(node, params){
		// summary:
		//		an object, which makes a node moveable
		// node: Node
		//		a node (or node's id) to be moved
		// params: dojo.dnd.__MoveableArgs?
		//		optional parameters
		this.node = dojo.byId(node);
		if(!params){ params = {}; }
		this.handle = params.handle ? dojo.byId(params.handle) : null;
		if(!this.handle){ this.handle = this.node; }
		this.delay = params.delay > 0 ? params.delay : 0;
		this.skip  = params.skip;
		this.mover = params.mover ? params.mover : dojo.dnd.Mover;
		this.events = [
			dojo.connect(this.handle, "onmousedown", this, "onMouseDown"),
			dojo.connect(this.handle, "ontouchstart", this, "onMouseDown"),
			// cancel text selection and text dragging
			dojo.connect(this.handle, "ondragstart",   this, "onSelectStart"),
			dojo.connect(this.handle, "onselectstart", this, "onSelectStart")
		];
	},

	// markup methods
	markupFactory: function(params, node){
		return new dojo.dnd.Moveable(node, params);
	},

	// methods
	destroy: function(){
		// summary:
		//		stops watching for possible move, deletes all references, so the object can be garbage-collected
		dojo.forEach(this.events, dojo.disconnect);
		this.events = this.node = this.handle = null;
	},
	
	// mouse event processors
	onMouseDown: function(e){
		// summary:
		//		event processor for onmousedown/ontouchstart, creates a Mover for the node
		// e: Event
		//		mouse/touch event
		if(this.skip && dojo.dnd.isFormElement(e)){ return; }
		if(this.delay){
			this.events.push(
				dojo.connect(this.handle, "onmousemove", this, "onMouseMove"),
				dojo.connect(this.handle, "ontouchmove", this, "onMouseMove"),
				dojo.connect(this.handle, "onmouseup", this, "onMouseUp"),
				dojo.connect(this.handle, "ontouchend", this, "onMouseUp")
			);
			var pos = e.touches ? e.touches[0] : e;
			this._lastX = pos.pageX;
			this._lastY = pos.pageY;
		}else{
			this.onDragDetected(e);
		}
		dojo.stopEvent(e);
	},
	onMouseMove: function(e){
		// summary:
		//		event processor for onmousemove/ontouchmove, used only for delayed drags
		// e: Event
		//		mouse/touch event
		var pos = e.touches ? e.touches[0] : e;
		if(Math.abs(pos.pageX - this._lastX) > this.delay || Math.abs(pos.pageY - this._lastY) > this.delay){
			this.onMouseUp(e);
			this.onDragDetected(e);
		}
		dojo.stopEvent(e);
	},
	onMouseUp: function(e){
		// summary:
		//		event processor for onmouseup, used only for delayed drags
		// e: Event
		//		mouse event
		for(var i = 0; i < 2; ++i){
			dojo.disconnect(this.events.pop());
		}
		dojo.stopEvent(e);
	},
	onSelectStart: function(e){
		// summary:
		//		event processor for onselectevent and ondragevent
		// e: Event
		//		mouse event
		if(!this.skip || !dojo.dnd.isFormElement(e)){
			dojo.stopEvent(e);
		}
	},
	
	// local events
	onDragDetected: function(/* Event */ e){
		// summary:
		//		called when the drag is detected;
		//		responsible for creation of the mover
		new this.mover(this.node, e, this);
	},
	onMoveStart: function(/* dojo.dnd.Mover */ mover){
		// summary:
		//		called before every move operation
		dojo.publish("/dnd/move/start", [mover]);
		dojo.addClass(dojo.body(), "dojoMove");
		dojo.addClass(this.node, "dojoMoveItem");
	},
	onMoveStop: function(/* dojo.dnd.Mover */ mover){
		// summary:
		//		called after every move operation
		dojo.publish("/dnd/move/stop", [mover]);
		dojo.removeClass(dojo.body(), "dojoMove");
		dojo.removeClass(this.node, "dojoMoveItem");
	},
	onFirstMove: function(/* dojo.dnd.Mover */ mover, /* Event */ e){
		// summary:
		//		called during the very first move notification;
		//		can be used to initialize coordinates, can be overwritten.
		
		// default implementation does nothing
	},
	onMove: function(/* dojo.dnd.Mover */ mover, /* Object */ leftTop, /* Event */ e){
		// summary:
		//		called during every move notification;
		//		should actually move the node; can be overwritten.
		this.onMoving(mover, leftTop);
		var s = mover.node.style;
		s.left = leftTop.l + "px";
		s.top  = leftTop.t + "px";
		this.onMoved(mover, leftTop);
	},
	onMoving: function(/* dojo.dnd.Mover */ mover, /* Object */ leftTop){
		// summary:
		//		called before every incremental move; can be overwritten.
		
		// default implementation does nothing
	},
	onMoved: function(/* dojo.dnd.Mover */ mover, /* Object */ leftTop){
		// summary:
		//		called after every incremental move; can be overwritten.
		
		// default implementation does nothing
	}
});

}

if(!dojo._hasResource["wm.base.widget.Dialogs.Dialog"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.widget.Dialogs.Dialog"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */


dojo.provide("wm.base.widget.Dialogs.Dialog");







wm.dialog = {showingList: [], tabIndexChanges: {}};

wm.dialog.getNextZIndex = function(isDesignLoaded, optionalThis) {
    var index = 30;
    if (!wm.dialog.showingList.length) return index;

    for (var i = 0; i < wm.dialog.showingList.length; i++) {
	if (!isDesignLoaded || isDesignLoaded && wm.dialog.showingList[i]._isDesignLoaded) {
	    if (wm.dialog.showingList[i] instanceof wm.Toast == false && !wm.dialog.showingList[i].docked) {
		if (!optionalThis || wm.dialog.showingList[i] != this)
		    index = Math.max(index, wm.dialog.showingList[i].domNode.style.zIndex);
	    }
	}
    }
    return index+5;
}

wm.dismiss = function(inWidget, inWhy) {
	var o = inWidget;
	while (o && !dojo.isFunction(o.dismiss))
		o = o.owner;
	wm.fire(o, "dismiss", [inWhy]);
}

wm.bgIframe = {
	create: function() {
		var html=[
				"<iframe src='javascript:\"\"'",
				" style='position: absolute; left: 0px; top: 0px;",
				" z-index: 2; filter:Alpha(Opacity=\"0\");'>"
			].join(''),
	    f = this.domNode = (dojo.isIE && dojo.isIE < 9) ? document.createElement(html) : document.createElement("IFRAME");
	    app.appRoot.domNode.appendChild(f);
		f.style.display = "none";
		if (dojo.isMoz) {
			f.style.position = "absolute";
			f.style.left = f.style.top = "0px";
			f.style.opacity = 0;
			f.style.zIndex = 2;
		}
		dojo.subscribe("window-resize", this, "size")
	},
    setShowing: function(inShowing,forceChange) {
		if (!this.domNode)
			return;
		if (forceChange || inShowing != this.showing) {
			this.domNode.style.display = inShowing ? "" : "none";
			this.showing = inShowing;
		}
		if (inShowing)
			this.size();

	},
	size: function(inNode) {
		if (!this.domNode || !this.showing)
			return;
		if (inNode)
			this.sizeNode = inNode;
		var sizeNode = this.sizeNode || document.body;
		dojo.marginBox(this.domNode, dojo.contentBox(sizeNode));
	}
};

dojo.addOnLoad(function() {
	// iframe covering required on IE6 and (wah) on FF2 Mac
	if ((dojo.isIE && dojo.isIE < 7) || (dojo.isFF && dojo.isFF < 4 && navigator.userAgent.indexOf("Macintosh") != -1))
		wm.bgIframe.create();
});


dojo.declare("wm.DialogResize", wm.MouseDrag, {
	beginResize: function(e, inSplitter) {
		this.dialog = inSplitter;
		this.mousedown(e);
	},
	drag: function() {
		this.inherited(arguments);
		this.dialog.drag(this.dx, this.dy);
	},
	finish: function() {
		this.inherited(arguments);
		this.dialog.drop();
	}
});


dojo.declare("wm.Dialog", wm.Container, {
    manageHistory: true,
    manageURL: false,
    enableTouchHeight: true,
    titlebarButtons: "",
    containerClass: "MainContent",
    corner: "cc", // center vertical, center horizontal; this is almost always the desired default... but for some nonmodal dialogs, its useful to have other options
    scrim: true,

    useContainerWidget: false,  // if true, we create a container widget, if false we just use the dom node directly.  dom node is fine if you just want to set innerHTML or stick a 3rd party widget into the dialog.
    useButtonBar: false,
    _minified: false,
    _maxified: false,
    noEscape: false,
    noMinify: false,
    noMaxify: false,
	layoutKind: "top-to-bottom",
    horizontalAlign: "left",
    verticalAlign: "top",
	border: 2,
    borderColor: "rgb(80,80,80)",
    titlebarBorder: "1",
    titlebarBorderColor: "black",
    titlebarHeight: "23",
    mobileTitlebarHeight: "35",
    titleBarButtonsOnRight: false,
    footerBorder: "1,0,0,0",
    containerPadding: "5",
/*
	contentWidth: 640,
	contentHeight: 400,
	*/
    margin: "3",
    width: "640px",
    height: "400px",
	showing: false,
        dialogScrim: null,
	modal: true,
    showTitleButtonsWhenDocked:false,
    noLeftRightDocking: true,
    noTopBottomDocking: true,
    constructor: function() {
	wm.Dialog.resizer = wm.Dialog.resizer || new wm.DialogResize();
    },
    init: function() {
	if (wm.isMobile) this.titlebarHeight = this.mobileTitlebarHeight;
        this.inherited(arguments);
	if (this._isDesignLoaded) {
	    this.flags.noModelDrop = true;
	}

	if (!this.docked) {
	    if (this._isDesignLoaded)
		studio.designer.domNode.appendChild(this.domNode);
	    else
		app.appRoot.domNode.appendChild(this.domNode);
	}
	this.dialogScrim = new wm.Scrim({owner: this, _classes: {domNode: ["wmdialog-scrim"]}, waitCursor: false});

	this.createTitle();
	if (!this._isDesignLoaded)
	    this.connectEvents(this.domNode, ["mousedown"]);
    },
	postInit: function() {
		this.inherited(arguments);

	    this._animEnabled = true;
	    if (dojo.isIE <= 9 || wm.isAndroid <= 3 || this._noAnimation) this._animEnabled = false;

	    if (this._animEnabled) {
		    var transitionEnd;
		    if (dojo.isWebKit) {
			transitionEnd = 'webkitAnimationEnd';
		    } else if (dojo.isIE) {
			transitionEnd = 'MSAnimationEnd'; // lowercase requried
		    } else if (dojo.isOpera) {
			transitionEnd = 'oanimationend';
		    } else {
			transitionEnd = "animationend";
		    }
		    this.domNode.addEventListener( transitionEnd, dojo.hitch(this, "animEnd"), false);
	    }

		dojo.addClass(this.domNode, "wmdialog");
/*
		this.setContentWidth(this.contentWidth);
		this.setContentHeight(this.contentHeight);
		*/
		this.domNode.style.position = "absolute";
	    if (!this.docked) {
		this.domNode.style.zIndex = wm.dialog.getNextZIndex(this._isDesignLoaded);
	    }
            if (this.designWrapper)
                this.designWrapper.domNode.style.zIndex = this.domNode.style.zIndex+1;
	    if (!this.docked)
		this.domNode.style.display = "none";
	    this._connections.push(this.connect(document, "keydown", this, "keydown"));
	    this._subscriptions.push(dojo.subscribe("window-resize", this, "windowResize"));

	    this.setModal(this.modal);

	    this.setTitlebarBorder(this.titlebarBorder);
            this.setTitlebarBorderColor(this.titlebarBorderColor);


	    var containerWidget, containerNode;

            // set the owner to wm.Page to allow othis to be written... IF its an instance not a subclass of wm.Dialog
            var owner = (this.declaredClass == "wm.Dialog" || this._pageOwnsWidgets) ? this.owner : this;


            // If the dialog has only a single widget inside of it, thats the titlebar, and the rest of it hasn't yet been created and needs creating.
            // If the dialog has more than one widget inside of it, then its safe to assume everything this dialog needs has been created

	    /* containerWidgetId is undefined if the page was last saved prior to adding support for this property. Currently the
	    * id is only used by designabledialog*/
	    if (this.containerWidgetId !== undefined) {
		// if its defined and empty, then there is no containerWidget
		if (this.containerWidgetId) {
		    containerWidget = this.owner.getValueById(this.containerWidgetId);
		    if (!containerWidget) return;
		    containerNode = containerWidget.domNode;
		}
	    } else if (this.c$.length == 1) {
	        if (this.useContainerWidget) {
	            containerWidget = this.containerWidget ||  new wm.Container({
			_classes: {domNode: ["wmdialogcontainer", this.containerClass]},
			name: owner.getUniqueName("containerWidget"),
			parent: this,
			owner: owner,
			layoutKind: "top-to-bottom",
			padding: this.containerPadding,
			fitToContentHeight: this.fitToContentHeight,
			margin: "0",
			border: "0",
			width: "100%",
			height: "100%",
			horizontalAlign: "left",
			verticalAlign: "top",
			autoScroll: true});
		    containerNode = containerWidget.domNode;
	        } else {
		    containerNode = this.domNode;
	        }
            } else {
		containerWidget = this.c$[1]; // could be undefined
	    }


	    /* buttonBarId is undefined if the page was last saved prior to adding support for this property. Currently the
	    * id is only used by designabledialog */
	    if (this.buttonBarId !== undefined) {
		if (this.buttonBarId) {
		    this.buttonBar = this.owner.getValueById(this.buttonBarId);
		}
	    } else if (this.c$.length < 3) {
                // use of buttonbar is only accepted if useContainerWidget is true
               	if (this.useButtonBar && this.useContainerWidget) {
                    this.createButtonBar();
                }
            } else {
		this.buttonBar = this.c$[2];       // could be undefined
	    }

/*
            if (this.containerWidget)
                this.containerWidget.noInspector = true;
            if (this.buttonBar)
                this.buttonBar.noInspector = true;
		*/

	    // must set this AFTER creating the button bar, or the button
	    // bar will be ADDED to the containerWidget
	    if (containerWidget) {
		this.containerWidget = containerWidget;
	    }
	    this.containerNode = containerNode;
	    if (this.docked)
		this.show();
	},
    setUseButtonBar: function(inUse) {
        this.useButtonBar = inUse;
        if (inUse && !this.buttonBar) {
            this.createButtonBar();
            this.reflow();
        } else if (!inUse && this.buttonBar) {
            this.buttonBar.destroy();
            delete this.buttonBar;
            this.reflow();
        }
    },
    createButtonBar: function() {
        var owner = (this.declaredClass == "wm.Dialog" || this instanceof wm.DesignableDialog) ? this.owner : this;
        this.buttonBar = new wm.ButtonBarPanel({
            name: "buttonBar",
            owner: owner,
            parent: this,
            border: this.footerBorder,
            borderColor: this.titlebarBorderColor
        });
        this.reflow();
    },
    setTitlebarBorder: function(inBorder) {
        this.titlebarBorder = inBorder;
        var border = (String(inBorder).match(",")) ? inBorder : "0,0," + inBorder + ",0";
        this.titleBar.setBorder(border);
        this.titleBar.setHeight((parseInt(this.titlebarHeight) + this.titleBar.padBorderMargin.t + this.titleBar.padBorderMargin.b) + "px");
    },
    setTitlebarBorderColor: function(inBorderColor) {
        this.titlebarBorderColor = inBorderColor;
        this.titleBar.setBorderColor(inBorderColor);
    },
    setFooterBorder: function(inBorder) {
        this.footerBorder = inBorder;
        if (this.buttonBar) {
            this.buttonBar.setBorder(inBorder);
            //this.$.buttonBar.setHeight((34 + this.$.buttonBar.padBorderMargin.t + this.$.buttonBar.padBorderMargin.b) + "px");
        }
    },
    setFooterBorderColor: function(inBorderColor) {
        this.footerBorderColor = inBorderColor;
        if (this.buttonBar)
            this.buttonBar.setBorderColor(inBorderColor);
    },

    setModal: function(inModal) {
        dojo[inModal ? "removeClass" : "addClass"](this.domNode, "nonmodaldialog");
        this.modal = (inModal === undefined || inModal === null) ? true : inModal;

        if (this.dojoMoveable) {
            this.dojoMoveable.destroy();
            this.dojoMoveable = null;
        }
        if (!inModal && !this.dojoMoveable) {
            this.dojoMoveable = new dojo.dnd.Moveable(this.domNode, {
                handle: this.titleLabel.domNode
            });
            this.connect(this.dojoMoveable, "onMouseDown", this, function() {
                if (!this.modal) {
                    if (this.docked) {
                        this._userSized = true;
                        this.setDocked(false);
                    }
                    var zindex = wm.dialog.getNextZIndex(this._isDesignLoaded, this);
                    this.domNode.style.zIndex = zindex;
                }
            });
            this.connect(this.dojoMoveable, "onMoveStop", this, function() {
                if (this._openingTitleBarMenu) return;
                this._userSized = true;
                this.bounds.l = parseInt(this.domNode.style.left);
                this.bounds.t = parseInt(this.domNode.style.top);
                if (!this._maxified) {
                    if (!this.insureDialogVisible(true)) {
                        if (this.bounds.t < 0 && !this.noTopBottomDocking || this.bounds.t + this.bounds.h > app.appRoot.bounds.b && !this.noTopBottomDocking || this.bounds.l < 0 && !this.noLeftRightDocking || this.bounds.w + this.bounds.l > app.appRoot.bounds.r && !this.noLeftRightDocking) {
                            this.setDocked(true);
                        }
                    }
                }
                this.setBounds(this.bounds); // recalcualtes right and bottom borders

                if (!this.docked) {
                    var rerender = false;
                     if (this.bounds.l > app.appRoot.bounds.r) {
                                this.bounds.l = app.appRoot.bounds.r - 100;
                                rerender = true;
                            }
                            if (this.bounds.r < 0) {
                                this.bounds.l = - this.bounds.w + 100;
                                rerender = true;
                            }
                            if (this.bounds.t > app.appRoot.bounds.b) {
                                this.bounds.t = app.appRoot.bounds.b - 100;
                                rerender = true;
                            }
                             /* If user drags it above the top of the screen, the titlebar can't be reached to move it back, so don't allow this */
                            if (this.bounds.t < 0) {
                                this.bounds.t = 0;
                                rerender = true;
                            }
                            if (rerender) {
                                this.setBounds(this.bounds);
                                wm.Control.prototype.renderBounds.call(this);
                            }
                }
            });
        }
        if (this.showing && !this._isDesignLoaded) {
            this.dialogScrim.setShowing(this.modal);
            wm.bgIframe.setShowing(!this.modal && !this.isDesignedComponent());
        }
        this.titleButtonPanel.setShowing(!this.modal && (!this.docked || this.showTitleButtonsWhenDocked));
    },
    setNoEscape: function(inNoEscape) {
        this.noEscape = inNoEscape;
        this.titleClose.setShowing(!this.modal && !this.noEscape && !wm.isMobile);
    },
    setDocked: function(inDock, optionalParent, optionalEdge) {
        if (this._isDesignLoaded) return;
        var wasDocked = this.docked
        if (Boolean(wasDocked) == Boolean(inDock)) return;
        this.docked = inDock;
        if (inDock) {
            this._dock(optionalParent, optionalEdge);
            dojo.addClass(this.domNode, "Docked");
        } else {
            this._undock();
            dojo.removeClass(this.domNode, "Docked");
        }
    },
    _dock: function(parent, edge) {
	var border = this.border;
	var margin = this.margin;
	if (!edge) {
	    if (this.bounds.t < 0 && !this.noTopBottomDocking)
		edge = "t";
	    else if (this.bounds.t+this.bounds.h > app.appRoot.bounds.b  && !this.noTopBottomDocking)
		edge = "b";
	    else if (this.bounds.l < 0 && !this.noLeftRightDocking)
		edge = "l";
	    else if (!this.noLeftRightDocking)
		edge = "r";
	}
	if (!this.showTitleButtonsWhenDocked) {
	    this.titleButtonPanel.hide();
	}

	this._dockData = dojo.clone(this.bounds);
	this._dockData.edge = edge;
	this._dockData.border = border;
	this._dockData.margin = margin;
	this.setBorder("0");
	this.setMargin("0");
	if (!parent) {
	    if (edge == "t" && app.dockTop && !app.dockTop.parent.isAncestorHidden()) {
		parent = app.dockTop;
	    } else if (edge == "b" && app.dockBottom && !app.dockBottom.parent.isAncestorHidden()) {
		parent = app.dockBottom;
	    } else if (edge == "l" && app.dockLeft && !app.dockLeft.parent.isAncestorHidden()) {
		parent = app.dockLeft;
	    } else if (edge == "r" && app.dockRight && !app.dockRight.parent.isAncestorHidden()) {
		parent = app.dockRight;
	    } else {
		parent = app.appRoot;
	    }
	}

	if (!parent.showing) {
	    parent.setShowing(true);
	}

	if (parent == app.appRoot) {
	    app.dockDialog(this, edge);
	} else {
	    this.setParent(parent);
	    this.setWidth("100%");
	    this.setHeight("100%");
	    parent.show();
	    parent.reflow();
	}
	this.onDock();
    },
    onDock: function() {},
    _undock: function() {
	this.docked = false;
	if (!wm.isMobile) {
	    this.titleButtonPanel.show();
	}

	if (!this._dockData) {
	    this._dockData = dojo.clone(this.bounds);
	}
	if (this._dockData.edge == "t" || this._dockData.edge == "b") {
	    this._dockData.t = Math.floor(dojo.coords(this.domNode).y);
	} else {
	    this._dockData.l = Math.floor(dojo.coords(this.domNode).x);
	}
	this._cupdating = true;
	if (this._dockData.border !== undefined)
	    this.setBorder(this._dockData.border);
	else
	    this.setBorder(wm.Dialog.prototype.border);
	if (this._dockData.margin !== undefined)
	    this.setMargin(this._dockData.margin);
	else
	    this.setMargin(wm.Dialog.prototype.margin);

	this.setWidth( ((this._dockData.w||this.bounds.w) -20) + "px");
	this.setHeight(((this._dockData.h||this.bounds.h) -20) + "px");
	this.setBounds({t: this._dockData.t || this.bounds.t, l: this._dockData.l || this.bounds.l});
	this._cupdating = false;

	delete this._dockData;
	var parent = this.parent;
	app.removeDockedDialog(this); // TODO
	if (this._isDesignLoaded)
	    studio.designer.domNode.appendChild(this.domNode);
	else
	    app.appRoot.domNode.appendChild(this.domNode);

	this.render();
	this.flow();

	if (parent.dockRight || parent.dockLeft || parent.dockTop || parent.dockBottom) {
	    if (parent.c$.length == 0) {
		parent.hide();
	    } else {
		parent.reflow();
	    }
	} else {
	    app.reflow();
	}
	this.onUndock();
    },
    onUndock: function() {},
    minify: function() {
	this._minified = true;
	this.setShowing(false);
	if (!app.wmMinifiedDialogPanel) {
	    app.createMinifiedDialogPanel();
	}
	this.minifiedLabel = app.createMinifiedDialogLabel(this.title);
	this.minifiedLabel.connect(this.minifiedLabel, "onclick", this, function() {
	    app.removeMinifiedDialogLabel(this.minifiedLabel);
	    delete this.minifiedLabel;
	    app.wmMinifiedDialogPanel.reflow();
	    this._minified = false;
	    this.setShowing(true);
	});
	app.wmMinifiedDialogPanel.reflow();
    },
    unminify: function(inEvent, dontCallSetShowing) {
	if (!this._minified) return;
	app.removeMinifiedDialogLabel(this.minifiedLabel);
	delete this.minifiedLabel;
	    app.wmMinifiedDialogPanel.reflow();
	this._minified = false;
	if (!dontCallSetShowing)
	    this.show();
    },
    maxify: function() {
	if (this.docked) {
	    this._undock();
	}
	if (this._maxified) {
	    this._maxified = false;
        dojo.removeClass(this.domNode, "wmDialogMaxify");
	    //this.titleMaxify.setCaption(" ");
	    this.bounds.h = parseInt(this.height);
	    this.bounds.w = parseInt(this.width);
	} else {
	    this._maxified = true;
        dojo.addClass(this.domNode, "wmDialogMaxify");
	    //this.titleMaxify.setCaption("O");
	}
	this.renderBounds();
	this.reflow();
    },

    windowResize: function() {
	this.reflow();
	this.delayedRenderBounds();
    },
	reflowParent: function() {
	    if (this.docked && this.parent) {
		this.parent.reflow();
	    } else {
		this.renderBounds();
		this.reflow();
	    }
	},

	dismiss: function(e) {
	        this.setShowing(false, false, true);
		var why = "" || dojo.isString(e) ? e : e && e.target && e.target.innerHTML;
		this.onClose(why);
		why = null;
	},
        destroy: function() {
	    this._destroying = true;
	    if (this._minified) {
		app.removeMinifiedDialogLabel(this.minifiedLabel);
		delete this.minifiedLabel;
	    }
	    if (this.showing)
		this.dismiss();
	    if (this.dialogScrim)
                this.dialogScrim.destroy();
	    if (this.minifiedLabel)
		this.minfiedLabel.destroy();
	    this.inherited(arguments);
	},
	flow: function() {
		if (this.showing) {
			// Dialog is responsible for rendering itself.
			this.renderBounds();
			this.inherited(arguments);
	// annoying hack
		    if (dojo.isChrome && this.buttonBar && !this._chromeButtonBarHack) {
			this._chromeButtonBarHack = true;
			this.buttonBar.bounds.h++;
			this.buttonBar.renderBounds();
		    }

		    this.dialogScrim.reflowParent();
		}
	},

    getPreferredFitToContentHeight: function() {
	var result = this.inherited(arguments);
	var min = this.minHeight;
	//result = result - this.marginExtents.t - this.marginExtents.b;
	return Math.max(min, result);
    },
    getPreferredFitToContentWidth: function() {
	var result = this.inherited(arguments);
	var min = this.minWidth;
	//result = result - this.marginExtents.l - this.marginExtents.r;
	return Math.max(min, result);
    },
	setFitToContentWidth: function(inFitToContent) {
	    this.inherited(arguments);
	    this.reflow();
	},
	setFitToContentHeight: function(inFitToContent) {
	    this.inherited(arguments);
	    this.reflow();
	},

    delayedRenderBounds: function() {
	wm.job(this.getRuntimeId() + ".renderBounds", 5, dojo.hitch(this, function() {
	    var bounds = dojo.clone(this.bounds);
	    this.renderBounds();
	    if (bounds.w != this.bounds.w || bounds.h != this.bounds.h)
		this.reflow();
	}));
    },
    renderBounds: function() {
	    if (this.docked)
		return this.inherited(arguments);

		if (this.showing) {
		    if (this.fitToContentHeight && !this._userSized) {
			this.bounds.h = this.getPreferredFitToContentHeight();
			this.height = this.bounds.h + "px";
		    }
		    if (this.fitToContentWidth && !this._userSized) {
			this.bounds.w = this.getPreferredFitToContentWidth();
			this.width = this.bounds.w + "px";
		    }
		    if (this._minified) {
			var parentBox = app.appRoot.bounds; //dojo.contentBox(window.document.body);
			var t = parentBox.h - 30;
			var l = parentBox.w - 200;
			this.setBounds(l,t,200,30);
		    } else if (this._maxified) {
			var parentBox = app.appRoot.bounds; //dojo.contentBox(window.document.body);
			this.setBounds(20,20,parentBox.w-40,parentBox.h-40);
		    } else {
			//// center within parent
			//var parentBox = dojo.contentBox(this.domNode.parentNode);
			//var bounds = this.getBounds();
			if (this._userSized) {
			    this.insureDialogVisible();
                        } else {
			    if (!this.fixPositionNode && this.positionNear) {
				var widget = this.owner.getValueById(this.positionNear);
				if (widget) this.fixPositionNode = widget.domNode;
			    }
                            if (this.fixPositionNode) {
				this.renderBoundsByPositionNode();
                            } else if (!this._fixPosition) {
				this.renderBoundsByCorner();
				/*
				  var t = (parentBox.h - bounds.h) / 2;
				  var l = (parentBox.w - bounds.w) / 2;
				  this.setBounds(l, t);
				  this.domNode.style.top = t + "px";
				  this.domNode.style.left = l + "px";
				*/
                            } else {
				this.insureDialogVisible();
                            }
		            wm.bgIframe.size();
			}
		    }
/*
		    if (this.isDesignedComponent())
			this.dialogScrim.size(studio.designer.domNode);
			*/
		    return this.inherited(arguments);
		}
	},
        // This should be able to take both the human readable value "top right", and also the streamlined "tr" and have it work regardless.
    // Note that vertical axis must always come before horizontal axis
    setCorner: function(inCorner) {
        this.corner = inCorner.replace(/top/, "t").replace(/bottom/,"b").replace(/left/,"l").replace(/right/,"r").replace(/center/,"c").replace(/ /,"");
	if (this.positionNear) {
	    this.renderBoundsByPositionNode();
	} else {
            this.renderBoundsByCorner();
	}
    },
/* if the dialog is off the edge of the screen, attempt to compensate */
    insureDialogVisible: function(testOnly) {
	if (!this.showing) return;
        var w = this.bounds.w;
        var h = this.bounds.h;
        //var isDesigned =  (this.domNode.parentNode != document.body);
	//var isDesigned =  (this.domNode.parentNode != app.appRoot.domNode);
	var isDesigned = this._isDesignLoaded;
        var W = (isDesigned) ? studio.designer.bounds.w : (app._page) ? app._page.root.bounds.w : window.clientWidth;
        var H = (isDesigned) ? studio.designer.bounds.h : (app._page) ? app._page.root.bounds.h : window.clientHeight;
        if (this.bounds.t + this.bounds.h > H) {
            if (testOnly) return false;
            else this.bounds.t = H - this.bounds.h;
        }
        if (this.bounds.l + this.bounds.w > W) {
            if (testOnly) return false;
            else this.bounds.l = W - this.bounds.w;
        }
        if (this.bounds.t < 0) {
            if (testOnly) return false;
            else this.bounds.t = 0;
        }
        if (this.bounds.l < 0) {
            if (testOnly) return false;
            else this.bounds.l = 0;
        }
        if (!testOnly)
	    wm.Control.prototype.renderBounds.call(this);
        return true;
    },

    // TODO: Add property to control whether dialog goes below, above, left or right
    renderBoundsByPositionNode: function() {
        if (!this.fixPositionNode) return;
	var o = dojo._abs(this.fixPositionNode);

	if (this._isDesignLoaded) {
	    var designerO = dojo._abs(studio.designer.domNode);
	    o.x -= designerO.x;
	    o.y -= designerO.y;
	}
	var corner = this.corner || "bc";
        var top  = corner.substring(0,1);
        var left = corner.substring(1,2);

	switch(left) {
	case "l":
	    this.bounds.l = o.x - this.bounds.w;
	    break;
	case "r":
	    this.bounds.l = o.x + o.w;
	    break;
	case "c":
	    this.bounds.l = o.x + (o.w-this.bounds.w)/2;
	}
	switch(top) {
	case "t":
	    this.bounds.t = o.y - this.bounds.h;
	    break;
	case "b":
            this.bounds.t = o.y + o.h;
	    break;
	case "c":
	    this.bounds.t = o.y + (o.h-this.bounds.h)/2;
	}
        this.insureDialogVisible();
	this.setBounds(this.bounds); // recalcualtes right and bottom borders
/*
        if (!this.insureDialogVisible(true)) {
            this.bounds.t = o.y - this.bounds.h;
            if (!this.insureDialogVisible(true)) {
                this.bounds.t = o.y;
                this.bounds.l = o.x + o.w;
                if (!this.insureDialogVisible(true)) {
                    this.bounds.l = o.x - this.bounds.w;
                    this.insureDialogVisible(false); // if all test up to this point have failed, force it to fit here.
                    return; // insureDialogVisible calls renderBounds
                }
            }
        }

	wm.Control.prototype.renderBounds.call(this);
	*/
    },
    renderBoundsByCorner: function() {
        if (!this.showing) return;
        var w = this.width;
        var h = this.height;

        var isDesigned = this._isDesignLoaded;
        var W = (isDesigned) ? studio.designer.bounds.w : this.domNode.parentNode.clientWidth;
        var H = (isDesigned) ? studio.designer.bounds.h : this.domNode.parentNode.clientHeight;


        if (String(w).match(/\%/)) {
            w = W * parseInt(w) / 100;
        } else {
            w = parseInt(w);
        }

        if (String(h).match(/\%/)) {
            h = H * parseInt(h) / 100;
        } else {
            h = parseInt(h);
        }

        //if (!this._isDesignLoaded) {
        var buffer = 10;
        if (w > W - buffer * 2) w = W - buffer * 2;
        if (h > H - buffer * 2) h = H - buffer * 2;
        //}
        var t, l;

        var top = this.corner.substring(0, 1);
        var left = this.corner.substring(1, 2);
        var showingList = [];
        var thisownerapp = this.getOwnerApp();
        if (!this._percEx.h && !this._percEx.w) {
            for (var i = 0; i < wm.dialog.showingList.length; i++)
            if (wm.dialog.showingList[i] != this && wm.dialog.showingList[i].getOwnerApp() == thisownerapp && (!window["studio"] || this != window["studio"].dialog)) showingList.push(wm.dialog.showingList[i]);
            h = parseInt(h);
            var last = wm.Array.last(showingList);
        }
        switch (left) {
        case "l":
            l = buffer;
            break;
        case "r":
            l = W - w - buffer;
            break;
        case "c":
            l = Math.floor((W - w) / 2);
            if (last && last.corner == this.corner) l += 25; // offset it if its over another dialog so that there's a better (though not certain) chance of the dialog below being visible


            break;
        }

        switch (top) {
        case "t":
            t = buffer;
            break;
        case "b":
            t = H - h - buffer;
            break;
        case "c":
            t = Math.floor((H - h) / 2);
            if (last && last.corner == this.corner) t += 25;
            break;
        }

        this.setBounds(l, t, w, h);
        wm.Control.prototype.renderBounds.call(this);
    },
    setContent: function(inContent) {
        this.containerNode.innerHTML = inContent;
    },
    animEnd: function() {
        if (this.showing) {
            //this.domNode.style.opacity = 1; // needed for IE 9 beta
            //this.callOnShowParent();
        } else {
            if (this.docked) this.setDocked(false);
            this.domNode.style.display = "none";
        }
    },
    setShowing: function(inShowing, forceChange, skipOnClose) {
        if (app.debugDialog) var ignoreFunctions = ["_setValue", "setProp","setValue"];

        /* Manage some global states; showingList and zIndexes */
        wm.Array.removeElement(wm.dialog.showingList, this);
        if (!this.docked && inShowing && (!window["studio"] || this != window["studio"].dialog)) {
            var zindex = wm.dialog.getNextZIndex(this._isDesignLoaded);
            wm.dialog.showingList.push(this);
            this.domNode.style.zIndex = zindex;
            if (this.modal) {
                this.dialogScrim.domNode.style.zIndex = zindex - 1;
            }
        }


        /* Unminify */
        if (inShowing && this._minified) {
            this.unminify(null, true);
            delete this.showing; // stupid hack to fix bug in Safari Version 4.0.4 (6531.21.10)
        }


        /* Deal with the dialog's scrim alternate (this may not be needed anymore) */
        wm.bgIframe.setShowing(inShowing && this.modal && !this.isDesignedComponent());


        /* Deal with the dialog's scrim */
        if (inShowing != this.showing && this.modal && !this._isDesignLoaded) {
            this.dialogScrim.setShowing(inShowing);
        }

        var wasShowing = this.showing;
        var showingChanging = Boolean(this.showing) != Boolean(inShowing);
        if (showingChanging && this._animEnabled) {
            dojo.removeClass(this.domNode, ["fadeInAnim", "fadeOutAnim"]);
        }

        // set it to showing so that rendering can happen; but set it to almost hidden BEFORE display is set to block
        if (inShowing && showingChanging) {
            if (this._animEnabled) {
                this.domNode.opacity = 0.01;
            }
            this.inherited(arguments);
            if (this._animEnabled) {
                dojo.addClass(this.domNode, "fadeInAnim");
            } else {
                this.animEnd();
            }

            // individual dialogs may override this to focus on something more specific, but at a minimum, I want focus somewhere on/in the dialog when it shows
            if (this.modal && !this._noAutoFocus) {
                this.domNode.tabIndex = -1;
                this.domNode.focus();
            }
            if (app.debugDialog && this != app.debugDialog) {
                var i = 0;
                var caller = arguments.callee.caller;
                ignoreFunctions.push("show");
                while (caller && dojo.indexOf(ignoreFunctions, caller.nom) != -1 && i < 15) {
                    caller = caller.caller;
                    i++;
                }
                var eventId = app.debugDialog.newLogEvent({
                            eventType: "dialog",
                            sourceDescription: (caller && caller.nom ? caller.nom + "()" : ""),
                            resultDescription: "Showing dialog: " + this.getRuntimeId() + ".setShowing(true)",
                            firingId: this.getRuntimeId(),
                            affectedId: this.getRuntimeId(),
                            method: "show"
                        });

            }
            this.callOnShowParent();
            this.onShow();
            if (eventId) app.debugDialog.endLogEvent(eventId);

        } else if (!inShowing && showingChanging) {
            this.callOnHideParent();
            this.showing = Boolean(inShowing);

            if (this._animEnabled) {
                dojo.addClass(this.domNode, "fadeOutAnim");
            } else {
                this.animEnd();
            }
            this.showing = false;

            if (app.debugDialog && this != app.debugDialog) {
                var i = 0;
                var caller = arguments.callee.caller;
                ignoreFunctions.push("hide");
                while (caller && dojo.indexOf(ignoreFunctions, caller.nom) != -1 && i < 15) {
                    caller = caller.caller;
                    i++;
                }
                var eventId = app.debugDialog.newLogEvent({
                            eventType: "dialog",
                            sourceDescription: (caller && caller.nom ? caller.nom + "()" : ""),
                            resultDescription: "Hiding dialog: " + this.getRuntimeId() + ".setShowing(false)",
                            firingId: this.getRuntimeId(),
                            affectedId: this.getRuntimeId(),
                            method: "hide"
                        });

            }

            if (!skipOnClose && !this._minified) this.onClose("");
            if (eventId) app.debugDialog.endLogEvent(eventId);
        }



        if (this.designWrapper) this.designWrapper.setShowing(inShowing);

        // block tab from focusing on covered elements
        if (inShowing && this.modal && app && app._page && wm.isEmpty(wm.dialog.tabIndexChanges)) {
            dojo.query("input, button", app._page.root.domNode).forEach(function(input) {
                wm.dialog.tabIndexChanges[input.id] = input.tabIndex;
                input.tabIndex = -1;
            });
        } else if (!inShowing && this.modal) {
            wm.forEachProperty(wm.dialog.tabIndexChanges, function(inIndex, inId) {
                var node = dojo.byId(inId);
                if (node) node.tabIndex = inIndex || 0;
            });
            wm.dialog.tabIndexChanges = {};
        }

        // add to history whether we show or hide so that the URL updates
        if (!this._initializing && !this._isDesignLoaded && showingChanging && this.manageHistory) {
            app.addHistory({
                id: this.getRuntimeId(),
                options: {},
                title: "Hide " + this.title
            });
        }

    },
/*
        setShowing: function(inShowing, forceChange, skipOnClose) {
	    var animationTime = (this._cupdating || this.showing == inShowing || this._noAnimation || this._showAnimation && this._showAnimation.status() == "playing") ? 0 : app.dialogAnimationTime;

	    // First show/hide the scrim if we're modal
	    if (inShowing != this.showing && this.modal && !this._isDesignLoaded)
		this.dialogScrim.setShowing(inShowing);

	    var wasShowing = this.showing;
	    var showingChanging = Boolean(this.showing) != inShowing;

	    // set it to showing so that rendering can happen
	    if (inShowing) {
		if (animationTime) {
		    this.domNode.opacity = 0.01;
		}
		this.inherited(arguments);
		if (this.modal && !this._noAutoFocus) {
                    this.domNode.tabIndex = -1;
                    this.domNode.focus(); // individual dialogs may override this to focus on something more specific, but at a minimum, I want focus somewhere on/in the dialog when it shows
		}
	    }


		// global flag for easily finding the most recently shown dialog
	        wm.Array.removeElement(wm.dialog.showingList, this);

	    if (inShowing && (!window["studio"] || this != window["studio"].dialog)) {
		var zindex =  wm.dialog.getNextZIndex(this._isDesignLoaded);
		wm.dialog.showingList.push(this);
	        this.domNode.style.zIndex = zindex;
		if (this.modal) {
		    this.dialogScrim.domNode.style.zIndex = zindex-1;
		}
            }

		if (inShowing) {
		    if (this._minified)
			this.unminify(null, true);
		    //this.reflow();
		    delete this.showing; // stupid hack to fix bug in Safari Version 4.0.4 (6531.21.10)
		    this.showing = true;
		    this.flow();
		}
	    wm.bgIframe.setShowing(inShowing && this.modal && !this.isDesignedComponent());

	    if (this.designWrapper)
		this.designWrapper.setShowing(inShowing);


	    if (inShowing && this._hideAnimation) {
		this._hideAnimation.stop();
		this.domNode.style.opacity = 1;
		wasShowing = true; // its still showing, skip animating showing it again and just show it
		delete this._hideAnimation;

	    } else if (!inShowing && this._showAnimation) {
		this._showAnimation.stop();
		delete this._showAnimation;

	    }

	    if (inShowing && !wasShowing) {
		this.callOnShowParent();
		if (animationTime) {
		    if (!this._showAnimation) {
			if (app.debugDialog) {
			    var eventChain = app.debugDialog.cacheEventChain();
			}
			this._showAnimation =
			    dojo.animateProperty({node: this.domNode,
						  properties: {opacity: 1},
						  duration: animationTime,
						  onEnd: dojo.hitch(this, function() {
						      if (eventChain) {
							  app.debugDialog.restoreEventChain(eventChain);
						      }
			                              this.domNode.style.opacity = 1; // needed for IE 9 beta
                                                      this.onShow();
						  if (eventChain) {
						      app.debugDialog.clearEventChain();
						  }
						  })});
			this._showAnimation.play();
		    }
		} else {
		    this.onShow();
		}

	    } else if (!inShowing && wasShowing) {
		this.callOnHideParent();
		if (animationTime) {
		    if (!this._hideAnimation) {
			if (app.debugDialog) {
			    var eventChain = app.debugDialog.cacheEventChain();
			}
                        this._transitionToHiding = true;
			this._hideAnimation =
			dojo.animateProperty({node: this.domNode,
					      properties: {opacity: 0.01},
					      duration: animationTime,
					      onEnd: dojo.hitch(this, function() {
                                                  if (this.isDestroyed) return;
						  if (eventChain) {
						      app.debugDialog.restoreEventChain(eventChain);
						  }
						      wm.Control.prototype.setShowing.call(this,inShowing,forceChange, skipOnClose);
						  if (this.docked) this.setDocked(false);
                                                  delete this._transitionToHiding;
						      if (!skipOnClose && !this._minified)
						          this.onClose("");
						      delete this._hideAnimation; // has no destroy method
						  if (eventChain) {
						      app.debugDialog.clearEventChain();
						  }
					      })});
			    this._hideAnimation.play();
		    }
		} else {
		    this.inherited(arguments);
		    if (this.docked) this.setDocked(false);
		    if (!skipOnClose && !this._minified)
			this.onClose("");
		}
	    }
	    // add to history whether we show or hide so that the URL updates
	    if (!this._initializing && !this._isDesignLoaded &&  showingChanging && this.manageHistory) {
		app.addHistory({id: this.getRuntimeId(),
				options: {},
				title: "Hide " + this.title});
	    }

	},
	*/
/*
	setContentWidth: function(inWidth) {
		this.contentWidth = inWidth;
		this.setWidth(inWidth + "px");
	},

	setContentHeight: function(inHeight) {
		this.contentHeight = inHeight;
		this.setHeight(inHeight + "px");
	},
	setContentSize: function(inWidth, inHeight) {
		this.setContentWidth(inWidth);
		this.setContentHeight(inHeight);
	},
	*/
    canProcessKeyboardEvent: function(inEvent) {
        if (!this.showing || this.docked) return false;
            var dialogs = dojo.query(".wmdialog");
            var zindex = parseInt(this.domNode.style.zIndex);
            for (var i = 0; i < dialogs.length; i++) {
                if (dialogs[i].style.display != "none" && parseInt(dialogs[i].style.zIndex) > zindex) {
                    return false; // this isn't the foremost dialog
                }
            }
	return true;

    },
    _onEsc: function() {},
	keydown: function(inEvent) {
	    if (!this.canProcessKeyboardEvent(inEvent))
		return true;

	    if (inEvent.keyCode == dojo.keys.ESCAPE && !this.noEscape) {
		if (this._isDesignLoaded && studio.selected.getParentDialog() == this) return;
		if (this.showing) {
		    this.callOnHideParent();
		    this._onEsc();
		    this.setShowing(false);
		    this.onClose("cancel");
		    if (!this._isDesignLoaded)
			inEvent._wmstop = true;
		    dojo.stopEvent(inEvent);
		}
	    } else if (inEvent.keyCode == dojo.keys.ENTER) {
                if (this.$.textInput && this.$.textInput.getDataValue)
                    this.onEnterKeyPress(this.$.textInput.getDataValue(), inEvent);
                else
                    this.onEnterKeyPress("", inEvent);
            }
            return true;
	},
        onEnterKeyPress: function(inText) {
        },
	onShow: function() {
	},
	onClose: function(inWhy) {
	},
        handleBack: function(inOptions) {
	    if (!this.showing && !this._showAnimation)
		return false;

	    this.hide();
	    return true;
	},
    restoreFromLocationHash: function(inValue) {
	this.show();
    },
    generateStateUrl: function(stateObj) {
	if (this.showing || this._showAnimation && !this._isDesignLoaded)
	    stateObj[this.getRuntimeId()] = 1;
    },
    setTitlebarHeight: function(inHeight) {
        this.titlebarHeight = inHeight;
        if (this.titleBar) this.titleBar.setHeight(inHeight + "px");
    },
    createTitle: function() {
	var border = (String(this.titlebarBorder).match(",")) ? this.titlebarBorder : "0,0," + this.titlebarBorder + ",0";
	this.titleBar = new wm.Container({_classes: {domNode: ["dialogtitlebar"]},
					  showing: this.title,
					  name: "titleBar",
					  parent: this,
					  owner: this,
					  width: "100%",
					  desktopHeight: this.titlebarHeight + "px",
                      mobileHeight: this.mobileTitlebarHeight + "px",
					  margin: "0",
					  padding: "0",
					  border: border,
					  borderColor: this.titlebarBorderColor,
					  verticalAlign: "middle",
					  layoutKind: "left-to-right",
					  flags: {notInspectable: true}});
/*
	if (wm.isMobile) {
	    if (!wm.Dialog.titlebarMenu) {
		wm.Dialog.titlebarMenu = app.createComponents({
		    _dialogTitlebarMenu: ["wm.PopupMenu", {}]
		},app)[0];
	    }
	}
	*/


	var buttonPanel = this.titleButtonPanel = new wm.Panel({parent: this.titleBar,
					owner: this,
					name: "titleButtonBar",
					width: wm.isMobile ? this.mobileTitlebarHeight + "px": (!this.noEscape ? 20 : 0) + (!this.noMinify ? 20 : 0) + (!this.noMaxify ? 20 : 0) + "px",
					height: "100%",
					layoutKind: "left-to-right",
					horizontalAlign: "left",
					verticalAlign: "top",
					showing: !this.modal && (!this.docked  || this.showTitleButtonsWhenDocked)
				       });
	if (wm.isMobile) {
	    this.menuButton = new wm.MobileIconButton({
		                                 direction: "down",
						 noInspector: true,
						 name: "menuButton",
						 width: this.mobileTitlebarHeight + "px",
						 height: "100%",
						 margin: "0",
						 parent: buttonPanel,
						 owner: this,
						 onclick: dojo.hitch(this, function(inEvent) {
						     this.setShowing(false);
/*
						     wm.Dialog.titlebarMenu.setFullStructure([
							 {"label":"Close","separator":undefined,"defaultLabel":"Close","iconClass":undefined,"imageList":undefined,"idInPage":undefined,"isCheckbox":false,"onClick":dojo.hitch(this,"hide"),"children":[]},
							 {"label":"Minimize","separator":undefined,"defaultLabel":"Minimize","iconClass":undefined,"imageList":undefined,"idInPage":undefined,"isCheckbox":false,"onClick":dojo.hitch(this,"minify"),"children":[]},
							 {"label":"Full Size","separator":undefined,"defaultLabel":"Full Size","iconClass":undefined,"imageList":undefined,"idInPage":undefined,"isCheckbox":false,"onClick":dojo.hitch(this,"maxify"),"children":[]},
							 {"label":"Normal Size","separator":undefined,"defaultLabel":"Normal Size","iconClass":undefined,"imageList":undefined,"idInPage":undefined,"isCheckbox":false,"onClick":dojo.hitch(this,"maxify"),"children":[]}
						     ]);
						     wm.Dialog.titlebarMenu.renderDojoObj();
						     wm.Dialog.titlebarMenu.setItemShowing("Close", !this.noEscape);
						     wm.Dialog.titlebarMenu.setItemShowing("Minify", !this.noMinify);
						     wm.Dialog.titlebarMenu.setItemShowing("Full Size", !this.noMaxify && !this._maxified);
						     wm.Dialog.titlebarMenu.setItemShowing("Normal Size", this._maxified);
						     wm.Dialog.titlebarMenu.update(inEvent);
						     */
						 })
	    });


	}
	this.titleClose = new wm.ToolButton({_classes: {domNode: ["dialogclosebutton"]},
					     noInspector: true,
					     name: "titleClose",
                                             hint: wm.getDictionaryItem("wm.Dialog.HINT_CLOSE"),
					     width: "19px",
					     height: "19px",
					     margin: "3,0,0,3",
					     parent: buttonPanel,
					     owner: this,
					     showing: !this.noEscape && !wm.isMobile});
	this.titleMinify = new wm.ToolButton({_classes: {domNode: ["dialogminifybutton"]},
					      noInspector: true,
                                             hint: wm.getDictionaryItem("wm.Dialog.HINT_MINIFY"),
					      name: "titleMinify",
					      width: "19px",
					      height: "19px",
					      margin: "3,0,0,3",
					     parent: buttonPanel,
					      owner: this,
					      showing:  !this.noMinify  && !wm.isMobile});

	this.titleMaxify = new wm.ToolButton({_classes: {domNode: ["dialogmaxifybutton"]},
					  noInspector: true,
                                              hint: wm.getDictionaryItem("wm.Dialog.HINT_MAXIFY"),
					      name: "titleMinify",
					      caption: " ",
					      width: "19px",
					      height: "19px",
					      margin: "3,0,0,3",
					     parent: buttonPanel,
					      owner: this,
					      showing: !this.noMaxify && !wm.isMobile});

	this.titleLabel = new wm.Label({
					  noInspector: true,
	                                name: "dialogTitleLabel",
					parent: this.titleBar,
					owner: this,
					caption: this.title,
					showing: Boolean(this.title),
					margin: "3,3,0,10",
					width: "100%",
					height: "100%"});
	//this.titleBevel = new wm.Bevel({ parent: this, owner: this, showing: Boolean(this.title) });
	this.connect(this.titleClose, "onclick", this, "dismiss");
	this.connect(this.titleMinify, "onclick", this, "minify");
	this.connect(this.titleMaxify, "onclick", this, "maxify");

    	if (this.titlebarButtons && !wm.isMobile) {
    	    var buttonList = this.titlebarButtons.split(/\s*,\s*/);
    	    for (var i = 0; i < buttonList.length; i++) {
    		new wm.ToolButton({_classes: {domNode: [buttonList[i]]},
    				   noInspector: true,
    				   name: buttonList[i],
    				   caption: " ",
    				   width: "19px",
    				   height: "19px",
    				   margin: "3,0,0,3",
    				   parent: this.titleBar,
    				   owner: this,
    				   onclick: dojo.hitch(this, "onMiscButtonClick", buttonList[i])
    				  });
    	    }
    	    new wm.Spacer({owner: this,
    			   parent: this.titleBar,
    			   width: "5px"});

    	}
        if (this.titleBarButtonsOnRight) {
            this.titleBar.c$.reverse();
            buttonPanel.c$.reverse();
        }
    },
    onMiscButtonClick: function(inButtonName) {},
    setTitlebarButtons: function(inButtons) {
	this.titlebarButtons = inButtons;
	this.titleBar.destroy();
	this.createTitle();
	this.moveControl(this.titleBar,0);
	this.reflow();
    },
    setNoMinify: function(val) {
        this.noMinify = val;
        if (this.titleMinify)
            this.titleMinify.setShowing(!val && !wm.isMobile);
    },
    setNoMaxify: function(val) {
        this.noMaxify = val;
        if (this.titleMaxify)
            this.titleMaxify.setShowing(!val && !wm.isMobile);
    },
    setTitle: function(inTitle) {
	this.title = inTitle;
	if (this.titleLabel) {
	    this.titleLabel.setCaption(inTitle);
	    this.titleLabel.setShowing(true);
	}
	if (this.titleBar)
	    this.titleBar.setShowing(Boolean(inTitle));
    },
    setSizeProp: function(n, v, inMinSize) {
	this.inherited(arguments);
	if (v && v.match("%")) {
	}
	if (this.docked) return;
	if (this.isReflowEnabled())
	    this.renderBounds();
	if(this.designWrapper) {
	    this.designWrapper.controlBoundsChange();
	    this.designWrapper.renderBounds();
	}
        this.reflow();
    },

    // this is what is called when you bind an event handler to a dialog
    update: function() {
	this.show();
    },
    // design only; fired when dialog is selected; we want it to autoshow when selected in the designer
    activate: function() {
	this.show();
    },
    // design only; fired when dialog is selected; we want it to autohide when deselected in the designer
    deactivate: function() {
	this.hide();
    },


    /* Resizing */
    mousedown: function(e) {
        if (!this.modal && !this.docked) {
            var zindex = wm.dialog.getNextZIndex(this._isDesignLoaded, this);
            this.domNode.style.zIndex = zindex;
        }

        /* Can only target the dialog's node if hitting the border or if some bad rendering of content */
        /* noMaxify is taken to mean that the dialog isn't designed to be resized, either to max size or any custom size */
        if (!this.modal && !this.noMaxify && e.target == this.domNode) {

            this._initialPosition = dojo.clone(this.bounds);

            var leftTarget = e.clientX - this.marginExtents.l - this.borderExtents.l;
            var rightTarget = e.clientX;
            var topTarget = e.clientY - this.marginExtents.t - this.borderExtents.t;
            var bottomTarget = e.clientY;

            if (leftTarget - 12 <= this.bounds.l && leftTarget + 12 >= this.bounds.l) {
                this._dragBorderX = "left";
            } else if (rightTarget - 12 <= this.bounds.r && rightTarget + 12 >= this.bounds.r) {
                this._dragBorderX = "right";
            } else {
                this._dragBorderX = "";
            }
            if (topTarget - 12 <= this.bounds.t && topTarget + 12 >= this.bounds.t) {
                this._dragBorderY = "top";
            } else if (bottomTarget - 12 <= this.bounds.b && bottomTarget + 12 >= this.bounds.b) {
                this._dragBorderY = "bottom";
            } else {
                this._dragBorderY = "";
            }
            switch (this._dragBorderX + this._dragBorderY) {
            case "lefttop":
                wm.Dialog.resizer.setCursor("nw-resize");
                break;
            case "leftbottom":
                wm.Dialog.resizer.setCursor("sw-resize");
                break;
            case "righttop":
                wm.Dialog.resizer.setCursor("ne-resize");
                break;
            case "rightbottom":
                wm.Dialog.resizer.setCursor("se-resize");
                break;
            case "top":
                wm.Dialog.resizer.setCursor("n-resize");
                break;
            case "bottom":
                wm.Dialog.resizer.setCursor("s-resize");
                break;
            case "left":
                wm.Dialog.resizer.setCursor("w-resize");
                break;
            case "right":
                wm.Dialog.resizer.setCursor("e-resize");
                break;
            }
            wm.Dialog.resizer.beginResize(e, this);
        }
    },
    drag: function(inDx, inDy) {
        this._userSized = true;
        if (this._dragBorderX == "left") {
            this.setBounds(this._initialPosition.l + inDx, NaN, this._initialPosition.w - inDx, NaN);
        } else if (this._dragBorderX == "right") {
            this.setBounds(NaN, NaN, this._initialPosition.r - this._initialPosition.l + inDx, NaN);
        }


        if (this._dragBorderY == "top") {
            this.setBounds(NaN, this._initialPosition.t + inDy, NaN, this._initialPosition.h - inDy, NaN);
        } else if (this._dragBorderY == "bottom") {
            this.setBounds(NaN, NaN, NaN, this._initialPosition.b - this._initialPosition.t + inDy);
        }

        this.renderBounds();
        if (!dojo.isIE || dojo.isIE >= 9) {
            if (this.docked) {
                app.reflow();
            } else {
                this.reflow();
            }
        }

    },
    drop: function() {
        this.reflow();
    },
    setPositionNear: function(inWidgetOrName) {
        if (inWidgetOrName instanceof wm.Component) {
            this.positionNear = inWidgetOrName.getId();
            this.fixPositionNode = inWidgetOrName.domNode;
        } else {
            this.positionNear = inWidgetOrName;
            var widget = this.owner.getValueById(inWidgetOrName);
            this.fixPositionNode = widget ? widget.domNode : null;
        }
        this.renderBounds();
    },
    adjustFlowForMobile: function() {}
});


dojo.declare("wm.ButtonBarPanel", wm.Panel, {
    classNames: "wmcontainer wmpanel dialogfooter",        
    width: "100%",
    height: (wm.isMobile ? wm.Button.prototype.mobileHeight : wm.Button.prototype.desktopHeight) || wm.Button.prototype.height,
    padding: "0",
    desktopHeight: wm.Button.prototype.desktopHeight || wm.Button.prototype.height,
    mobileHeight: wm.Button.prototype.mobileHeight || wm.Button.prototype.height,
    enableTouchHeight: true,
    horizontalAlign: "right",
    verticalAlign: "top",
    fitToContentHeight: true,
    layoutKind: "left-to-right",
    init: function() {
        this.inherited(arguments);
        var d = this.isAncestorInstanceOf(wm.Dialog);
        if (d && (!d.buttonBar || d.buttonBar.isDestroyed)) d.buttonBar = this;
    },
    destroy: function() {
        var d = this.isAncestorInstanceOf(wm.Dialog);
        if (d && d.buttonBar == this) delete d.buttonBar;
        this.inherited(arguments);
    }
});

}

if(!dojo._hasResource["wm.base.widget.Dialogs.WidgetsJsDialog"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.widget.Dialogs.WidgetsJsDialog"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */


dojo.provide("wm.base.widget.Dialogs.WidgetsJsDialog");




dojo.declare("wm.WidgetsJsDialog", wm.Dialog, { 
    margin: "0,4,4,0",// for shadow styles
    useContainerWidget: true,
    widgets_data: null,
    widgets_json: "",
    width: "400px",
    height: "150px",

    setShowing: function(inShowing, forceChange) {
	this.inherited(arguments);
	if (this.isReflowEnabled() && !this._rendered) {
	    this.leafFirstRenderCss();
	    this._rendered = true;
	}
    },
    postInit: function() {
	this.inherited(arguments);
	if (!this.widgets_data)
	    this.setWidgetsJson(this.widgets_json);
	this.generateContents();
	this.containerWidget.setPadding("0");
	this.renderBounds();
	this.reflow();
    },

    setWidgetsJson: function(inJson) {
	try {
	    this.widgets_json = inJson;
	    this.widgets_data = dojo.fromJson(this.widgets_json);
	    if (!this._cupdating)
		this.generateContents();
	} catch(e) {console.error(e);}
    },
    generateContents: function() {
	if (this._generated) return;
	this._generated = true;
	this.containerWidget._cupdating = true;
	this.containerWidget.createComponents(this.widgets_data, this);
	this.containerWidget._cupdating = false;
	this.containerWidget.reflow();
	if (this.button_data) {
	    if (!this.buttonBar) {
		var containerWidget = this.containerWidget;
		var containerNode = this.containerNode;
		delete this.containerWidget;
		delete this.containerNode;
		this.createButtonBar();
		this.containerWidget = containerWidget;
		this.containerNode = containerNode;
	    }
	    this.buttonBar.createComponents(this.button_data, this);
	}
    }
});

}

if(!dojo._hasResource["wm.base.widget.Dialogs.Toast"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.widget.Dialogs.Toast"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */


dojo.provide("wm.base.widget.Dialogs.Toast");


dojo.declare("wm.Toast", wm.WidgetsJsDialog, {
    autoSetBorderColor: true,
    manageHistory: false,
    manageURL: false,
    classNames: "wmtoast wmtoastExtraSpecific",
    title: "",
    modal: false,
    useContainerWidget: true,
    _timeoutId: 0,
    duration: 5000,
    content: "Toast",
    height: "100px",
    width: "350px",
    corner: "br", // bottom right
    border: "2",
    margin: "0",
    imgHeight: "100%",
    imgWidth: "30px",
    imgMargin: "4,0,0,4",
    prepare: function() {
        this.inherited(arguments);
        this.widgets_data = {
	    img: ["wm.Picture", {_classes: {domNode: ["ToastLeft"]}, width: this.imgWidth, height: this.imgHeight, margin: this.imgMargin}],
    	    rightColumn: ["wm.Panel", {layoutKind: "top-to-bottom", width: "100%", height: "100%", fitToContentHeight: true, padding: "0"},{},{
        		title: ["wm.Label", {_classes: {domNode: ["wmtoasttitle"]}, height: "20px", width: "100%", singleLine: true}],
        		message: ["wm.Label", {_classes: {domNode: ["wmtoastmessage"]}, height: "100px", width: "100%", singleLine: false, autoSizeHeight: true}]
    	    }]
    	};
    },
    postInit: function() {
    	this.inherited(arguments);
    	this.containerWidget.setLayoutKind("left-to-right");
    	this.containerWidget.setPadding("4");	
            this.img = this.containerWidget.c$[0];
            this.title = this.containerWidget.c$[1].c$[0];
            this.message = this.containerWidget.c$[1].c$[1];

    	this.setContent(this.content);
    	this.connectEvents(this.domNode, ["click"]);
    },
    click: function() {
        this.hide();
        this.onToastClick();
    },
    onToastClick: function() {},
    setShowing: function(inShow, forceChange) {
    	if (!inShow) {
    	    window.clearTimeout(this._timeoutId);
    	    delete this._timeoutId;
    	}

        this.inherited(arguments);
        if (inShow) {
            this.renderBounds();
    	    this.domNode.style.zIndex = 1000;
    	}
    },
    renderBounds: function() {
        this.renderBoundsByCorner();
    },
    setContent: function(inContent) {
	   this.content = inContent;
       if (this.message)
            this.message.setCaption(inContent);
    },
    setTitle: function(inTitle) {
    	if (this.title)
    	    this.title.setCaption(inTitle);
    },
    // classes supported "Success", "Error", "Warning", "Info".  User may add their own classes via css file
    showToast: function(inContent,inDuration, inCssClasses, inPosition, optionalTitle) {
	    if (inContent instanceof Error) inContent = inContent.toString();
    	if (!inCssClasses) inCssClasses = "Info";
        if (inPosition) {
            inPosition = inPosition.replace(/top/, "t").replace(/bottom/,"b").replace(/left/,"l").replace(/right/,"r").replace(/center/,"c").replace(/ /,"");
        }
        this.corner = inPosition || app.toastPosition || "br";
    	if (this._timeoutId) {
    	    window.clearTimeout(this._timeoutId);
    	    this.hide();
    	    this._timeoutId = 0;
    	}

	    var localizedCssClasses = wm.getDictionaryItem("wm.Toast.STATUS_" + (inCssClasses||"").toUpperCase()) || "";
    
    	this.setTitle(optionalTitle || localizedCssClasses || inCssClasses);
        inCssClasses = inCssClasses || "Info";
        this._toastType = inCssClasses = inCssClasses || "Info";
        var classes = (inCssClasses) ? inCssClasses.split(" ") : [];

        if (this.autoSetBorderColor) {
            if (dojo.indexOf(classes, "Success") != -1) {
                this.setBorderColor("rgb(0,120,0)");
            } else if (dojo.indexOf(classes, "Error") != -1) {
                this.setBorderColor("rgb(120,0,0)");
            } else if (dojo.indexOf(classes, "Warning") != -1) {
                this.setBorderColor("#f9a215");
            } else {
                this.setBorderColor("rgb(0,0,0)");
            }
        }
        
        this.message.autoSizeHeight = false;
	   this.setContent(inContent);
        this.message.autoSizeHeight = true;
    	this.duration = inDuration || this.duration;
	   this.domNode.className = this.classNames + " " + ((inCssClasses) ? inCssClasses : "");
    	this.show();
	//this.setContent(inContent);
        this.message.doAutoSize(true, true);
	   this.containerWidget.removeDelayedReflow()
    	this.containerWidget.reflow();
        this.setHeight((this.containerWidget.padBorderMargin.t + this.containerWidget.padBorderMargin.b + this.message.parent.bounds.h + this.padBorderMargin.t + this
.padBorderMargin.b) + "px" );

        // After a timeout, animate the toast away
	   this._timeoutId = window.setTimeout(dojo.hitch(this, "hide"), this.duration);
/*
	this.domNode.style.opacity = "0.01";
	this.show();
        this.message.doAutoSize(true, true);
        this.setHeight((this.containerWidget.padBorderMargin.t + this.containerWidget.padBorderMargin.b + this.message.parent.bounds.h + this.padBorderMargin.t + this.padBorderMargin.b) + "px" );
	dojo.anim(this.domNode, { opacity: 1}, 800);
        */
    },
/*
    fadeaway: function(fromClick) {
        if (!this._timeoutId) return;
	this._timeoutId = 0;
        if (fromClick) {
	    dojo.anim(this.domNode, { opacity: 0 }, 200, null, dojo.hitch(this, function() {
                this.hide();
                this.domNode.style.opacity = 1;
            }));
        } else {
	    dojo.anim(this.domNode, { opacity: 0.01 }, 500, null, dojo.hitch(this, function() {this.hide();}));
        }
    },
    */
    // this is what is called when you bind an event handler to a dialog; call showToast so that the timer is triggered
    update: function() {
	   this.showToast(this.content,this.duration, this.domNode.className);
    }

});


}

if(!dojo._hasResource["wm.base.widget.Dialogs.GenericDialog"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.widget.Dialogs.GenericDialog"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */


dojo.provide("wm.base.widget.Dialogs.GenericDialog");


dojo.declare("wm.GenericDialog", wm.WidgetsJsDialog, {
    manageHistory: false,
    manageURL: false,
    enterKeyIsButton: 1,
    noEscape: true,
    title: "Generic Dialog",
    footerBorder: "",
    footerBorderColor: "",
    padding: "0",
    regExp: ".*",
    button1Caption: "",
    button2Caption: "",
    button3Caption: "",
    button4Caption: "",
    button1Close: false,
    button2Close: false,
    button3Close: false,
    button4Close: false,
    userPrompt: "Testing...",
    showInput: false,
    prepare: function() {
        this.inherited(arguments);
    	if ("enterKeyIsButton1" in this) {
    	    this.enterKeyIsButton = this.enterKeyIsButton1 ? 1 : 0;
    	    delete this.enterKeyIsButton1;
    	}
        this.widgets_data = {
    	    genericInfoPanel: ["wm.Panel", {layoutKind: "top-to-bottom", 
    					    width: "100%", 
    					    height: "100%", 
    					    horizontalAlign: "left", 
    					    verticalAlign: "top", 
    					    autoScroll: true, 
    					    fitToContentHeight: true, 
    					    padding: "10,5,10,5"}, {},
    			       {
    				   userQuestionLabel: ["wm.Html", {autoScroll: false, 
    								   "height":"25px",
    								   autoSizeHeight: true, 
    								   "width":"100%",
    								   html: ""}],
    				   textInput: ["wm.Text", {"width":"100%",
    							   "captionSize":"0%",
    							   "showing":false}, {}, {}]
    	    }]
    	};
    	this.button_data = {
    	    button4: ["wm.Button", {"width":"130px","showing":false}, {"onclick":"buttonClick"}],
    	    button3: ["wm.Button", {"width":"130px","showing":false}, {"onclick":"buttonClick"}],
    	    button2: ["wm.Button", {"width":"130px","showing":false}, {"onclick":"buttonClick"}],
    	    button1: ["wm.Button", {"width":"130px","showing":false}, {"onclick":"buttonClick"}]
    	};
        


    },
    postInit: function() {
        this.inherited(arguments);
        this.containerWidget = this.c$[1];
        this.containerWidget.flags.notInspectable = true;
        if (!this.buttonBar) {
            this.buttonBar = this.containerWidget.c$[this.containerWidget.c$.length - 1];
            this.buttonBar.flags.notInspectable = true;
            this.setFooterBorder(this.footerBorder);
            this.setFooterBorderColor(this.footerBorderColor);
        }
        if (this.regExp != ".*") this.$.textInput.setRegExp(this.regExp);

        var captionFound = false;
        for (var i = 1; i <= 6; i++) {
            var caption = this["button" + i + "Caption"];
            var button = this.$["button" + i];
            if (caption) {
                captionFound = true;
                button.setCaption(caption);
                if (this["button" + i + "Close"]) button.addUserClass("SubmitButton");
                button.show();
            }
            if (this.buttonBar) this.buttonBar.setShowing(captionFound);
            this.setShowInput(this.showInput);
        }
        if (this.$.userQuestionLabel) this.$.userQuestionLabel.setHtml(this.userPrompt);
        this.containerWidget.setFitToContentHeight(true);
    },
    setFooterBorder: function(inBorder) {
        this.footerBorder = inBorder;
        if (this.buttonBar) {
            this.buttonBar.setBorder(inBorder);
            this.buttonBar.setHeight((34 + this.buttonBar.padBorderMargin.t + this.buttonBar.padBorderMargin.b) + "px");
        }
    },
    setFooterBorderColor: function(inBorderColor) {
        this.footerBorderColor = inBorderColor;
        if (this.buttonBar)
            this.buttonBar.setBorderColor(inBorderColor);
    },
    // handle fitToContentHeight adjustments
    reflow: function() {
        try {
            if (this._userSized) {
                return this.inherited(arguments);
            } else if (!this._settingHeight) {
                var height = this.getPreferredFitToContentHeight();
                if (dojo.isChrome) height--; // stupid chrome bug...
                this._settingHeight = true;
                this.setHeight(height + "px");
                this._settingHeight = false;

                this.inherited(arguments);
            }
        } catch (e) {
            this._settingHeight = false;
        }

    },
    setShowing: function(inShowing,forceChange) {
        this.inherited(arguments);
        if (inShowing) {
            if (this.$.userQuestionLabel) {
                this.$.userQuestionLabel.doAutoSize(true,true);
            }
            if (this.showInput && this.$.textInput && this.$.textInput.focus) {
                this.$.textInput.focus();
            }
            wm.onidle(this, "reflow");
        }
    },
    setShowInput: function(inShowInput) {
	this.showInput = inShowInput;
        if (this.$.textInput) {
    	    this.$.textInput.setShowing(inShowInput);
    	}
    },

    setInputDataValue: function(inValue) {
        if (this.$.textInput) {
    	    this.$.textInput.setDataValue(inValue);
    	}
    },
    getInputDataValue: function(inValue) {
        var result;
        if (this.$.textInput) {
            result = this.$.textInput.getDataValue();
            if (dojo.isString(result)) result = dojo.trim(result);
            return result;
        }
    },
    setUserPrompt: function(inPrompt) {
        this.userPrompt = inPrompt;
        if (this.$.userQuestionLabel) this.$.userQuestionLabel.setHtml(inPrompt);
    },
    setButton1Caption: function(inCap) {this.setButtonCaption(1,inCap);},
    setButton2Caption: function(inCap) {this.setButtonCaption(2,inCap);},
    setButton3Caption: function(inCap) {this.setButtonCaption(3,inCap);},
    setButton4Caption: function(inCap) {this.setButtonCaption(4,inCap);},
    
    setButtonCaption: function(inButtonNumber, inButtonCaption) {
        var button = this.$["button" + inButtonNumber];
        this["button" + inButtonNumber + "Caption"] = inButtonCaption;
        if (!button) return;
        if (inButtonCaption) {
            button.setCaption(inButtonCaption);
            button.show();
        } else {
            button.hide();
        }
        if (this.buttonBar) this.buttonBar.setShowing(this.button1Caption || this.button2Caption || this.button3Caption || this.button4Caption);
    },
    onEnterKeyPress: function(inText, inEvent) {
        if (this.enterKeyIsButton) {
    	    this.buttonClick(this.$["button" + this.enterKeyIsButton]);
    	    dojo.stopEvent(inEvent);
        }
    },
    buttonClick: function(inSender) {
        var name = inSender.name;
        var id = parseInt(name.match(/\d+/)[0]);
        if (this["button" + id + "Close"]) this.dismiss();

        var text = (this.$.textInput) ? this.$.textInput.getDataValue() : "";
        switch (id) {
            case 1:
                this.onButton1Click(inSender, text);
                break;
            case 2:
                this.onButton2Click(inSender, text);
                break;
            case 3:
                this.onButton3Click(inSender, text);
                break;
            case 4:
                this.onButton4Click(inSender, text);
                break;
        }
    },
    onButton1Click: function(inButton, inText) {},
    onButton2Click: function(inButton, inText) {},
    onButton3Click: function(inButton, inText) {},
    onButton4Click: function(inButton, inText) {}
});

}

if(!dojo._hasResource["wm.base.widget.Dialogs.PageDialog"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.widget.Dialogs.PageDialog"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */


dojo.provide("wm.base.widget.Dialogs.PageDialog");




dojo.declare("wm.pageContainerMixin", null, {
    pageName: "",
    hideControls: false,
    pageProperties: null,
    deferLoad: false,
    // I'd rather this were true, but projects (AND STUDIO!) will break until users go through and change deferLoad back to false
    initPageContainer: function() {
        this.pageContainer = new wm.PageContainer({
            loadParentFirst: false,
            deferLoad: false,
            parent: this,
            owner: this,
            flex: 1,
            pageProperties: this.pageProperties
        });
        this._connections.push(this.connect(this.pageContainer, "onPageChanged", this, "_pageChanged"));
        this._connections.push(this.connect(this.pageContainer, "onError", this, "onError"));
        this.pageContainer.dismiss = dojo.hitch(this, "dismiss");
        if (this.pageName && !this.deferLoad) this.setPage(this.pageName);
        else this.pageContainer._pageName = this.pageName; // will load the page when PageContainer's reveal method is called
        this.createControls();
    },
    onError: function(inErrorOrMessage) {},
    setPage: function(inPageName) {
        if (inPageName) {
            if (this.pageContainer.pageName != inPageName) {
                if (this.page) this.page.root.hide();
                this.pageContainer.setPageName(inPageName);
            } else this.onPageReady();
        }
    },

    /* This is intended for use with app.pageDialog, a shared PageDialog that is reused with many pages; not intended for use
     * on PageDialogs added to a project */
    showPage: function(inPageName, inHideControls, inWidth, inHeight, inTitle, inModal) {
        if (inTitle !== undefined) this.setTitle(inTitle);
        if (inModal !== undefined) this.setModal(inModal);
        this.setContainerOptions(inHideControls, inWidth, inHeight);
        this.setShowing(true);
        this.setPage(inPageName);
        // IE requires reflow here
        this.reflow();
    },
    setContainerOptions: function(inHideControls, inWidth, inHeight) {
        this.setHideControls(inHideControls);
    },
    _pageChanged: function() {
        this.page = this.pageContainer.page;
        this[this.page.name] = this.page;
        this.onPageReady();
        this.reflow();
        wm.focusContainer(this.page.root);
    },
    onPageReady: function() {
    },
    forEachWidget: function(inFunc) {
        return this.pageContainer.forEachWidget(inFunc);
    },
    createControls: function() {
        var cp = this.controlsPanel = new wm.ButtonBarPanel({ parent: this,
                             owner: this,
                             layoutKind: "top-to-bottom",
                             horizontalAlign: "left",
                             verticalAlign: "top",
                             height: "40px",
                             width: "100%",
                                 border: this.footerBorder || "",
                             borderColor: this.footerBorderColor || "",
                             flags: {notInspectable: true}});
        if (!this.noBevel) {
            this.controlsBevel = new wm.Bevel({ parent: cp, owner: this });
        }
        var bp = this.buttonPanel = new wm.Panel({ parent: cp, owner: this, width: "100%", height: "100%", layoutKind: "left-to-right", horizontalAlign: "right", fitToContentHeight:true});
        dojo.addClass(bp.domNode, "wmpagedialog-controlspanel");
        this.closeButton = new wm.Button({ parent: bp,
                           owner: this,
                           caption:  wm.getDictionaryItem("wm.PageDialog.CAPTION_CLOSE"),
                           width: "80px"});
        this._connections.push(this.connect(this.closeButton, "onclick", this, "dismiss"));
        cp.setShowing(!this.hideControls);
        cp = null;
        bp = null;
    },
    setHideControls: function(inHideControls) {
        if (inHideControls !== undefined) {
            this.hideControls = inHideControls;
            this.controlsPanel.setShowing(!inHideControls);
        }
    },
    destroy: function() {
        if (this.controlsPanel)
        {
            this.controlsPanel.destroy();
            this.controlsPanel = null;
        }

        if (this.closeButton)
        {
            this.closeButton.destroy();
            this.closeButton = null;
        }

        if (this.controlsBevel)
        {
            this.controlsBevel.destroy();
            this.controlsBevel = null;
        }

        if (this.buttonPanel)
        {
            this.buttonPanel.destroy();
            this.buttonPanel = null;
        }


        if (this.pageContainer)
        {
            this.pageContainer.dismiss = null;
            this.pageContainer.destroy();
            this.pageContainer = null;
        }

        this.inherited(arguments);
    }
});

dojo.declare("wm.PageDialog", [wm.Dialog, wm.pageContainerMixin], {
    noBevel: false,
    footerBorder: "",
    footerBorderColor: "",
    postInit: function() {
        this.inherited(arguments);
        this.initPageContainer();
    },
    /*
    setShowing: function(inShow, forceChange) {
        this.inherited(arguments);
        if (this.deferLoad && inShow) this.setPage(this.pageName);
    },
    */
    setPageName: function(inPageName) {
        if (this._pageLoading) return;
        if (this.isDesignLoaded()) {
            var newPage = studio.getDictionaryItem("wm.PageContainer.NEW_PAGE_OPTION");
            if (inPageName == newPage) return this.pageContainer.createNewPage();
        }

        return this.setPage(inPageName);
    },
    setPage: function(inPageName) {
        this.pageName = inPageName;
        if (inPageName && this.pageContainer.pageName != inPageName) this.showLoadingIndicator();
        this.inherited(arguments);
    },
    setContainerOptions: function(inHideControls, inWidth, inHeight) {
        inWidth = inWidth || wm.Dialog.prototype.contentWidth;
        inHeight = inHeight || wm.Dialog.prototype.contentHeight;
        if (!dojo.isString(inWidth)) inWidth += "px";
        if (!dojo.isString(inHeight)) inHeight += "px";
        this.setWidth(inWidth);
        this.setHeight(inHeight);
        this.inherited(arguments);
    },
    hideLoadingIndicator: function() {
        if (this._loader) {
            dojo._destroyElement(this._loader);
            delete this._loader;
        }
    },
    showLoadingIndicator: function() {
        if (this.width < 150 || this.height < 80) return;
        var text = "&nbsp;Loading...";
        var imgsrc = wm.theme.getImagesPath() + "loadingThrobber.gif";
        this._loader = wm.createElement("div", {
            id: "_wm_loading_" + this.id,
            innerHTML: '<div class="_wm_loading" style="position: absolute; font-weight: bold; font-size: 10pt; z-index: 100; top: 40%; left: 40%;"><img alt="loading" style="vertical-align: middle" src="' + imgsrc + '" />' + text + '</div>'
        });
        this.domNode.appendChild(this._loader);
    },
    onPageReady: function() {
        this.hideLoadingIndicator();
    },

    destroy: function() {
        //this.pageContainerMixinDestroy();
        this.inherited(arguments);
        if (this.containerNode) {
            dojo.destroy(this.containerNode);
            this.containerNode = null;
        }

        this.c$ = [];
    },


    keydown: function(inEvent) {
        if (!this.canProcessKeyboardEvent(inEvent)) return true;
        if (inEvent.keyCode == dojo.keys.ESCAPE && this.page && this.page.onEscapeKey) {
            this.page.onEscapeKey()
        }
        this.inherited(arguments);
    }
});

}

if(!dojo._hasResource["wm.base.widget.Dialogs.DesignableDialog"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.widget.Dialogs.DesignableDialog"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */


dojo.provide("wm.base.widget.Dialogs.DesignableDialog");



/* Use designable dialog if your planning to design it in studio; if programatically creating a dialog use wm.Dialog */
dojo.declare("wm.DesignableDialog", wm.Dialog, {
    _pageOwnsWidgets: true,
    useButtonBar: false, // its false so we can add it in paletteDrop, but then the user can delete it if they want
    border: "1",
    borderColor: "black",
    titlebarBorder: "1",
    titlebarBorderColor: "black",
    footerBorderColor: "black",
    scrim: false,
    useContainerWidget: true,
    title: "Dialog",
    postInit: function() {
	this.inherited(arguments);
	delete this.containerNode; // containerNode is where child nodes get added to when appending children; just let the normal parent/child relationships prevail...
    }
});

}

if(!dojo._hasResource["wm.base.widget.Dialogs.LoadingDialog"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["wm.base.widget.Dialogs.LoadingDialog"] = true;
/*
 *  Copyright (C) 2012-2013 CloudJee, Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */


/* This dialog is designed to show whenever its "serviceVariableToTrack" is fired, and to cover the widget specified by widgetToCover when it shows.
 * This dialog can also be triggered via javascript:
 * call show/hide/setShowing to determine when its showing/hidden
 * set loadingdialog.widgetToCover = mywidget at any time; next call to show will cover the new widget. NOTE: Must have been hidden before next call to show.
 * Change the service variable to monitor at runtime with setServiceVariableToTrack.
 */
dojo.provide("wm.base.widget.Dialogs.LoadingDialog");


dojo.declare("wm.LoadingDialog", wm.Dialog, {
    caption: "Loading...",
    captionWidth: "60px",
    image: "",
    imageWidth: "20px",
    imageHeight: "20px",


    containerClass: "", // don't give the containerWidget any extra classes

    /* This is the widget that will be covered by this dialog */
    widgetToCover: null,

    /* OPTIONAL: Rather than calling show/hide, you may instead specify a servicevariable;
     * when that variable is firing, this is showing, when its not firing, this is not showing
     */
    serviceVariableToTrack: null,

    /* Do not use dialog class and styles */
    classNames: "wmloadingdialog wm_FontColor_White",

    useContainerWidget: true,

    /* This dialog will block clicking on the thing it covers, but does not block the rest of the page */
    modal: false,

    noMinify: true,
    noMaxify: true,
    noEscape: true,
    border: 0,
    title: "",
    _noAnimation: true,
/*
    _animationShowTime: 800,
    _opacity: 0.7,
    */
    postInit: function() {
	this.inherited(arguments);
	dojo.removeClass(this.domNode, "wmdialog");
	this.containerWidget.setLayoutKind("left-to-right");
	this.containerWidget.setVerticalAlign("middle");
	this.containerWidget.setHorizontalAlign("center");
	this.containerWidget.setFitToContentHeight();

	this.setImage(this.image);
	this.setCaption(this.caption);

	   this.setServiceVariableToTrack(this.serviceVariableToTrack);
    },
    setServiceVariableToTrack: function(inVars) {
	if (this._isDesignLoaded) return;
	
	if (inVars && inVars.length) {
        inVars = dojo.map(inVars, function(inVar) {
    	    if (dojo.isString(inVar)) {
    		  return this.owner.getValueById(inVar);
    		 } else {
    		  return inVar;
    		 }
  		 },this);    		 
	}
    if (inVars && !dojo.isArray(inVars)) inVars = [inVars];
	this.serviceVariableToTrack = inVars;
    if (this._onResultConnect) {
    	dojo.forEach(this._onResultConnect, function(c) {
    	   dojo.disconnect(c);
    	   wm.Array.removeElement(this._connections, c);	 
    	},this);
    	dojo.forEach(this._onRequestConnect, function(c) {
    	   dojo.disconnect(c);
    	   wm.Array.removeElement(this._connections, c);	 
    	},this);	
    }
      this._onResultConnect = [];
      this._onRequestConnect = [];
	  if (this.serviceVariableToTrack && this.serviceVariableToTrack.length) {	  
	       dojo.forEach(this.serviceVariableToTrack, function(svar) {
    	      this._onResultConnect.push(this.connect(svar, "onResult", dojo.hitch(this, "svarDone", svar)));
    	      this._onRequestConnect.push(this.connect(svar, "request", dojo.hitch(this, "svarStart", svar)));
    	   }, this);
	  }
    },
    svarDone: function(svar) {
        if (!this._currentSVars) this._currentSVars = [];
        wm.Array.removeElement(this._currentSVars, svar);
        if (this._currentSVars.length == 0) this.hide();
    },
    svarStart: function(svar) {
        if (!this._currentSVars) this._currentSVars = [];
        this._currentSVars.push(svar);
        if (!this.showing) this.show();
    },    
    show: function() {
	this._getWidgetToCover();
	if (this.widgetToCover && this.widgetToCover instanceof wm.Control && !this.widgetToCover.isAncestorHidden()) {
	    this.inherited(arguments);
	}
    },
    setImage: function(inUrl) {
	var image = this.image = inUrl;
	if (!image) {
	    image =  dojo.moduleUrl("lib.images.common").toString() +  "loadingThrobber.gif";
	}
	this._setImage(image);
    },
    _setImage: function(inUrl) {

	if (!this._picture) {
	    this._picture = new wm.Picture({owner: this,
					    parent: this.containerWidget,
					    name: "loadingPicture",
					    source: inUrl,
					    width: this.imageWidth,
					    height: this.imageHeight});
	} else {
	    this._picture.setSource(inUrl);
	}
    },
    setImageWidth: function(inWidth) {
	this.imageWidth = inWidth;
	if (this._picture) {
	    this._picture.setWidth(inWidth);
	}
    },
    setImageHeight: function(inHeight) {
	this.imageHeight = inHeight;
	if (this._picture) {
	    this._picture.setHeight(inHeight);
	}
    },
    setCaption: function(inCaption) {
	this.caption = inCaption;
	if (!this.caption)
	    return;
	if (!this._label) {
	    this._label = new wm.Label(
		{
		    owner: this,
		    parent: this.containerWidget,
		    name: "loadingLabel",
		    width: this.captionWidth,
		    height: "20px",
		    caption: inCaption,
		    singleLine: false,
		    autoSizeHeight: true
		});
	} else {
	    this._label.setCaption(this.caption);
	}
    },
    setShowing: function(inShowing, forceChange, skipOnClose) {
	this.inherited(arguments);
	if (inShowing) {
	    this._getWidgetToCover();
	    if (this.widgetToCover) {
	    this.setMargin(this.widgetToCover.margin);
		var node = this.widgetToCover.domNode;
        if (window.getComputedStyle) {
        	var roundedStyle, roundedStyleTL,roundedStyleTR, roundedStyleBL, roundedStyleBR;
            var computedStyle = window.getComputedStyle(node);
		    roundedStyle = computedStyle.getPropertyValue("border-radius") || computedStyle.getPropertyValue("-webkit-border-radius") || computedStyle.getPropertyValue("-moz-border-radius") || computedStyle.getPropertyValue("-ms-border-radius") || computedStyle.getPropertyValue("-o-border-radius");
			if (roundedStyle) {
			    this.domNode.style.borderRadius = roundedStyle;
			    if (dojo.isWebKit) {
			    	this.domNode.style.WebkitBorderRadius = roundedStyle;
				} else if (dojo.isFF) {
				    this.domNode.style.MozBorderRadius = roundedStyle;
				}
    		} else { /* else clause required by IE10 which only lets us access the individual corners and not the total value */
    			this.domNode.style.borderTopLeftRadius= computedStyle.getPropertyValue("border-top-left-radius");
    			this.domNode.style.borderTopRightRadius= computedStyle.getPropertyValue("border-top-right-radius");
    			this.domNode.style.borderBottomLeftRadius= computedStyle.getPropertyValue("border-bottom-left-radius");
    			this.domNode.style.borderBottomRightRadius= computedStyle.getPropertyValue("border-bottom-right-radius");    			
    		}
			
		}
		var zindex = node.style.zIndex || 0;
		while (node.parentNode && node.parentNode.tagName != "BODY") {
		    node = node.parentNode;
		    if (node.style.zIndex) {
			zindex = Math.max(zindex,node.style.zIndex);
		    }
		}
		this.domNode.style.zIndex = zindex+1;
	    }
	}
    },
    _getWidgetToCover: function() {
	if (this.widgetToCover) {
	    if (dojo.isString(this.widgetToCover))
		this.widgetToCover = this.owner.getValueById(this.widgetToCover);
	}
	return this.widgetToCover;
    },
    renderBounds: function() {
	this._getWidgetToCover();
	if (this.widgetToCover) {
	    try {
	    var parentNode = this.widgetToCover.domNode.parentNode;
	    if (this.domNode.parentNode != parentNode)
		parentNode.appendChild(this.domNode);
	    var b = dojo.clone(this.widgetToCover.bounds);
		b.l -= this.widgetToCover.borderExtents.l;
		b.r += this.widgetToCover.borderExtents.r;
		b.w = b.r-b.l;
		b.t -= this.widgetToCover.borderExtents.t;
		b.b += this.widgetToCover.borderExtents.b;
		b.h = b.b-b.t;
	    this.setBounds(b);
	    wm.Control.prototype.renderBounds.call(this);
	    } catch(e) {}
	}
    }
});


}


dojo.i18n._preloadLocalizations("dojo.nls.lib_build", ["ROOT","ar","ca","cs","da","de","de-de","el","en","en-au","en-gb","en-us","es","es-es","fi","fi-fi","fr","fr-fr","he","he-il","hu","it","it-it","ja","ja-jp","ko","ko-kr","nb","nl","nl-nl","pl","pt","pt-br","pt-pt","ru","sk","sl","sv","th","tr","xx","zh","zh-cn","zh-tw"]);
